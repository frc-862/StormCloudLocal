"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/* istanbul ignore if */
if (!Error.prepareStackTrace) {
  require('source-map-support/register');
}
/**
 * A lightweight, fixed-size value buffer.
 */


class NanoBuffer {
  /**
   * Creates a `NanoBuffer` instance.
   *
   * @param {Number} [maxSize=10] - The initial buffer size.
   */
  constructor(maxSize = 10) {
    if (typeof maxSize !== 'number') {
      throw new TypeError('Expected maxSize to be a number');
    }

    if (isNaN(maxSize) || maxSize < 0) {
      throw new RangeError('Expected maxSize to be zero or greater');
    }
    /**
     * The buffer where the values are stored.
     * @type {Array}
     * @access private
     */


    this._buffer = Array(maxSize | 0);
    /**
     * The index of the newest value in the buffer.
     * @type {Number}
     * @access private
     */

    this._head = 0;
    /**
     * The maximum number of values to store in the buffer.
     * @type {Number}
     * @access private
     */

    this._maxSize = maxSize;
    /**
     * The number of values in the buffer.
     * @type {Number}
     * @access private
     */

    this._size = 0;
  }
  /**
   * Returns the index of the newest value in the buffer.
   *
   * @returns {Number}
   * @access public
   */


  get head() {
    return this._head;
  }
  /**
   * Returns the maximum number of values in the buffer.
   *
   * @returns {Number}
   * @access public
   */


  get maxSize() {
    return this._maxSize;
  }
  /**
   * Changes the maximum number of values allowed in the buffer.
   *
   * @param {Number} newMaxSize - The new max size of the buffer.
   * @access public
   */


  set maxSize(newMaxSize) {
    if (typeof newMaxSize !== 'number') {
      throw new TypeError('Expected new max size to be a number');
    }

    if (isNaN(newMaxSize) || newMaxSize < 0) {
      throw new RangeError('Expected new max size to be zero or greater');
    }

    if (newMaxSize === this._maxSize) {
      // nothing to do
      return;
    } // somewhat lazy, but we create a new buffer, then manually copy
    // ourselves into it, then steal back the internal values


    const tmp = new NanoBuffer(newMaxSize);

    for (const value of this) {
      tmp.push(value);
    }

    this._buffer = tmp._buffer;
    this._head = tmp._head;
    this._maxSize = tmp._maxSize;
    this._size = tmp._size;
    tmp._buffer = null;
  }
  /**
   * Returns the number of values in the buffer.
   *
   * @returns {Number}
   * @access public
   */


  get size() {
    return this._size;
  }
  /**
   * Inserts a new value into the buffer.
   *
   * @param {*} value - The value to store.
   * @returns {NanoBuffer}
   * @access public
   */


  push(value) {
    if (this._maxSize) {
      if (this._size > 0) {
        this._head++;
      }

      if (this._head >= this._maxSize) {
        // we wrapped
        this._head = 0;
      }

      this._size = Math.min(this._size + 1, this._maxSize);
      this._buffer[this._head] = value;
    }

    return this;
  }
  /**
   * Removes all values in the buffer.
   *
   * @returns {NanoBuffer}
   * @access public
   */


  clear() {
    this._buffer = Array(this._maxSize);
    this._head = 0;
    this._size = 0;
    return this;
  }
  /**
   * Creates an iterator function for this buffer.
   *
   * @return {Function}
   * @access public
   */


  [Symbol.iterator]() {
    let i = 0;
    return {
      next: () => {
        // just in case the size changed
        i = Math.min(i, this._maxSize); // calculate the index

        let j = this._head + i - (this._size - 1);

        if (j < 0) {
          j += this._maxSize;
        } // console.log('\ni=' + i + ' head=' + this._head + ' size=' + this._size + ' maxSize=' + this._maxSize + ' j=' + j);


        const done = i++ >= this._size;
        return {
          value: done ? undefined : this._buffer[j],
          done
        };
      }
    };
  }

}

exports.default = NanoBuffer;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbIkVycm9yIiwicHJlcGFyZVN0YWNrVHJhY2UiLCJyZXF1aXJlIiwiTmFub0J1ZmZlciIsImNvbnN0cnVjdG9yIiwibWF4U2l6ZSIsIlR5cGVFcnJvciIsImlzTmFOIiwiUmFuZ2VFcnJvciIsIl9idWZmZXIiLCJBcnJheSIsIl9oZWFkIiwiX21heFNpemUiLCJfc2l6ZSIsImhlYWQiLCJuZXdNYXhTaXplIiwidG1wIiwidmFsdWUiLCJwdXNoIiwic2l6ZSIsIk1hdGgiLCJtaW4iLCJjbGVhciIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiaSIsIm5leHQiLCJqIiwiZG9uZSIsInVuZGVmaW5lZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0EsSUFBSSxDQUFDQSxLQUFLLENBQUNDLGlCQUFYLEVBQThCO0FBQzdCQyxFQUFBQSxPQUFPLENBQUMsNkJBQUQsQ0FBUDtBQUNBO0FBRUQ7Ozs7O0FBR2UsTUFBTUMsVUFBTixDQUFpQjtBQUMvQjs7Ozs7QUFLQUMsRUFBQUEsV0FBVyxDQUFDQyxPQUFPLEdBQUcsRUFBWCxFQUFlO0FBQ3pCLFFBQUksT0FBT0EsT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUNoQyxZQUFNLElBQUlDLFNBQUosQ0FBYyxpQ0FBZCxDQUFOO0FBQ0E7O0FBRUQsUUFBSUMsS0FBSyxDQUFDRixPQUFELENBQUwsSUFBa0JBLE9BQU8sR0FBRyxDQUFoQyxFQUFtQztBQUNsQyxZQUFNLElBQUlHLFVBQUosQ0FBZSx3Q0FBZixDQUFOO0FBQ0E7QUFFRDs7Ozs7OztBQUtBLFNBQUtDLE9BQUwsR0FBZUMsS0FBSyxDQUFDTCxPQUFPLEdBQUcsQ0FBWCxDQUFwQjtBQUVBOzs7Ozs7QUFLQSxTQUFLTSxLQUFMLEdBQWEsQ0FBYjtBQUVBOzs7Ozs7QUFLQSxTQUFLQyxRQUFMLEdBQWdCUCxPQUFoQjtBQUVBOzs7Ozs7QUFLQSxTQUFLUSxLQUFMLEdBQWEsQ0FBYjtBQUNBO0FBRUQ7Ozs7Ozs7O0FBTUEsTUFBSUMs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QWFrQixDQUFiLENBRHBCO0FBRU5DLFVBQUFBO0FBRk0sU0FBUDtBQUlBO0FBbEJLLEtBQVA7QUFvQkE7O0FBaEw4QiIsInNvdXJjZXNDb250ZW50IjpbIi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKCFFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSkge1xuXHRyZXF1aXJlKCdzb3VyY2UtbWFwLXN1cHBvcnQvcmVnaXN0ZXInKTtcbn1cblxuLyoqXG4gKiBBIGxpZ2h0d2VpZ2h0LCBmaXhlZC1zaXplIHZhbHVlIGJ1ZmZlci5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmFub0J1ZmZlciB7XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgYE5hbm9CdWZmZXJgIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21heFNpemU9MTBdIC0gVGhlIGluaXRpYWwgYnVmZmVyIHNpemUuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihtYXhTaXplID0gMTApIHtcblx0XHRpZiAodHlwZW9mIG1heFNpemUgIT09ICdudW1iZXInKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBtYXhTaXplIHRvIGJlIGEgbnVtYmVyJyk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzTmFOKG1heFNpemUpIHx8IG1heFNpemUgPCAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcignRXhwZWN0ZWQgbWF4U2l6ZSB0byBiZSB6ZXJvIG9yIGdyZWF0ZXInKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYnVmZmVyIHdoZXJlIHRoZSB2YWx1ZXMgYXJlIHN0b3JlZC5cblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQGFjY2VzcyBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fYnVmZmVyID0gQXJyYXkobWF4U2l6ZSB8IDApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGluZGV4IG9mIHRoZSBuZXdlc3QgdmFsdWUgaW4gdGhlIGJ1ZmZlci5cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBhY2Nlc3MgcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2hlYWQgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHZhbHVlcyB0byBzdG9yZSBpbiB0aGUgYnVmZmVyLlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGFjY2VzcyBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbWF4U2l6ZSA9IG1heFNpemU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIHZhbHVlcyBpbiB0aGUgYnVmZmVyLlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGFjY2VzcyBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fc2l6ZSA9IDA7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG5ld2VzdCB2YWx1ZSBpbiB0aGUgYnVmZmVyLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfVxuXHQgKiBAYWNjZXNzIHB1YmxpY1xuXHQgKi9cblx0Z2V0IGhlYWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hlYWQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdmFsdWVzIGluIHRoZSBidWZmZXIuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9XG5cdCAqIEBhY2Nlc3MgcHVibGljXG5cdCAqL1xuXHRnZXQgbWF4U2l6ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF4U2l6ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGFuZ2VzIHRoZSBtYXhpbXVtIG51bWJlciBvZiB2YWx1ZXMgYWxsb3dlZCBpbiB0aGUgYnVmZmVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gbmV3TWF4U2l6ZSAtIFRoZSBuZXcgbWF4IHNpemUgb2YgdGhlIGJ1ZmZlci5cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICovXG5cdHNldCBtYXhTaXplKG5ld01heFNpemUpIHtcblx0XHRpZiAodHlwZW9mIG5ld01heFNpemUgIT09ICdudW1iZXInKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBuZXcgbWF4IHNpemUgdG8gYmUgYSBudW1iZXInKTtcblx0XHR9XG5cblx0XHRpZiAoaXNOYU4obmV3TWF4U2l6ZSkgfHwgbmV3TWF4U2l6ZSA8IDApIHtcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCdFeHBlY3RlZCBuZXcgbWF4IHNpemUgdG8gYmUgemVybyBvciBncmVhdGVyJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG5ld01heFNpemUgPT09IHRoaXMuX21heFNpemUpIHtcblx0XHRcdC8vIG5vdGhpbmcgdG8gZG9cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBzb21ld2hhdCBsYXp5LCBidXQgd2UgY3JlYXRlIGEgbmV3IGJ1ZmZlciwgdGhlbiBtYW51YWxseSBjb3B5XG5cdFx0Ly8gb3Vyc2VsdmVzIGludG8gaXQsIHRoZW4gc3RlYWwgYmFjayB0aGUgaW50ZXJuYWwgdmFsdWVzXG5cdFx0Y29uc3QgdG1wID0gbmV3IE5hbm9CdWZmZXIobmV3TWF4U2l6ZSk7XG5cdFx0Zm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzKSB7XG5cdFx0XHR0bXAucHVzaCh2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fYnVmZmVyICA9IHRtcC5fYnVmZmVyO1xuXHRcdHRoaXMuX2hlYWQgICAgPSB0bXAuX2hlYWQ7XG5cdFx0dGhpcy5fbWF4U2l6ZSA9IHRtcC5fbWF4U2l6ZTtcblx0XHR0aGlzLl9zaXplICAgID0gdG1wLl9zaXplO1xuXG5cdFx0dG1wLl9idWZmZXIgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiB2YWx1ZXMgaW4gdGhlIGJ1ZmZlci5cblx0ICpcblx0ICogQHJldHVybnMge051bWJlcn1cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICovXG5cdGdldCBzaXplKCkge1xuXHRcdHJldHVybiB0aGlzLl9zaXplO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluc2VydHMgYSBuZXcgdmFsdWUgaW50byB0aGUgYnVmZmVyLlxuXHQgKlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHN0b3JlLlxuXHQgKiBAcmV0dXJucyB7TmFub0J1ZmZlcn1cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICovXG5cdHB1c2godmFsdWUpIHtcblx0XHRpZiAodGhpcy5fbWF4U2l6ZSkge1xuXHRcdFx0aWYgKHRoaXMuX3NpemUgPiAwKSB7XG5cdFx0XHRcdHRoaXMuX2hlYWQrKztcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX2hlYWQgPj0gdGhpcy5fbWF4U2l6ZSkge1xuXHRcdFx0XHQvLyB3ZSB3cmFwcGVkXG5cdFx0XHRcdHRoaXMuX2hlYWQgPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9zaXplID0gTWF0aC5taW4odGhpcy5fc2l6ZSArIDEsIHRoaXMuX21heFNpemUpO1xuXHRcdFx0dGhpcy5fYnVmZmVyW3RoaXMuX2hlYWRdID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwgdmFsdWVzIGluIHRoZSBidWZmZXIuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtOYW5vQnVmZmVyfVxuXHQgKiBAYWNjZXNzIHB1YmxpY1xuXHQgKi9cblx0Y2xlYXIoKSB7XG5cdFx0dGhpcy5fYnVmZmVyID0gQXJyYXkodGhpcy5fbWF4U2l6ZSk7XG5cdFx0dGhpcy5faGVhZCA9IDA7XG5cdFx0dGhpcy5fc2l6ZSA9IDA7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBpdGVyYXRvciBmdW5jdGlvbiBmb3IgdGhpcyBidWZmZXIuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiBAYWNjZXNzIHB1YmxpY1xuXHQgKi9cblx0W1N5bWJvbC5pdGVyYXRvcl0oKSB7XG5cdFx0bGV0IGkgPSAwO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdG5leHQ6ICgpID0+IHtcblx0XHRcdFx0Ly8ganVzdCBpbiBjYXNlIHRoZSBzaXplIGNoYW5nZWRcblx0XHRcdFx0aSA9IE1hdGgubWluKGksIHRoaXMuX21heFNpemUpO1xuXG5cdFx0XHRcdC8vIGNhbGN1bGF0ZSB0aGUgaW5kZXhcblx0XHRcdFx0bGV0IGogPSB0aGlzLl9oZWFkICsgaSAtICh0aGlzLl9zaXplIC0gMSk7XG5cdFx0XHRcdGlmIChqIDwgMCkge1xuXHRcdFx0XHRcdGogKz0gdGhpcy5fbWF4U2l6ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdcXG5pPScgKyBpICsgJyBoZWFkPScgKyB0aGlzLl9oZWFkICsgJyBzaXplPScgKyB0aGlzLl9zaXplICsgJyBtYXhTaXplPScgKyB0aGlzLl9tYXhTaXplICsgJyBqPScgKyBqKTtcblxuXHRcdFx0XHRjb25zdCBkb25lID0gaSsrID49IHRoaXMuX3NpemU7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dmFsdWU6IGRvbmUgPyB1bmRlZmluZWQgOiB0aGlzLl9idWZmZXJbal0sXG5cdFx0XHRcdFx0ZG9uZVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn1cbiJdLCJmaWxlIjoiaW5kZXguanMifQ==
