"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const errors = {};
var _default = errors;
exports.default = _default;
createError('ALREADY_EXISTS', Error, 'A object with the same name has already been registered and would overwrite the existing object');
createError('CONFLICT', Error, 'A parameter conflicts with the value of another parameter');
createError('DEFAULT_COMMAND_NOT_FOUND', Error, 'The default command was not found');
createError('EMPTY_STRING', Error, 'A string value was undefined, null, empty, or false');
createError('FILE_NOT_FOUND', Error, 'The file does not exist or access is restricted');
createError('INVALID_ALIAS', TypeError, 'An alias is empty, not a string, or an invalid format');
createError('INVALID_ARGUMENT', TypeError, 'A function argument is undefined or the incorrect data type');
createError('INVALID_CLIKIT_OBJECT', TypeError, 'A function was passed a cli-kit object that is not supported');
createError('INVALID_COMMAND', Error, 'The specified command or command parameters are not valid');
createError('INVALID_DATA_TYPE', Error, 'The CLI argument or option has been assigned an unsupported data type');
createError('INVALID_DATE', RangeError, 'A value was not a valid date');
createError('INVALID_EXTENSION', Error, 'Unable to load an extension due to bad path, bad package.json, missing main file, etc');
createError('INVALID_JSON', Error, 'The string does not contain valid JSON');
createError('INVALID_NODE_JS', Error, 'The current Node.js version is too old');
createError('INVALID_NUMBER', Error, 'Unable to parse value into the number');
createError('INVALID_OPTION', Error, 'The option parameters are incomplete or contains invalid values');
createError('INVALID_OPTION_FORMAT', TypeError, 'Unable to parse an option\'s foramt');
createError('INVALID_PACKAGE_JSON', Error, 'A package.json file does not exist, did not contain valid JSON, or define an object');
createError('INVALID_VALUE', Error, 'Unable to transform the value to the desired data type or conform to the required format');
createError('MISSING_REQUIRED_ARGUMENT', Error, 'A required command line argument was not found');
createError('MISSING_REQUIRED_OPTION', Error, 'A required command line option was not found');
createError('NO_EXECUTABLE', Error, 'Attempted to run an undefined executable');
createError('NOT_AN_OPTION', Error, 'An option is not an option and should be treated as an argument');
createError('NOT_YES_NO', RangeError, 'The value is not "yes", "y", "no", or "n"');
createError('RANGE_ERROR', RangeError, 'The value is not within the acceptable min/max range');
createError('TEMPLATE_NOT_FOUND', Error, 'The specified template file does not exist or access is denied');
createError('TYPE_ERROR', TypeError, 'A variable is undefined or the incorrect data type');
/**
 * Creates an the error object and populates the message, code, and metadata.
 *
 * @param {String} code - The error code.
 * @param {Error|RangeError|TypeError} type - An instantiable error object.
 * @param {String} desc - A generic error description.
 */

function createError(code, type, desc) {
  errors[code] = function (msg, meta) {
    const err = new type(msg);

    if (desc) {
      if (!meta) {
        meta = {};
      }

      meta.desc = desc;
    }

    return Object.defineProperties(err, {
      code: {
        configurable: true,
        enumerable: true,
        writable: true,
        value: `ERR_${code}`
      },
      meta: {
        configurable: true,
        value: meta || undefined,
        writable: true
      }
    });
  };

  Object.defineProperties(errors[code], {
    name: {
      configurable: true,
      value: code,
      writable: true
    },
    toString: {
      configurable: true,
      value: function toString() {
        return `ERR_${code}`;
      },
      writable: true
    }
  });
}
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9lcnJvcnMuanMiXSwibmFtZXMiOlsiZXJyb3JzIiwiY3JlYXRlRXJyb3IiLCJFcnJvciIsIlR5cGVFcnJvciIsIlJhbmdlRXJyb3IiLCJjb2RlIiwidHlwZSIsImRlc2MiLCJtc2ciLCJtZXRhIiwiZXJyIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwidW5kZWZpbmVkIiwibmFtZSIsInRvU3RyaW5nIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxNQUFNQSxNQUFNLEdBQUcsRUFBZjtlQUNlQSxNOztBQUVmQyxXQUFXLENBQUMsZ0JBQUQsRUFBZ0NDLEtBQWhDLEVBQTRDLGlHQUE1QyxDQUFYO0FBQ0FELFdBQVcsQ0FBQyxVQUFELEVBQWdDQyxLQUFoQyxFQUE0QywyREFBNUMsQ0FBWDtBQUNBRCxXQUFXLENBQUMsMkJBQUQsRUFBZ0NDLEtBQWhDLEVBQTRDLG1DQUE1QyxDQUFYO0FBQ0FELFdBQVcsQ0FBQyxjQUFELEVBQWdDQyxLQUFoQyxFQUE0QyxxREFBNUMsQ0FBWDtBQUNBRCxXQUFXLENBQUMsZ0JBQUQsRUFBZ0NDLEtBQWhDLEVBQTRDLGlEQUE1QyxDQUFYO0FBQ0FELFdBQVcsQ0FBQyxlQUFELEVBQWdDRSxTQUFoQyxFQUE0Qyx1REFBNUMsQ0FBWDtBQUNBRixXQUFXLENBQUMsa0JBQUQsRUFBZ0NFLFNBQWhDLEVBQTRDLDZEQUE1QyxDQUFYO0FBQ0FGLFdBQVcsQ0FBQyx1QkFBRCxFQUFnQ0UsU0FBaEMsRUFBNEMsOERBQTVDLENBQVg7QUFDQUYsV0FBVyxDQUFDLGlCQUFELEVBQWdDQyxLQUFoQyxFQUE0QywyREFBNUMsQ0FBWDtBQUNBRCxXQUFXLENBQUMsbUJBQUQsRUFBZ0NDLEtBQWhDLEVBQTRDLHVFQUE1QyxDQUFYO0FBQ0FELFdBQVcsQ0FBQyxjQUFELEVBQWdDRyxVQUFoQyxFQUE0Qyw4QkFBNUMsQ0FBWDtBQUNBSCxXQUFXLENBQUMs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QSxPQUpRO0FBS1RVLE1BQUFBLFFBQVEsRUFBRTtBQUxEO0FBTjJCLEdBQXRDO0FBY0EiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBlcnJvcnMgPSB7fTtcbmV4cG9ydCBkZWZhdWx0IGVycm9ycztcblxuY3JlYXRlRXJyb3IoJ0FMUkVBRFlfRVhJU1RTJywgICAgICAgICAgICAgIEVycm9yLCAgICAgICdBIG9iamVjdCB3aXRoIHRoZSBzYW1lIG5hbWUgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGFuZCB3b3VsZCBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIG9iamVjdCcpO1xuY3JlYXRlRXJyb3IoJ0NPTkZMSUNUJywgICAgICAgICAgICAgICAgICAgIEVycm9yLCAgICAgICdBIHBhcmFtZXRlciBjb25mbGljdHMgd2l0aCB0aGUgdmFsdWUgb2YgYW5vdGhlciBwYXJhbWV0ZXInKTtcbmNyZWF0ZUVycm9yKCdERUZBVUxUX0NPTU1BTkRfTk9UX0ZPVU5EJywgICBFcnJvciwgICAgICAnVGhlIGRlZmF1bHQgY29tbWFuZCB3YXMgbm90IGZvdW5kJyk7XG5jcmVhdGVFcnJvcignRU1QVFlfU1RSSU5HJywgICAgICAgICAgICAgICAgRXJyb3IsICAgICAgJ0Egc3RyaW5nIHZhbHVlIHdhcyB1bmRlZmluZWQsIG51bGwsIGVtcHR5LCBvciBmYWxzZScpO1xuY3JlYXRlRXJyb3IoJ0ZJTEVfTk9UX0ZPVU5EJywgICAgICAgICAgICAgIEVycm9yLCAgICAgICdUaGUgZmlsZSBkb2VzIG5vdCBleGlzdCBvciBhY2Nlc3MgaXMgcmVzdHJpY3RlZCcpO1xuY3JlYXRlRXJyb3IoJ0lOVkFMSURfQUxJQVMnLCAgICAgICAgICAgICAgIFR5cGVFcnJvciwgICdBbiBhbGlhcyBpcyBlbXB0eSwgbm90IGEgc3RyaW5nLCBvciBhbiBpbnZhbGlkIGZvcm1hdCcpO1xuY3JlYXRlRXJyb3IoJ0lOVkFMSURfQVJHVU1FTlQnLCAgICAgICAgICAgIFR5cGVFcnJvciwgICdBIGZ1bmN0aW9uIGFyZ3VtZW50IGlzIHVuZGVmaW5lZCBvciB0aGUgaW5jb3JyZWN0IGRhdGEgdHlwZScpO1xuY3JlYXRlRXJyb3IoJ0lOVkFMSURfQ0xJS0lUX09CSkVDVCcsICAgICAgIFR5cGVFcnJvciwgICdBIGZ1bmN0aW9uIHdhcyBwYXNzZWQgYSBjbGkta2l0IG9iamVjdCB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbmNyZWF0ZUVycm9yKCdJTlZBTElEX0NPTU1BTkQnLCAgICAgICAgICAgICBFcnJvciwgICAgICAnVGhlIHNwZWNpZmllZCBjb21tYW5kIG9yIGNvbW1hbmQgcGFyYW1ldGVycyBhcmUgbm90IHZhbGlkJyk7XG5jcmVhdGVFcnJvcignSU5WQUxJRF9EQVRBX1RZUEUnLCAgICAgICAgICAgRXJyb3IsICAgICAgJ1RoZSBDTEkgYXJndW1lbnQgb3Igb3B0aW9uIGhhcyBiZWVuIGFzc2lnbmVkIGFuIHVuc3VwcG9ydGVkIGRhdGEgdHlwZScpO1xuY3JlYXRlRXJyb3IoJ0lOVkFMSURfREFURScsICAgICAgICAgICAgICAgIFJhbmdlRXJyb3IsICdBIHZhbHVlIHdhcyBub3QgYSB2YWxpZCBkYXRlJyk7XG5jcmVhdGVFcnJvcignSU5WQUxJRF9FWFRFTlNJT04nLCAgICAgICAgICAgRXJyb3IsICAgICAgJ1VuYWJsZSB0byBsb2FkIGFuIGV4dGVuc2lvbiBkdWUgdG8gYmFkIHBhdGgsIGJhZCBwYWNrYWdlLmpzb24sIG1pc3NpbmcgbWFpbiBmaWxlLCBldGMnKTtcbmNyZWF0ZUVycm9yKCdJTlZBTElEX0pTT04nLCAgICAgICAgICAgICAgICBFcnJvciwgICAgICAnVGhlIHN0cmluZyBkb2VzIG5vdCBjb250YWluIHZhbGlkIEpTT04nKTtcbmNyZWF0ZUVycm9yKCdJTlZBTElEX05PREVfSlMnLCAgICAgICAgICAgICBFcnJvciwgICAgICAnVGhlIGN1cnJlbnQgTm9kZS5qcyB2ZXJzaW9uIGlzIHRvbyBvbGQnKTtcbmNyZWF0ZUVycm9yKCdJTlZBTElEX05VTUJFUicsICAgICAgICAgICAgICBFcnJvciwgICAgICAnVW5hYmxlIHRvIHBhcnNlIHZhbHVlIGludG8gdGhlIG51bWJlcicpO1xuY3JlYXRlRXJyb3IoJ0lOVkFMSURfT1BUSU9OJywgICAgICAgICAgICAgIEVycm9yLCAgICAgICdUaGUgb3B0aW9uIHBhcmFtZXRlcnMgYXJlIGluY29tcGxldGUgb3IgY29udGFpbnMgaW52YWxpZCB2YWx1ZXMnKTtcbmNyZWF0ZUVycm9yKCdJTlZBTElEX09QVElPTl9GT1JNQVQnLCAgICAgICBUeXBlRXJyb3IsICAnVW5hYmxlIHRvIHBhcnNlIGFuIG9wdGlvblxcJ3MgZm9yYW10Jyk7XG5jcmVhdGVFcnJvcignSU5WQUxJRF9QQUNLQUdFX0pTT04nLCAgICAgICAgRXJyb3IsICAgICAgJ0EgcGFja2FnZS5qc29uIGZpbGUgZG9lcyBub3QgZXhpc3QsIGRpZCBub3QgY29udGFpbiB2YWxpZCBKU09OLCBvciBkZWZpbmUgYW4gb2JqZWN0Jyk7XG5jcmVhdGVFcnJvcignSU5WQUxJRF9WQUxVRScsICAgICAgICAgICAgICAgRXJyb3IsICAgICAgJ1VuYWJsZSB0byB0cmFuc2Zvcm0gdGhlIHZhbHVlIHRvIHRoZSBkZXNpcmVkIGRhdGEgdHlwZSBvciBjb25mb3JtIHRvIHRoZSByZXF1aXJlZCBmb3JtYXQnKTtcbmNyZWF0ZUVycm9yKCdNSVNTSU5HX1JFUVVJUkVEX0FSR1VNRU5UJywgICBFcnJvciwgICAgICAnQSByZXF1aXJlZCBjb21tYW5kIGxpbmUgYXJndW1lbnQgd2FzIG5vdCBmb3VuZCcpO1xuY3JlYXRlRXJyb3IoJ01JU1NJTkdfUkVRVUlSRURfT1BUSU9OJywgICAgIEVycm9yLCAgICAgICdBIHJlcXVpcmVkIGNvbW1hbmQgbGluZSBvcHRpb24gd2FzIG5vdCBmb3VuZCcpO1xuY3JlYXRlRXJyb3IoJ05PX0VYRUNVVEFCTEUnLCAgICAgICAgICAgICAgIEVycm9yLCAgICAgICdBdHRlbXB0ZWQgdG8gcnVuIGFuIHVuZGVmaW5lZCBleGVjdXRhYmxlJyk7XG5jcmVhdGVFcnJvcignTk9UX0FOX09QVElPTicsICAgICAgICAgICAgICAgRXJyb3IsICAgICAgJ0FuIG9wdGlvbiBpcyBub3QgYW4gb3B0aW9uIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhbiBhcmd1bWVudCcpO1xuY3JlYXRlRXJyb3IoJ05PVF9ZRVNfTk8nLCAgICAgICAgICAgICAgICAgIFJhbmdlRXJyb3IsICdUaGUgdmFsdWUgaXMgbm90IFwieWVzXCIsIFwieVwiLCBcIm5vXCIsIG9yIFwiblwiJyk7XG5jcmVhdGVFcnJvcignUkFOR0VfRVJST1InLCAgICAgICAgICAgICAgICAgUmFuZ2VFcnJvciwgJ1RoZSB2YWx1ZSBpcyBub3Qgd2l0aGluIHRoZSBhY2NlcHRhYmxlIG1pbi9tYXggcmFuZ2UnKTtcbmNyZWF0ZUVycm9yKCdURU1QTEFURV9OT1RfRk9VTkQnLCAgICAgICAgICBFcnJvciwgICAgICAnVGhlIHNwZWNpZmllZCB0ZW1wbGF0ZSBmaWxlIGRvZXMgbm90IGV4aXN0IG9yIGFjY2VzcyBpcyBkZW5pZWQnKTtcbmNyZWF0ZUVycm9yKCdUWVBFX0VSUk9SJywgICAgICAgICAgICAgICAgICBUeXBlRXJyb3IsICAnQSB2YXJpYWJsZSBpcyB1bmRlZmluZWQgb3IgdGhlIGluY29ycmVjdCBkYXRhIHR5cGUnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIHRoZSBlcnJvciBvYmplY3QgYW5kIHBvcHVsYXRlcyB0aGUgbWVzc2FnZSwgY29kZSwgYW5kIG1ldGFkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2RlIC0gVGhlIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0ge0Vycm9yfFJhbmdlRXJyb3J8VHlwZUVycm9yfSB0eXBlIC0gQW4gaW5zdGFudGlhYmxlIGVycm9yIG9iamVjdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBkZXNjIC0gQSBnZW5lcmljIGVycm9yIGRlc2NyaXB0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFcnJvcihjb2RlLCB0eXBlLCBkZXNjKSB7XG5cdGVycm9yc1tjb2RlXSA9IGZ1bmN0aW9uIChtc2csIG1ldGEpIHtcblx0XHRjb25zdCBlcnIgPSBuZXcgdHlwZShtc2cpO1xuXG5cdFx0aWYgKGRlc2MpIHtcblx0XHRcdGlmICghbWV0YSkge1xuXHRcdFx0XHRtZXRhID0ge307XG5cdFx0XHR9XG5cdFx0XHRtZXRhLmRlc2MgPSBkZXNjO1xuXHRcdH1cblxuXHRcdHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlcnIsIHtcblx0XHRcdGNvZGU6IHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IGBFUlJfJHtjb2RlfWBcblx0XHRcdH0sXG5cdFx0XHRtZXRhOiB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IG1ldGEgfHwgdW5kZWZpbmVkLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGVycm9yc1tjb2RlXSwge1xuXHRcdG5hbWU6IHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiBjb2RlLFxuXHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHR9LFxuXHRcdHRvU3RyaW5nOiB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0XHRcdHJldHVybiBgRVJSXyR7Y29kZX1gO1xuXHRcdFx0fSxcblx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0fVxuXHR9KTtcbn1cbiJdLCJmaWxlIjoibGliL2Vycm9ycy5qcyJ9
