"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assertNodeJSVersion = assertNodeJSVersion;
exports.declareCLIKitClass = declareCLIKitClass;
exports.decodeHeader = exports.decode = decode;
exports.encodeHeader = exports.encode = encode;
exports.filename = filename;
exports.findPackage = findPackage;
exports.isExecutable = isExecutable;
exports.isFile = isFile;
Object.defineProperty(exports, "pkgDir", {
  enumerable: true,
  get: function () {
    return _pkgDir.default;
  }
});
exports.split = split;
exports.wrap = wrap;

var _argvSplit = _interopRequireDefault(require("argv-split"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _errors = _interopRequireDefault(require("./errors"));

var _path = _interopRequireDefault(require("path"));

var _pkgDir = _interopRequireDefault(require("pkg-dir"));

var _semver = _interopRequireDefault(require("semver"));

var _which = _interopRequireDefault(require("which"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The required Node.js version for cli-kit. This is used to assert the Node version at runtime.
 * If the `CLI` instance is created with a `nodeVersion`, then it assert the greater of the two
 * Node versions.
 *
 * @type {String}
 */
const clikitNodeVersion = _fsExtra.default.readJsonSync(_path.default.resolve(__dirname, '..', '..', 'package.json')).engines.node;
/**
 * Asserts that the current Node.js version meets the requirements of cli-kit as well as the app.
 *
 * @param {Object} opts - Various options.
 * @param {String} [opts.appName] - The name of the app.
 * @param {String} [opts.nodeVersion] - The required Node.js version.
 */


function assertNodeJSVersion({
  appName,
  nodeVersion
}) {
  const {
    version: current
  } = process;
  let required;

  if (!_semver.default.satisfies(current, clikitNodeVersion)) {
    required = clikitNodeVersion;
  } else if (nodeVersion && !_semver.default.satisfies(current, nodeVersion)) {
    required = nodeVersion;
  }

  if (required) {
    throw _errors.default.INVALID_NODE_JS(`${appName !== 'program' && appName || 'This program'} requires Node.js version ${required}, currently ${current}`, {
      current,
      required
    });
  }
}
/**
 * Adds the name of the class and any base classes to an internal `clikit` property.
 *
 * @param {Object} obj - The cli-kit object instance to embed the class name.
 * @param {String} name - The class name.
 * @returns {Object}
 */


function declareCLIKitClass(obj, name) {
  return Object.defineProperty(obj, 'clikit', {
    configurable: true,
    value: new Set([name, ...(obj.clikit || [])])
  });
}
/**
 * Decodes a value.
 *
 * @param {String} value - The value to decode.
 * @returns {*}
 */


function decode(value) {
  return value === undefined || value === null ? '' : JSON.parse(Buffer.from(value, 'base64').toString('utf8'));
}

/**
 * Encodes a JavaScript value using base64.
 *
 * @param {*} it - A value to encode.
 * @returns {String}
 */
function encode(it) {
  return it === undefined || it === null ? it : Buffer.from(JSON.stringify(it), 'utf8').toString('base64');
}

/**
 * Strips off the file extension and returns the filename.
 *
 * @param {String} file - The file to extract the filename from.
 * @returns {String}
 */
function filename(file) {
  return _path.default.basename(file).replace(/\.[^.]+$/, '');
}
/**
 * Searches the specified path for the package root, then returns the directory and parsed
 * `package.json`.
 *
 * @param {String} searchPath - The path to search.
 * @returns {Object}
 */


function findPackage(searchPath) {
  let clikit = false;
  let json = {};
  let main = null;
  let root = _pkgDir.default.sync(searchPath) || null; // don't let the tests think they are cli-kit

  if (root === _path.default.resolve(__dirname, '..', '..')) {
    root = null;
  }

  if (/\.js$/.test(searchPath) && isFile(searchPath)) {
    main = searchPath;
  }

  if (root) {
    const file = _path.default.join(root, 'package.json');

    let contents;

    try {
      contents = _fsExtra.default.readFileSync(file, 'utf8');
    } catch (e) {
      // istanbul ignore next
      throw _errors.default.INVALID_PACKAGE_JSON(`Unable to open package.json: ${e.message}`, {
        name: 'package.json',
        scope: 'util.findPackage',
        value: file
      });
    }

    try {
      json = JSON.parse(contents);
    } catch (e) {
      throw _errors.default.INVALID_PACKAGE_JSON(`Failed to parse package.json: ${e.message}`, {
        file,
        name: 'package.json.bad',
        scope: 'util.findPackage',
        value: contents
      });
    }

    if (typeof json !== 'object') {
      throw _errors.default.INVALID_PACKAGE_JSON('Invalid package.json: expected object', {
        file,
        name: 'package.json.invalid',
        scope: 'util.findPackage',
        value: json
      });
    }

    if (json.clikit || json['cli-kit']) {
      clikit = true;
      Object.assign(json, json.clikit, json['cli-kit']);
    }

    if (!main) {
      if (json.main) {
        try {
          main = _path.default.resolve(root, json.main);

          if (_fsExtra.default.statSync(main).isDirectory()) {
            main = _path.default.join(main, 'index.js');
          }
        } catch (e) {
          main = _path.default.resolve(root, `${json.main}.js`);
        }
      } else {
        main = _path.default.resolve(root, 'index.js');
      }

      if (!isFile(main)) {
        main = null;
      }
    }
  } else {
    root = main ? _path.default.dirname(main) : null;
  }

  return {
    clikit,
    json,
    main,
    root
  };
}
/**
 * Attempts to determine if the specified string is an executable.
 *
 * @param {String} bin - An executable name, path, or entire command.
 * @returns {Array.<String>}
 */


function isExecutable(bin) {
  let args;

  try {
    args = split(bin);
    bin = args.shift();
  } catch (err) {// this shouldn't happen, but if it does, just fallback to the original value
  }

  return [_which.default.sync(bin), ...args];
}
/**
 * Determines if a file exists and that it is indeed a file.
 *
 * @param {String} file - The file to check.
 * @returns {Boolean}
 */


function isFile(file) {
  try {
    return _fsExtra.default.statSync(file).isFile();
  } catch (e) {// squelch
  }

  return false;
}

/**
 * Splits an argv (argument vector) string.
 *
 * This function is just a wrapper around argv-split just in case we ever want to replace it.
 * https://www.npmjs.com/package/argv-split.
 *
 * @param {String} it - The argv string to split.
 * @returns {Array.<String>}
 */
function split(it) {
  return (0, _argvSplit.default)(it);
}
/**
 * Inserts line breaks into a string so that the text does not exceed the specified width.
 *
 * @param {String} str - The string to line wrap.
 * @param {Number} [width] - The width to break the lines; defaults to the terminal width.
 * @param {Number} [indent] - The number of spaces to indent new lines.
 * @returns {String}
 */


function wrap(str, width, indent) {
  if (width <= 0) {
    return str;
  }

  indent = ' '.repeat(indent || 0);
  return str.split(/\r?\n/).map(line => {
    let i = 0;
    let j = 0;
    let k; // remove escape characters

    line = line.replace(/\u001b\[J/g, ''); // eslint-disable-line no-control-regex

    while (i < line.length) {
      i++;

      if (++j >= width) {
        // backpedal
        for (k = i; k >= 0; k--) {
          if (/[ ,;!?]/.test(line.charAt(k)) || /[.:]/.test(line.charAt(k)) && (k + 1 >= line.length || /[ \t\r\n]/.test(line.charAt(k + 1)))) {
            if (k + 1 < line.length) {
              line = `${line.substring(0, k)}\n${indent}${line.substring(k + 1)}`;
              i = k + 1;
              j = 0;
            }

            break;
          }
        }
      }
    }

    return line;
  }).join('\n');
}
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi91dGlsLmpzIl0sIm5hbWVzIjpbImNsaWtpdE5vZGVWZXJzaW9uIiwiZnMiLCJyZWFkSnNvblN5bmMiLCJwYXRoIiwicmVzb2x2ZSIsIl9fZGlybmFtZSIsImVuZ2luZXMiLCJub2RlIiwiYXNzZXJ0Tm9kZUpTVmVyc2lvbiIsImFwcE5hbWUiLCJub2RlVmVyc2lvbiIsInZlcnNpb24iLCJjdXJyZW50IiwicHJvY2VzcyIsInJlcXVpcmVkIiwic2VtdmVyIiwic2F0aXNmaWVzIiwiRSIsIklOVkFMSURfTk9ERV9KUyIsImRlY2xhcmVDTElLaXRDbGFzcyIsIm9iaiIsIm5hbWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsInZhbHVlIiwiU2V0IiwiY2xpa2l0IiwiZGVjb2RlIiwidW5kZWZpbmVkIiwiSlNPTiIsInBhcnNlIiwiQnVmZmVyIiwiZnJvbSIsInRvU3RyaW5nIiwiZW5jb2RlIiwiaXQiLCJzdHJpbmdpZnkiLCJmaWxlbmFtZSIsImZpbGUiLCJiYXNlbmFtZSIsInJlcGxhY2UiLCJmaW5kUGFja2FnZSIsInNlYXJjaFBhdGgiLCJqc29uIiwibWFpbiIsInJvb3QiLCJwa2dEaXIiLCJzeW5jIiwidGVzdCIsImlzRmlsZSIsImpvaW4iLCJjb250ZW50cyIsInJlYWRGaWxlU3luYyIsImUiLCJJTlZBTElEX1BBQ0tBR0VfSlNPTiIsIm1lc3NhZ2UiLCJzY29wZSIsImFzc2lnbiIsInN0YXRTeW5jIiwiaXNEaXJlY3RvcnkiLCJkaXJuYW1lIiwiaXNFeGVjdXRhYmxlIiwiYmluIiwiYXJncyIsInNwbGl0Iiwic2hpZnQiLCJlcnIiLCJ3aGljaCIsIndyYXAiLCJzdHIiLCJ3aWR0aCIsImluZGVudCIsInJlcGVhdCIsIm1hcCIsImxpbmUiLCJpIiwiaiIsImsiLCJsZW5ndGgiLCJjaGFyQXQiLCJzdWJzdHJpbmciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFD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SyxNQUFMLENBQVlGLENBQUMsR0FBRyxDQUFoQixDQUFqQixDQUF4RCxDQUF2QyxFQUF1STtBQUN0SSxnQkFBSUEsQ0FBQyxHQUFHLENBQUosR0FBUUgsSUFBSSxDQUFDSSxNQUFqQixFQUF5QjtBQUN4QkosY0FBQUEsSUFBSSxHQUFJLEdBQUVBLElBQUksQ0FBQ00sU0FBTCxDQUFlLENBQWYsRUFBa0JILENBQWxCLENBQXFCLEtBQUlOLE1BQU8sR0FBRUcsSUFBSSxDQUFDTSxTQUFMLENBQWVILENBQUMsR0FBRyxDQUFuQixDQUFzQixFQUFsRTtBQUNBRixjQUFBQSxDQUFDLEdBQUdFLENBQUMsR0FBRyxDQUFSO0FBQ0FELGNBQUFBLENBQUMsR0FBRyxDQUFKO0FBQ0E7O0FBQ0Q7QUFDQTtBQUNEO0FBQ0Q7QUFDRDs7QUFFRCxXQUFPRixJQUFQO0FBQ0EsR0E1QkssRUE2Qkx4QixJQTdCSyxDQTZCQSxJQTdCQSxDQUFQO0FBOEJBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFyZ3ZTcGxpdCBmcm9tICdhcmd2LXNwbGl0JztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgRSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBwa2dEaXIgZnJvbSAncGtnLWRpcic7XG5pbXBvcnQgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5pbXBvcnQgd2hpY2ggZnJvbSAnd2hpY2gnO1xuXG4vKipcbiAqIFRoZSByZXF1aXJlZCBOb2RlLmpzIHZlcnNpb24gZm9yIGNsaS1raXQuIFRoaXMgaXMgdXNlZCB0byBhc3NlcnQgdGhlIE5vZGUgdmVyc2lvbiBhdCBydW50aW1lLlxuICogSWYgdGhlIGBDTElgIGluc3RhbmNlIGlzIGNyZWF0ZWQgd2l0aCBhIGBub2RlVmVyc2lvbmAsIHRoZW4gaXQgYXNzZXJ0IHRoZSBncmVhdGVyIG9mIHRoZSB0d29cbiAqIE5vZGUgdmVyc2lvbnMuXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuY29uc3QgY2xpa2l0Tm9kZVZlcnNpb24gPSBmcy5yZWFkSnNvblN5bmMocGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uJywgJy4uJywgJ3BhY2thZ2UuanNvbicpKS5lbmdpbmVzLm5vZGU7XG5cbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBjdXJyZW50IE5vZGUuanMgdmVyc2lvbiBtZWV0cyB0aGUgcmVxdWlyZW1lbnRzIG9mIGNsaS1raXQgYXMgd2VsbCBhcyB0aGUgYXBwLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVmFyaW91cyBvcHRpb25zLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLmFwcE5hbWVdIC0gVGhlIG5hbWUgb2YgdGhlIGFwcC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5ub2RlVmVyc2lvbl0gLSBUaGUgcmVxdWlyZWQgTm9kZS5qcyB2ZXJzaW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Tm9kZUpTVmVyc2lvbih7IGFwcE5hbWUsIG5vZGVWZXJzaW9uIH0pIHtcblx0Y29uc3QgeyB2ZXJzaW9uOiBjdXJyZW50IH0gPSBwcm9jZXNzO1xuXHRsZXQgcmVxdWlyZWQ7XG5cblx0aWYgKCFzZW12ZXIuc2F0aXNmaWVzKGN1cnJlbnQsIGNsaWtpdE5vZGVWZXJzaW9uKSkge1xuXHRcdHJlcXVpcmVkID0gY2xpa2l0Tm9kZVZlcnNpb247XG5cdH0gZWxzZSBpZiAobm9kZVZlcnNpb24gJiYgIXNlbXZlci5zYXRpc2ZpZXMoY3VycmVudCwgbm9kZVZlcnNpb24pKSB7XG5cdFx0cmVxdWlyZWQgPSBub2RlVmVyc2lvbjtcblx0fVxuXG5cdGlmIChyZXF1aXJlZCkge1xuXHRcdHRocm93IEUuSU5WQUxJRF9OT0RFX0pTKGAke2FwcE5hbWUgIT09ICdwcm9ncmFtJyAmJiBhcHBOYW1lIHx8ICdUaGlzIHByb2dyYW0nfSByZXF1aXJlcyBOb2RlLmpzIHZlcnNpb24gJHtyZXF1aXJlZH0sIGN1cnJlbnRseSAke2N1cnJlbnR9YCwge1xuXHRcdFx0Y3VycmVudCxcblx0XHRcdHJlcXVpcmVkXG5cdFx0fSk7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBuYW1lIG9mIHRoZSBjbGFzcyBhbmQgYW55IGJhc2UgY2xhc3NlcyB0byBhbiBpbnRlcm5hbCBgY2xpa2l0YCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIGNsaS1raXQgb2JqZWN0IGluc3RhbmNlIHRvIGVtYmVkIHRoZSBjbGFzcyBuYW1lLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgY2xhc3MgbmFtZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNsYXJlQ0xJS2l0Q2xhc3Mob2JqLCBuYW1lKSB7XG5cdHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCAnY2xpa2l0Jywge1xuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHR2YWx1ZTogbmV3IFNldChbIG5hbWUsIC4uLihvYmouY2xpa2l0IHx8IFtdKSBdKVxuXHR9KTtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsID8gJycgOiBKU09OLnBhcnNlKEJ1ZmZlci5mcm9tKHZhbHVlLCAnYmFzZTY0JykudG9TdHJpbmcoJ3V0ZjgnKSk7XG59XG5cbmV4cG9ydCB7IGRlY29kZSBhcyBkZWNvZGVIZWFkZXIgfTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgSmF2YVNjcmlwdCB2YWx1ZSB1c2luZyBiYXNlNjQuXG4gKlxuICogQHBhcmFtIHsqfSBpdCAtIEEgdmFsdWUgdG8gZW5jb2RlLlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShpdCkge1xuXHRyZXR1cm4gaXQgPT09IHVuZGVmaW5lZCB8fCBpdCA9PT0gbnVsbCA/IGl0IDogQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoaXQpLCAndXRmOCcpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbn1cblxuZXhwb3J0IHsgZW5jb2RlIGFzIGVuY29kZUhlYWRlciB9O1xuXG4vKipcbiAqIFN0cmlwcyBvZmYgdGhlIGZpbGUgZXh0ZW5zaW9uIGFuZCByZXR1cm5zIHRoZSBmaWxlbmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZSAtIFRoZSBmaWxlIHRvIGV4dHJhY3QgdGhlIGZpbGVuYW1lIGZyb20uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlsZW5hbWUoZmlsZSkge1xuXHRyZXR1cm4gcGF0aC5iYXNlbmFtZShmaWxlKS5yZXBsYWNlKC9cXC5bXi5dKyQvLCAnJyk7XG59XG5cbi8qKlxuICogU2VhcmNoZXMgdGhlIHNwZWNpZmllZCBwYXRoIGZvciB0aGUgcGFja2FnZSByb290LCB0aGVuIHJldHVybnMgdGhlIGRpcmVjdG9yeSBhbmQgcGFyc2VkXG4gKiBgcGFja2FnZS5qc29uYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoUGF0aCAtIFRoZSBwYXRoIHRvIHNlYXJjaC5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUGFja2FnZShzZWFyY2hQYXRoKSB7XG5cdGxldCBjbGlraXQgPSBmYWxzZTtcblx0bGV0IGpzb24gPSB7fTtcblx0bGV0IG1haW4gPSBudWxsO1xuXHRsZXQgcm9vdCA9IHBrZ0Rpci5zeW5jKHNlYXJjaFBhdGgpIHx8IG51bGw7XG5cblx0Ly8gZG9uJ3QgbGV0IHRoZSB0ZXN0cyB0aGluayB0aGV5IGFyZSBjbGkta2l0XG5cdGlmIChyb290ID09PSBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4nLCAnLi4nKSkge1xuXHRcdHJvb3QgPSBudWxsO1xuXHR9XG5cblx0aWYgKC9cXC5qcyQvLnRlc3Qoc2VhcmNoUGF0aCkgJiYgaXNGaWxlKHNlYXJjaFBhdGgpKSB7XG5cdFx0bWFpbiA9IHNlYXJjaFBhdGg7XG5cdH1cblxuXHRpZiAocm9vdCkge1xuXHRcdGNvbnN0IGZpbGUgPSBwYXRoLmpvaW4ocm9vdCwgJ3BhY2thZ2UuanNvbicpO1xuXHRcdGxldCBjb250ZW50cztcblxuXHRcdHRyeSB7XG5cdFx0XHRjb250ZW50cyA9IGZzLnJlYWRGaWxlU3luYyhmaWxlLCAndXRmOCcpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5cdFx0XHR0aHJvdyBFLklOVkFMSURfUEFDS0FHRV9KU09OKGBVbmFibGUgdG8gb3BlbiBwYWNrYWdlLmpzb246ICR7ZS5tZXNzYWdlfWAsIHsgbmFtZTogJ3BhY2thZ2UuanNvbicsIHNjb3BlOiAndXRpbC5maW5kUGFja2FnZScsIHZhbHVlOiBmaWxlIH0pO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRqc29uID0gSlNPTi5wYXJzZShjb250ZW50cyk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0dGhyb3cgRS5JTlZBTElEX1BBQ0tBR0VfSlNPTihgRmFpbGVkIHRvIHBhcnNlIHBhY2thZ2UuanNvbjogJHtlLm1lc3NhZ2V9YCwgeyBmaWxlLCBuYW1lOiAncGFja2FnZS5qc29uLmJhZCcsIHNjb3BlOiAndXRpbC5maW5kUGFja2FnZScsIHZhbHVlOiBjb250ZW50cyB9KTtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIGpzb24gIT09ICdvYmplY3QnKSB7XG5cdFx0XHR0aHJvdyBFLklOVkFMSURfUEFDS0FHRV9KU09OKCdJbnZhbGlkIHBhY2thZ2UuanNvbjogZXhwZWN0ZWQgb2JqZWN0JywgeyBmaWxlLCBuYW1lOiAncGFja2FnZS5qc29uLmludmFsaWQnLCBzY29wZTogJ3V0aWwuZmluZFBhY2thZ2UnLCB2YWx1ZToganNvbiB9KTtcblx0XHR9XG5cblx0XHRpZiAoanNvbi5jbGlraXQgfHwganNvblsnY2xpLWtpdCddKSB7XG5cdFx0XHRjbGlraXQgPSB0cnVlO1xuXHRcdFx0T2JqZWN0LmFzc2lnbihqc29uLCBqc29uLmNsaWtpdCwganNvblsnY2xpLWtpdCddKTtcblx0XHR9XG5cblx0XHRpZiAoIW1haW4pIHtcblx0XHRcdGlmIChqc29uLm1haW4pIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRtYWluID0gcGF0aC5yZXNvbHZlKHJvb3QsIGpzb24ubWFpbik7XG5cdFx0XHRcdFx0aWYgKGZzLnN0YXRTeW5jKG1haW4pLmlzRGlyZWN0b3J5KCkpIHtcblx0XHRcdFx0XHRcdG1haW4gPSBwYXRoLmpvaW4obWFpbiwgJ2luZGV4LmpzJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0bWFpbiA9IHBhdGgucmVzb2x2ZShyb290LCBgJHtqc29uLm1haW59LmpzYCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1haW4gPSBwYXRoLnJlc29sdmUocm9vdCwgJ2luZGV4LmpzJyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaXNGaWxlKG1haW4pKSB7XG5cdFx0XHRcdG1haW4gPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyb290ID0gbWFpbiA/IHBhdGguZGlybmFtZShtYWluKSA6IG51bGw7XG5cdH1cblxuXHRyZXR1cm4geyBjbGlraXQsIGpzb24sIG1haW4sIHJvb3QgfTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBkZXRlcm1pbmUgaWYgdGhlIHNwZWNpZmllZCBzdHJpbmcgaXMgYW4gZXhlY3V0YWJsZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmluIC0gQW4gZXhlY3V0YWJsZSBuYW1lLCBwYXRoLCBvciBlbnRpcmUgY29tbWFuZC5cbiAqIEByZXR1cm5zIHtBcnJheS48U3RyaW5nPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXhlY3V0YWJsZShiaW4pIHtcblx0bGV0IGFyZ3M7XG5cblx0dHJ5IHtcblx0XHRhcmdzID0gc3BsaXQoYmluKTtcblx0XHRiaW4gPSBhcmdzLnNoaWZ0KCk7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIHRoaXMgc2hvdWxkbid0IGhhcHBlbiwgYnV0IGlmIGl0IGRvZXMsIGp1c3QgZmFsbGJhY2sgdG8gdGhlIG9yaWdpbmFsIHZhbHVlXG5cdH1cblxuXHRyZXR1cm4gW1xuXHRcdHdoaWNoLnN5bmMoYmluKSxcblx0XHQuLi5hcmdzXG5cdF07XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGZpbGUgZXhpc3RzIGFuZCB0aGF0IGl0IGlzIGluZGVlZCBhIGZpbGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGUgLSBUaGUgZmlsZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlKGZpbGUpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZnMuc3RhdFN5bmMoZmlsZSkuaXNGaWxlKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBzcXVlbGNoXG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgeyBwa2dEaXIgfTtcblxuLyoqXG4gKiBTcGxpdHMgYW4gYXJndiAoYXJndW1lbnQgdmVjdG9yKSBzdHJpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBqdXN0IGEgd3JhcHBlciBhcm91bmQgYXJndi1zcGxpdCBqdXN0IGluIGNhc2Ugd2UgZXZlciB3YW50IHRvIHJlcGxhY2UgaXQuXG4gKiBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9hcmd2LXNwbGl0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpdCAtIFRoZSBhcmd2IHN0cmluZyB0byBzcGxpdC5cbiAqIEByZXR1cm5zIHtBcnJheS48U3RyaW5nPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0KGl0KSB7XG5cdHJldHVybiBhcmd2U3BsaXQoaXQpO1xufVxuXG4vKipcbiAqIEluc2VydHMgbGluZSBicmVha3MgaW50byBhIHN0cmluZyBzbyB0aGF0IHRoZSB0ZXh0IGRvZXMgbm90IGV4Y2VlZCB0aGUgc3BlY2lmaWVkIHdpZHRoLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGxpbmUgd3JhcC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGhdIC0gVGhlIHdpZHRoIHRvIGJyZWFrIHRoZSBsaW5lczsgZGVmYXVsdHMgdG8gdGhlIHRlcm1pbmFsIHdpZHRoLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRlbnRdIC0gVGhlIG51bWJlciBvZiBzcGFjZXMgdG8gaW5kZW50IG5ldyBsaW5lcy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwKHN0ciwgd2lkdGgsIGluZGVudCkge1xuXHRpZiAod2lkdGggPD0gMCkge1xuXHRcdHJldHVybiBzdHI7XG5cdH1cblxuXHRpbmRlbnQgPSAnICcucmVwZWF0KGluZGVudCB8fCAwKTtcblxuXHRyZXR1cm4gc3RyXG5cdFx0LnNwbGl0KC9cXHI/XFxuLylcblx0XHQubWFwKGxpbmUgPT4ge1xuXHRcdFx0bGV0IGkgPSAwO1xuXHRcdFx0bGV0IGogPSAwO1xuXHRcdFx0bGV0IGs7XG5cblx0XHRcdC8vIHJlbW92ZSBlc2NhcGUgY2hhcmFjdGVyc1xuXHRcdFx0bGluZSA9IGxpbmUucmVwbGFjZSgvXFx1MDAxYlxcW0ovZywgJycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuXHRcdFx0d2hpbGUgKGkgPCBsaW5lLmxlbmd0aCkge1xuXHRcdFx0XHRpKys7XG5cdFx0XHRcdGlmICgrK2ogPj0gd2lkdGgpIHtcblx0XHRcdFx0XHQvLyBiYWNrcGVkYWxcblx0XHRcdFx0XHRmb3IgKGsgPSBpOyBrID49IDA7IGstLSkge1xuXHRcdFx0XHRcdFx0aWYgKC9bICw7IT9dLy50ZXN0KGxpbmUuY2hhckF0KGspKSB8fCAoL1suOl0vLnRlc3QobGluZS5jaGFyQXQoaykpICYmIChrICsgMSA+PSBsaW5lLmxlbmd0aCB8fCAvWyBcXHRcXHJcXG5dLy50ZXN0KGxpbmUuY2hhckF0KGsgKyAxKSkpKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoayArIDEgPCBsaW5lLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdGxpbmUgPSBgJHtsaW5lLnN1YnN0cmluZygwLCBrKX1cXG4ke2luZGVudH0ke2xpbmUuc3Vic3RyaW5nKGsgKyAxKX1gO1xuXHRcdFx0XHRcdFx0XHRcdGkgPSBrICsgMTtcblx0XHRcdFx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGxpbmU7XG5cdFx0fSlcblx0XHQuam9pbignXFxuJyk7XG59XG4iXSwiZmlsZSI6ImxpYi91dGlsLmpzIn0=
