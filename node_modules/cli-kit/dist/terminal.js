"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _debug = _interopRequireDefault(require("./lib/debug"));

var _errors = _interopRequireDefault(require("./lib/errors"));

var _readline = _interopRequireDefault(require("readline"));

var ansi = _interopRequireWildcard(require("./lib/ansi"));

var _console = require("console");

var _util = require("./lib/util");

var _events = require("events");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const {
  log
} = (0, _debug.default)('cli-kit:terminal');
const {
  highlight
} = _debug.default.styles;
/**
 * Cheap check to see if output may be XML or JSON object output.
 * @type {RegExp}
 */

const dataRegExp = /^\s*[<{[]/;
/**
 * The list of encodings to check the chunk contents for data and emit the 'start' event.
 * @type {RegExp}
 */

const encodings = new Set(['ascii', 'latin1', 'ucs2', 'utf8', 'utf16le']);
/**
 * Since `stdout` is global, each Terminal instance will listen to it and this causes a warning, so
 * by setting the max listeners, we can suppress the message.
 */

process.stdout.setMaxListeners(Infinity);
/**
 * A high-level interface around all terminal oprations.
 *
 * @emits Terminal#keypress
 * @emits Terminal#resize
 */

class Terminal extends _events.EventEmitter {
  /**
   * Tracks all pending callbacks to be notified when output first occurs.
   * @type {Array.<Function>}
   */

  /**
   * A semiphore counter to track the number of keypress listeners and automatically
   * enable/disable raw mode on the stdin stream.
   * @type {Number}
   */

  /**
   * Initializes the terminal, streams, and a console instance.
   *
   * @param {Object} [opts] - Various options.
   * @param {Number} [opts.defaultColumns=80] - The default number of columns wide the terminal
   * should be when `stdout` is not a TTY.
   * @param {Number} [opts.defaultRows=24] - The default number of rows high the terminal should
   * be when `stdout` is not a TTY.
   * @param {stream.Writable} [opts.stderr=process.stderr] - A writable output stream.
   * @param {stream.Readable} [opts.stdin=process.stdin] - A stream for which to read input.
   * @param {stream.Writable} [opts.stdout=process.stdout] - A writable output stream.
   * @param {Number} [opts.promptTimeout] - The number of milliseconds of inactivity before
   * timing out.
   * @access public
   */
  constructor(opts = {}) {
    super();

    _defineProperty(this, "outputCallbacks", []);

    _defineProperty(this, "rawMode", 0);

    (0, _util.declareCLIKitClass)(this, 'Terminal');

    if (opts.defaultColumns !== undefined && (typeof opts.defaultColumns !== 'number' || isNaN(opts.defaultColumns) || opts.defaultColumns < 1)) {
      throw _errors.default.INVALID_ARGUMENT('Expected default columns to be a positive integer');
    }

    this.defaultColumns = opts.defaultColumns || 80;

    if (opts.defaultRows !== undefined && (typeof opts.defaultRows !== 'number' || isNaN(opts.defaultRows) || opts.defaultRows < 1)) {
      throw _errors.default.INVALID_ARGUMENT('Expected default rows to be a positive integer');
    }

    this.defaultRows = opts.defaultRows || 24;
    this.stdin = opts.stdin || process.stdin;

    if (!this.stdin || typeof this.stdin !== 'object' || typeof this.stdin.read !== 'function') {
      throw _errors.default.INVALID_ARGUMENT('Expected the stdin stream to be a readable stream', {
        name: 'stdin',
        scope: 'Terminal.constructor',
        value: opts.stdin
      });
    }

    _readline.default.emitKeypressEvents(this.stdin);

    this.stdout = this.patchStreamWrite('stdout', opts.stdout || process.stdout);
    this.stderr = this.patchStreamWrite('stderr', opts.stderr || process.stderr);
    this.default = opts.default === 'stdout' ? this.stdout : this.stderr;
    this.console = new _console.Console(this.stdout, this.stderr);

    if (opts.promptTimeout !== undefined) {
      if (typeof opts.promptTimeout !== 'number' || isNaN(opts.promptTimeout) || opts.promptTimeout < 0) {
        throw _errors.default.INVALID_ARGUMENT('Expected prompt timeout to be a positive integer', {
          name: 'promptTimeout',
          scope: 'Terminal.constructor',
          value: opts.promptTimeout
        });
      }
    }

    this.promptTimeout = opts.promptTimeout | 0;

    if (this.stdout.isTTY) {
      this.stdout.on('resize', () => {
        this.emit('resize', {
          columns: this.stdout.columns,
          rows: this.stdout.rows
        });
      });
    }
  }

  beep() {
    this.stderr.write(ansi.beep);
  }

  showCursor() {
    this.stderr.write(ansi.cursor.show);
  }

  hideCursor() {
    this.stderr.write(ansi.cursor.hide);
  }

  get columns() {
    return this.stdout.columns || this.defaultColumns;
  }

  get rows() {
    return this.stdout.rows || this.defaultRows;
  }

  onAddKeypress() {
    if (!this.rl) {
      this.rl = _readline.default.createInterface(this.stdin);
    }

    if (this.stdin.isTTY && ++this.rawMode === 1) {
      this.sigintHandler = (chunk, key) => {
        if (key && key.name === 'c' && key.ctrl) {
          this.emit('SIGINT');
        }
      };

      this.stdin.setRawMode(true);
      this.stdin.on('keypress', this.sigintHandler);
    }
  }

  onRemoveKeypress() {
    if (this.stdin.isTTY && --this.rawMode === 0) {
      this.stdin.setRawMode(false);
      this.stdin.removeListener('keypress', this.sigintHandler);
      this.sigintHandler === 'false';
    }

    if (this.rl) {
      this.rl.close();
      this.rl = null;
    }
  }
  /**
   * A wrapper around `EventEmitter.on()`. If the `event` is `keypress`, then the event is routed
   * to the stdin instance.
   *
   * @param {String|Symbol} event - The event name.
   * @param {Function} listener - The event handler function.
   * @returns {Terminal}
   * @access public
   */


  on(event, listener) {
    if (event === 'keypress') {
      this.stdin.on(event, listener);
      this.onAddKeypress();
    } else {
      super.on(event, listener);
    }

    return this;
  }
  /**
   * A wrapper around `EventEmitter.once()`. If the `event` is `keypress`, then the event is routed
   * to the stdin instance.
   *
   * @param {String|Symbol} event - The event name.
   * @param {Function} listener - The event handler function.
   * @returns {Terminal}
   * @access public
   */


  once(event, listener) {
    if (event === 'keypress') {
      this.stdin.once(event, (...args) => {
        this.onRemoveKeypress();
        listener(...args);
      });
      this.onAddKeypress();
    } else {
      super.once(event, listener);
    }

    return this;
  }
  /**
   * A wrapper around `EventEmitter.removeListener()`. If the `event` is `keypress`, then the event is routed
   * to the stdin instance.
   *
   * @param {String|Symbol} event - The event name.
   * @param {Function} listener - The event handler function.
   * @returns {Terminal}
   * @access public
   */


  removeListener(event, listener) {
    if (event === 'keypress') {
      this.stdin.removeListener(event, listener);
      this.onRemoveKeypress();
    } else {
      super.removeListener(event, listener);
    }

    return this;
  }
  /**
   * Adds a callback to be notified when output first occurs unless output has already occurred
   * in which case the callback is immediately invoked. This is basically a synchronous promise.
   *
   * @param {Function} cb - The callback to notify when output first occurs.
   * @returns {Terminal}
   * @access public
   */


  onOutput(cb) {
    if (this.outputCallbacks) {
      this.outputCallbacks.push(cb);
    } else {
      cb(this.outputResolution);
    }

    return this;
  }
  /**
   * Patches a stream's `write()` method to detect output contents and emit an `output` event for
   * text-based output.
   *
   * @param {String} name - The stream name.
   * @param {stream.Writable} stream - A writable output stream.
   * @returns {stream.Writable}
   * @access private
   */


  patchStreamWrite(name, stream) {
    if (!stream || typeof stream !== 'object' || typeof stream.write !== 'function') {
      throw _errors.default.INVALID_ARGUMENT(`Expected the ${name} stream to be a writable stream`, {
        name,
        scope: 'Terminal.patchStreamWrite',
        value: stream
      });
    }

    log(`Patching output stream: ${highlight(name)}`);
    const origWrite = stream.write;
    const self = this;

    const write = function write(chunk, encoding, cb) {
      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }

      if (self.outputFired === undefined && (!encoding || encodings.has(encoding)) && !(self.outputFired = dataRegExp.test(chunk))) {
        self.outputResolution = {
          chunk,
          encoding
        };

        if (self.outputCallbacks) {
          for (const cb of self.outputCallbacks) {
            cb(self.outputResolution);
          }

          self.outputCallbacks = null;
        }
      }

      return origWrite.call(stream, chunk, encoding, cb);
    };

    stream.write = write.bind(stream);
    return stream;
  }

}

exports.default = Terminal;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRlcm1pbmFsLmpzIl0sIm5hbWVzIjpbImxvZyIsImhpZ2hsaWdodCIsImRlYnVnIiwic3R5bGVzIiwiZGF0YVJlZ0V4cCIsImVuY29kaW5ncyIsIlNldCIsInByb2Nlc3MiLCJzdGRvdXQiLCJzZXRNYXhMaXN0ZW5lcnMiLCJJbmZpbml0eSIsIlRlcm1pbmFsIiwiRXZlbnRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJvcHRzIiwiZGVmYXVsdENvbHVtbnMiLCJ1bmRlZmluZWQiLCJpc05hTiIsIkUiLCJJTlZBTElEX0FSR1VNRU5UIiwiZGVmYXVsdFJvd3MiLCJzdGRpbiIsInJlYWQiLCJuYW1lIiwic2NvcGUiLCJ2YWx1ZSIsInJlYWRsaW5lIiwiZW1pdEtleXByZXNzRXZlbnRzIiwicGF0Y2hTdHJlYW1Xcml0ZSIsInN0ZGVyciIsImRlZmF1bHQiLCJjb25zb2xlIiwiQ29uc29sZSIsInByb21wdFRpbWVvdXQiLCJpc1RUWSIsIm9uIiwiZW1pdCIsImNvbHVtbnMiLCJyb3dzIiwiYmVlcCIsIndyaXRlIiwiYW5zaSIsInNob3dDdXJzb3IiLCJjdXJzb3IiLCJzaG93IiwiaGlkZUN1cnNvciIsImhpZGUiLCJvbkFkZEtleXByZXNzIiwicmwiLCJjcmVhdGVJbnRlcmZhY2UiLCJyYXdNb2RlIiwic2lnaW50SGFuZGxlciIsImNodW5rIiwia2V5IiwiY3RybCIsInNldFJhd01vZGUiLCJvblJlbW92ZUtleXByZXNzIiwicmVtb3ZlTGlzdGVuZXIiLCJjbG9zZSIsImV2ZW50IiwibGlzdGVuZXIiLCJvbmNlIiwiYXJncyIsIm9uT3V0cHV0IiwiY2IiLCJvdXRwdXRDYWxsYmFja3MiLCJwdXNoIiwib3V0cHV0UmVzb2x1dGlvbiIsInN0cmVhbSIsIm9yaWdXcml0ZSIsInNlbGYiLCJlbmNvZGluZyIsIm91dHB1dEZpcmVkIiwiaGFzIiwidGVzdCIsImNhbGwiLCJiaW5kIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBRUE7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dCBFIGZyb20gJy4vbGliL2Vycm9ycyc7XG5pbXBvcnQgcmVhZGxpbmUgZnJvbSAncmVhZGxpbmUnO1xuXG5pbXBvcnQgKiBhcyBhbnNpIGZyb20gJy4vbGliL2Fuc2knO1xuXG5pbXBvcnQgeyBDb25zb2xlIH0gZnJvbSAnY29uc29sZSc7XG5pbXBvcnQgeyBkZWNsYXJlQ0xJS2l0Q2xhc3MgfSBmcm9tICcuL2xpYi91dGlsJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5cbmNvbnN0IHsgbG9nIH0gPSBkZWJ1ZygnY2xpLWtpdDp0ZXJtaW5hbCcpO1xuY29uc3QgeyBoaWdobGlnaHQgfSAgPSBkZWJ1Zy5zdHlsZXM7XG5cbi8qKlxuICogQ2hlYXAgY2hlY2sgdG8gc2VlIGlmIG91dHB1dCBtYXkgYmUgWE1MIG9yIEpTT04gb2JqZWN0IG91dHB1dC5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbmNvbnN0IGRhdGFSZWdFeHAgPSAvXlxccypbPHtbXS87XG5cbi8qKlxuICogVGhlIGxpc3Qgb2YgZW5jb2RpbmdzIHRvIGNoZWNrIHRoZSBjaHVuayBjb250ZW50cyBmb3IgZGF0YSBhbmQgZW1pdCB0aGUgJ3N0YXJ0JyBldmVudC5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbmNvbnN0IGVuY29kaW5ncyA9IG5ldyBTZXQoWyAnYXNjaWknLCAnbGF0aW4xJywgJ3VjczInLCAndXRmOCcsICd1dGYxNmxlJyBdKTtcblxuLyoqXG4gKiBTaW5jZSBgc3Rkb3V0YCBpcyBnbG9iYWwsIGVhY2ggVGVybWluYWwgaW5zdGFuY2Ugd2lsbCBsaXN0ZW4gdG8gaXQgYW5kIHRoaXMgY2F1c2VzIGEgd2FybmluZywgc29cbiAqIGJ5IHNldHRpbmcgdGhlIG1heCBsaXN0ZW5lcnMsIHdlIGNhbiBzdXBwcmVzcyB0aGUgbWVzc2FnZS5cbiAqL1xucHJvY2Vzcy5zdGRvdXQuc2V0TWF4TGlzdGVuZXJzKEluZmluaXR5KTtcblxuLyoqXG4gKiBBIGhpZ2gtbGV2ZWwgaW50ZXJmYWNlIGFyb3VuZCBhbGwgdGVybWluYWwgb3ByYXRpb25zLlxuICpcbiAqIEBlbWl0cyBUZXJtaW5hbCNrZXlwcmVzc1xuICogQGVtaXRzIFRlcm1pbmFsI3Jlc2l6ZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXJtaW5hbCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cdC8qKlxuXHQgKiBUcmFja3MgYWxsIHBlbmRpbmcgY2FsbGJhY2tzIHRvIGJlIG5vdGlmaWVkIHdoZW4gb3V0cHV0IGZpcnN0IG9jY3Vycy5cblx0ICogQHR5cGUge0FycmF5LjxGdW5jdGlvbj59XG5cdCAqL1xuXHRvdXRwdXRDYWxsYmFja3MgPSBbXTtcblxuXHQvKipcblx0ICogQSBzZW1pcGhvcmUgY291bnRlciB0byB0cmFjayB0aGUgbnVtYmVyIG9mIGtleXByZXNzIGxpc3RlbmVycyBhbmQgYXV0b21hdGljYWxseVxuXHQgKiBlbmFibGUvZGlzYWJsZSByYXcgbW9kZSBvbiB0aGUgc3RkaW4gc3RyZWFtLlxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKi9cblx0cmF3TW9kZSA9IDA7XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIHRoZSB0ZXJtaW5hbCwgc3RyZWFtcywgYW5kIGEgY29uc29sZSBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIFZhcmlvdXMgb3B0aW9ucy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLmRlZmF1bHRDb2x1bW5zPTgwXSAtIFRoZSBkZWZhdWx0IG51bWJlciBvZiBjb2x1bW5zIHdpZGUgdGhlIHRlcm1pbmFsXG5cdCAqIHNob3VsZCBiZSB3aGVuIGBzdGRvdXRgIGlzIG5vdCBhIFRUWS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLmRlZmF1bHRSb3dzPTI0XSAtIFRoZSBkZWZhdWx0IG51bWJlciBvZiByb3dzIGhpZ2ggdGhlIHRlcm1pbmFsIHNob3VsZFxuXHQgKiBiZSB3aGVuIGBzdGRvdXRgIGlzIG5vdCBhIFRUWS5cblx0ICogQHBhcmFtIHtzdHJlYW0uV3JpdGFibGV9IFtvcHRzLnN0ZGVycj1wcm9jZXNzLnN0ZGVycl0gLSBBIHdyaXRhYmxlIG91dHB1dCBzdHJlYW0uXG5cdCAqIEBwYXJhbSB7c3RyZWFtLlJlYWRhYmxlfSBbb3B0cy5zdGRpbj1wcm9jZXNzLnN0ZGluXSAtIEEgc3RyZWFtIGZvciB3aGljaCB0byByZWFkIGlucHV0LlxuXHQgKiBAcGFyYW0ge3N0cmVhbS5Xcml0YWJsZX0gW29wdHMuc3Rkb3V0PXByb2Nlc3Muc3Rkb3V0XSAtIEEgd3JpdGFibGUgb3V0cHV0IHN0cmVhbS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLnByb21wdFRpbWVvdXRdIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb2YgaW5hY3Rpdml0eSBiZWZvcmVcblx0ICogdGltaW5nIG91dC5cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICovXG5cdGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0ZGVjbGFyZUNMSUtpdENsYXNzKHRoaXMsICdUZXJtaW5hbCcpO1xuXG5cdFx0aWYgKG9wdHMuZGVmYXVsdENvbHVtbnMgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIG9wdHMuZGVmYXVsdENvbHVtbnMgIT09ICdudW1iZXInIHx8IGlzTmFOKG9wdHMuZGVmYXVsdENvbHVtbnMpIHx8IG9wdHMuZGVmYXVsdENvbHVtbnMgPCAxKSkge1xuXHRcdFx0dGhyb3cgRS5JTlZBTElEX0FSR1VNRU5UKCdFeHBlY3RlZCBkZWZhdWx0IGNvbHVtbnMgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cdFx0fVxuXHRcdHRoaXMuZGVmYXVsdENvbHVtbnMgPSBvcHRzLmRlZmF1bHRDb2x1bW5zIHx8IDgwO1xuXG5cdFx0aWYgKG9wdHMuZGVmYXVsdFJvd3MgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIG9wdHMuZGVmYXVsdFJvd3MgIT09ICdudW1iZXInIHx8IGlzTmFOKG9wdHMuZGVmYXVsdFJvd3MpIHx8IG9wdHMuZGVmYXVsdFJvd3MgPCAxKSkge1xuXHRcdFx0dGhyb3cgRS5JTlZBTElEX0FSR1VNRU5UKCdFeHBlY3RlZCBkZWZhdWx0IHJvd3MgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cdFx0fVxuXHRcdHRoaXMuZGVmYXVsdFJvd3MgPSBvcHRzLmRlZmF1bHRSb3dzIHx8IDI0O1xuXG5cdFx0dGhpcy5zdGRpbiA9IG9wdHMuc3RkaW4gfHwgcHJvY2Vzcy5zdGRpbjtcblx0XHRpZiAoIXRoaXMuc3RkaW4gfHwgdHlwZW9mIHRoaXMuc3RkaW4gIT09ICdvYmplY3QnIHx8IHR5cGVvZiB0aGlzLnN0ZGluLnJlYWQgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRocm93IEUuSU5WQUxJRF9BUkdVTUVOVCgnRXhwZWN0ZWQgdGhlIHN0ZGluIHN0cmVhbSB0byBiZSBhIHJlYWRhYmxlIHN0cmVhbScsIHsgbmFtZTogJ3N0ZGluJywgc2NvcGU6ICdUZXJtaW5hbC5jb25zdHJ1Y3RvcicsIHZhbHVlOiBvcHRzLnN0ZGluIH0pO1xuXHRcdH1cblx0XHRyZWFkbGluZS5lbWl0S2V5cHJlc3NFdmVudHModGhpcy5zdGRpbik7XG5cblx0XHR0aGlzLnN0ZG91dCA9IHRoaXMucGF0Y2hTdHJlYW1Xcml0ZSgnc3Rkb3V0Jywgb3B0cy5zdGRvdXQgfHwgcHJvY2Vzcy5zdGRvdXQpO1xuXHRcdHRoaXMuc3RkZXJyID0gdGhpcy5wYXRjaFN0cmVhbVdyaXRlKCdzdGRlcnInLCBvcHRzLnN0ZGVyciB8fCBwcm9jZXNzLnN0ZGVycik7XG5cblx0XHR0aGlzLmRlZmF1bHQgPSBvcHRzLmRlZmF1bHQgPT09ICdzdGRvdXQnID8gdGhpcy5zdGRvdXQgOiB0aGlzLnN0ZGVycjtcblxuXHRcdHRoaXMuY29uc29sZSA9IG5ldyBDb25zb2xlKHRoaXMuc3Rkb3V0LCB0aGlzLnN0ZGVycik7XG5cblx0XHRpZiAob3B0cy5wcm9tcHRUaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmICh0eXBlb2Ygb3B0cy5wcm9tcHRUaW1lb3V0ICE9PSAnbnVtYmVyJyB8fCBpc05hTihvcHRzLnByb21wdFRpbWVvdXQpIHx8IG9wdHMucHJvbXB0VGltZW91dCA8IDApIHtcblx0XHRcdFx0dGhyb3cgRS5JTlZBTElEX0FSR1VNRU5UKCdFeHBlY3RlZCBwcm9tcHQgdGltZW91dCB0byBiZSBhIHBvc2l0aXZlIGludGVnZXInLCB7IG5hbWU6ICdwcm9tcHRUaW1lb3V0Jywgc2NvcGU6ICdUZXJtaW5hbC5jb25zdHJ1Y3RvcicsIHZhbHVlOiBvcHRzLnByb21wdFRpbWVvdXQgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMucHJvbXB0VGltZW91dCA9IG9wdHMucHJvbXB0VGltZW91dCB8IDA7XG5cblx0XHRpZiAodGhpcy5zdGRvdXQuaXNUVFkpIHtcblx0XHRcdHRoaXMuc3Rkb3V0Lm9uKCdyZXNpemUnLCAoKSA9PiB7XG5cdFx0XHRcdHRoaXMuZW1pdCgncmVzaXplJywge1xuXHRcdFx0XHRcdGNvbHVtbnM6IHRoaXMuc3Rkb3V0LmNvbHVtbnMsXG5cdFx0XHRcdFx0cm93czogICAgdGhpcy5zdGRvdXQucm93c1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGJlZXAoKSB7XG5cdFx0dGhpcy5zdGRlcnIud3JpdGUoYW5zaS5iZWVwKTtcblx0fVxuXG5cdHNob3dDdXJzb3IoKSB7XG5cdFx0dGhpcy5zdGRlcnIud3JpdGUoYW5zaS5jdXJzb3Iuc2hvdyk7XG5cdH1cblxuXHRoaWRlQ3Vyc29yKCkge1xuXHRcdHRoaXMuc3RkZXJyLndyaXRlKGFuc2kuY3Vyc29yLmhpZGUpO1xuXHR9XG5cblx0Z2V0IGNvbHVtbnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3Rkb3V0LmNvbHVtbnMgfHwgdGhpcy5kZWZhdWx0Q29sdW1ucztcblx0fVxuXG5cdGdldCByb3dzKCkge1xuXHRcdHJldHVybiB0aGlzLnN0ZG91dC5yb3dzIHx8IHRoaXMuZGVmYXVsdFJvd3M7XG5cdH1cblxuXHRvbkFkZEtleXByZXNzKCkge1xuXHRcdGlmICghdGhpcy5ybCkge1xuXHRcdFx0dGhpcy5ybCA9IHJlYWRsaW5lLmNyZWF0ZUludGVyZmFjZSh0aGlzLnN0ZGluKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5zdGRpbi5pc1RUWSAmJiArK3RoaXMucmF3TW9kZSA9PT0gMSkge1xuXHRcdFx0dGhpcy5zaWdpbnRIYW5kbGVyID0gKGNodW5rLCBrZXkpID0+IHtcblx0XHRcdFx0aWYgKGtleSAmJiBrZXkubmFtZSA9PT0gJ2MnICYmIGtleS5jdHJsKSB7XG5cdFx0XHRcdFx0dGhpcy5lbWl0KCdTSUdJTlQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5zdGRpbi5zZXRSYXdNb2RlKHRydWUpO1xuXHRcdFx0dGhpcy5zdGRpbi5vbigna2V5cHJlc3MnLCB0aGlzLnNpZ2ludEhhbmRsZXIpO1xuXHRcdH1cblx0fVxuXG5cdG9uUmVtb3ZlS2V5cHJlc3MoKSB7XG5cdFx0aWYgKHRoaXMuc3RkaW4uaXNUVFkgJiYgLS10aGlzLnJhd01vZGUgPT09IDApIHtcblx0XHRcdHRoaXMuc3RkaW4uc2V0UmF3TW9kZShmYWxzZSk7XG5cdFx0XHR0aGlzLnN0ZGluLnJlbW92ZUxpc3RlbmVyKCdrZXlwcmVzcycsIHRoaXMuc2lnaW50SGFuZGxlcik7XG5cdFx0XHR0aGlzLnNpZ2ludEhhbmRsZXIgPT09ICdmYWxzZSc7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMucmwpIHtcblx0XHRcdHRoaXMucmwuY2xvc2UoKTtcblx0XHRcdHRoaXMucmwgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBIHdyYXBwZXIgYXJvdW5kIGBFdmVudEVtaXR0ZXIub24oKWAuIElmIHRoZSBgZXZlbnRgIGlzIGBrZXlwcmVzc2AsIHRoZW4gdGhlIGV2ZW50IGlzIHJvdXRlZFxuXHQgKiB0byB0aGUgc3RkaW4gaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gZXZlbnQgLSBUaGUgZXZlbnQgbmFtZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgZXZlbnQgaGFuZGxlciBmdW5jdGlvbi5cblx0ICogQHJldHVybnMge1Rlcm1pbmFsfVxuXHQgKiBAYWNjZXNzIHB1YmxpY1xuXHQgKi9cblx0b24oZXZlbnQsIGxpc3RlbmVyKSB7XG5cdFx0aWYgKGV2ZW50ID09PSAna2V5cHJlc3MnKSB7XG5cdFx0XHR0aGlzLnN0ZGluLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG5cdFx0XHR0aGlzLm9uQWRkS2V5cHJlc3MoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3VwZXIub24oZXZlbnQsIGxpc3RlbmVyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQSB3cmFwcGVyIGFyb3VuZCBgRXZlbnRFbWl0dGVyLm9uY2UoKWAuIElmIHRoZSBgZXZlbnRgIGlzIGBrZXlwcmVzc2AsIHRoZW4gdGhlIGV2ZW50IGlzIHJvdXRlZFxuXHQgKiB0byB0aGUgc3RkaW4gaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gZXZlbnQgLSBUaGUgZXZlbnQgbmFtZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgZXZlbnQgaGFuZGxlciBmdW5jdGlvbi5cblx0ICogQHJldHVybnMge1Rlcm1pbmFsfVxuXHQgKiBAYWNjZXNzIHB1YmxpY1xuXHQgKi9cblx0b25jZShldmVudCwgbGlzdGVuZXIpIHtcblx0XHRpZiAoZXZlbnQgPT09ICdrZXlwcmVzcycpIHtcblx0XHRcdHRoaXMuc3RkaW4ub25jZShldmVudCwgKC4uLmFyZ3MpID0+IHtcblx0XHRcdFx0dGhpcy5vblJlbW92ZUtleXByZXNzKCk7XG5cdFx0XHRcdGxpc3RlbmVyKC4uLmFyZ3MpO1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLm9uQWRkS2V5cHJlc3MoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3VwZXIub25jZShldmVudCwgbGlzdGVuZXIpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHdyYXBwZXIgYXJvdW5kIGBFdmVudEVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoKWAuIElmIHRoZSBgZXZlbnRgIGlzIGBrZXlwcmVzc2AsIHRoZW4gdGhlIGV2ZW50IGlzIHJvdXRlZFxuXHQgKiB0byB0aGUgc3RkaW4gaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gZXZlbnQgLSBUaGUgZXZlbnQgbmFtZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgZXZlbnQgaGFuZGxlciBmdW5jdGlvbi5cblx0ICogQHJldHVybnMge1Rlcm1pbmFsfVxuXHQgKiBAYWNjZXNzIHB1YmxpY1xuXHQgKi9cblx0cmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG5cdFx0aWYgKGV2ZW50ID09PSAna2V5cHJlc3MnKSB7XG5cdFx0XHR0aGlzLnN0ZGluLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG5cdFx0XHR0aGlzLm9uUmVtb3ZlS2V5cHJlc3MoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3VwZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgY2FsbGJhY2sgdG8gYmUgbm90aWZpZWQgd2hlbiBvdXRwdXQgZmlyc3Qgb2NjdXJzIHVubGVzcyBvdXRwdXQgaGFzIGFscmVhZHkgb2NjdXJyZWRcblx0ICogaW4gd2hpY2ggY2FzZSB0aGUgY2FsbGJhY2sgaXMgaW1tZWRpYXRlbHkgaW52b2tlZC4gVGhpcyBpcyBiYXNpY2FsbHkgYSBzeW5jaHJvbm91cyBwcm9taXNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIFRoZSBjYWxsYmFjayB0byBub3RpZnkgd2hlbiBvdXRwdXQgZmlyc3Qgb2NjdXJzLlxuXHQgKiBAcmV0dXJucyB7VGVybWluYWx9XG5cdCAqIEBhY2Nlc3MgcHVibGljXG5cdCAqL1xuXHRvbk91dHB1dChjYikge1xuXHRcdGlmICh0aGlzLm91dHB1dENhbGxiYWNrcykge1xuXHRcdFx0dGhpcy5vdXRwdXRDYWxsYmFja3MucHVzaChjYik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNiKHRoaXMub3V0cHV0UmVzb2x1dGlvbik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhdGNoZXMgYSBzdHJlYW0ncyBgd3JpdGUoKWAgbWV0aG9kIHRvIGRldGVjdCBvdXRwdXQgY29udGVudHMgYW5kIGVtaXQgYW4gYG91dHB1dGAgZXZlbnQgZm9yXG5cdCAqIHRleHQtYmFzZWQgb3V0cHV0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBzdHJlYW0gbmFtZS5cblx0ICogQHBhcmFtIHtzdHJlYW0uV3JpdGFibGV9IHN0cmVhbSAtIEEgd3JpdGFibGUgb3V0cHV0IHN0cmVhbS5cblx0ICogQHJldHVybnMge3N0cmVhbS5Xcml0YWJsZX1cblx0ICogQGFjY2VzcyBwcml2YXRlXG5cdCAqL1xuXHRwYXRjaFN0cmVhbVdyaXRlKG5hbWUsIHN0cmVhbSkge1xuXHRcdGlmICghc3RyZWFtIHx8IHR5cGVvZiBzdHJlYW0gIT09ICdvYmplY3QnIHx8IHR5cGVvZiBzdHJlYW0ud3JpdGUgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRocm93IEUuSU5WQUxJRF9BUkdVTUVOVChgRXhwZWN0ZWQgdGhlICR7bmFtZX0gc3RyZWFtIHRvIGJlIGEgd3JpdGFibGUgc3RyZWFtYCwgeyBuYW1lLCBzY29wZTogJ1Rlcm1pbmFsLnBhdGNoU3RyZWFtV3JpdGUnLCB2YWx1ZTogc3RyZWFtIH0pO1xuXHRcdH1cblxuXHRcdGxvZyhgUGF0Y2hpbmcgb3V0cHV0IHN0cmVhbTogJHtoaWdobGlnaHQobmFtZSl9YCk7XG5cblx0XHRjb25zdCBvcmlnV3JpdGUgPSBzdHJlYW0ud3JpdGU7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0XHRjb25zdCB3cml0ZSA9IGZ1bmN0aW9uIHdyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcblx0XHRcdGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Y2IgPSBlbmNvZGluZztcblx0XHRcdFx0ZW5jb2RpbmcgPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc2VsZi5vdXRwdXRGaXJlZCA9PT0gdW5kZWZpbmVkICYmICghZW5jb2RpbmcgfHwgZW5jb2RpbmdzLmhhcyhlbmNvZGluZykpICYmICEoc2VsZi5vdXRwdXRGaXJlZCA9IGRhdGFSZWdFeHAudGVzdChjaHVuaykpKSB7XG5cdFx0XHRcdHNlbGYub3V0cHV0UmVzb2x1dGlvbiA9IHsgY2h1bmssIGVuY29kaW5nIH07XG5cdFx0XHRcdGlmIChzZWxmLm91dHB1dENhbGxiYWNrcykge1xuXHRcdFx0XHRcdGZvciAoY29uc3QgY2Igb2Ygc2VsZi5vdXRwdXRDYWxsYmFja3MpIHtcblx0XHRcdFx0XHRcdGNiKHNlbGYub3V0cHV0UmVzb2x1dGlvbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlbGYub3V0cHV0Q2FsbGJhY2tzID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb3JpZ1dyaXRlLmNhbGwoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblx0XHR9O1xuXG5cdFx0c3RyZWFtLndyaXRlID0gd3JpdGUuYmluZChzdHJlYW0pO1xuXG5cdFx0cmV0dXJuIHN0cmVhbTtcblx0fVxufVxuIl0sImZpbGUiOiJ0ZXJtaW5hbC5qcyJ9
