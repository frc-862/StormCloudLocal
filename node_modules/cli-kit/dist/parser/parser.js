"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = _interopRequireDefault(require("lodash.camelcase"));

var _command = _interopRequireDefault(require("./command"));

var _context = _interopRequireDefault(require("./context"));

var _debug = _interopRequireDefault(require("../lib/debug"));

var _errors = _interopRequireDefault(require("../lib/errors"));

var _extension = _interopRequireDefault(require("./extension"));

var _hookEmitter = _interopRequireDefault(require("hook-emitter"));

var _parsedArgument = _interopRequireDefault(require("./parsed-argument"));

var _pluralize = _interopRequireDefault(require("pluralize"));

var _util = require("../lib/util");

var _types = require("./types");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const {
  log
} = (0, _debug.default)('cli-kit:parser');
const {
  highlight,
  note
} = _debug.default.styles;
const dashOpt = /^(?:-|—)(.+?)(?:=(.+))?$/;
const negateRegExp = /^no-(.+)$/;
const optRE = /^(?:--|—)(?:([^=]+)(?:=([\s\S]*))?)$/;
/**
 * A collection of parsed CLI arguments.
 *
 * @extends {HookEmitter}
 */

class Parser extends _hookEmitter.default {
  /**
   * An object containing all of the parsed options, flags, and named arguments.
   *
   * @type {Object}
   */

  /**
   * A list of options and arguments in which their callbacks were fired during parsing so that
   * we don't fire the callbacks again when setting the default values.
   * @type {Set}
   */

  /**
   * An object containing only unknown parsed options and flags.
   *
   * @type {Object}
   */

  /**
   * An array of parsed arguments.
   *
   * @type {Array}
   */

  /**
   * Initializes the internal properties and class name.
   *
   * @param {Object} [opts] - Various options.
   * @param {Object} [opts.data] - User-defined data to pass into the selected command.
   * @param {Function} [opts.exitCode] - A function that sets the exit code.
   * @param {Termianl} [opts.terminal] - A terminal instance to override the default CLI terminal
   * instance.
   * @access public
   */
  constructor(opts = {}) {
    super();

    _defineProperty(this, "argv", {});

    _defineProperty(this, "_fired", new Set());

    _defineProperty(this, "unknown", {});

    _defineProperty(this, "_", []);

    Object.defineProperties(this, {
      /**
       * The array of arguments. As arguments are identified, they are replaced with
       * `ParsedArgument` instances and in the case of options with values and extra options,
       * the array is shortened.
       * @type {Array.<String|ParsedArgument>}
       */
      args: {
        value: null,
        writable: true
      },

      /**
       * A stack of contexts applied to the arguments. The first element is the most specific
       * context, usually a command. The last element is typically the root `CLI` instance.
       * @type {Array.<Context>}
       */
      contexts: {
        value: null,
        writable: true
      },

      /**
       * A map of option and argument environment variable values derived from all options
       * and arguments found across all contexts.
       * @type {Object}
       */
      env: {
        value: null,
        writable: true
      },

      /**
       * Options possibly containing a `data` payload, `exitCode`, and `terminal` instance.
       * @type {Object}
       */
      opts: {
        value: opts
      },

      /**
       * A list of all required arguments and options that were missing. The caller (e.g.
       * the `CLI` instance) is responsible for enforcing missing arguments.
       * @type {Set}
       */
      required: {
        value: null,
        writable: true
      }
    });
    (0, _util.declareCLIKitClass)(this, 'Parser');
  }
  /**
   * Loops over the contexts in reverse from the top-level to the most specific context and
   * gathers the option defaults as well as any options specified as environment variables.
   *
   * @returns {Promise}
   * @access private
   */


  async applyDefaults() {
    const requiredOptions = {
      long: {},
      short: {}
    };
    const len = this.contexts.length;
    log(`Processing default options and environment variables for ${highlight(len)} ${(0, _pluralize.default)('context', len)}`);
    this.env = {}; // loop through every context

    for (let i = len; i; i--) {
      const ctx = this.contexts[i - 1]; // init options

      for (const options of ctx.options.values()) {
        for (const option of options) {
          if (option.name) {
            const name = option.camelCase || ctx.get('camelCase') ? (0, _lodash.default)(option.name) : option.name;

            if (this.argv[name] === undefined) {
              let value = option.default;

              if (option.datatype === 'bool' && typeof value !== 'boolean') {
                value = !!option.negate;
              } else if (option.type === 'count') {
                value = 0;
              }

              if (option.multiple && !Array.isArray(value)) {
                value = value !== undefined ? [value] : [];
              }

              if (!this._fired.has(option) && typeof option.callback === 'function') {
                const newValue = await option.callback({
                  ctx,
                  data: this.opts.data,
                  exitCode: this.opts.exitCode,
                  input: [value],
                  name,

                  async next() {},

                  opts: this.opts,
                  option,
                  parser: this,
                  value
                });

                if (newValue !== undefined) {
                  value = newValue;
                }
              }

              this.argv[name] = value;
            }

            if (option.env && process.env[option.env] !== undefined) {
              this.env[name] = option.transform(process.env[option.env]);
            }
          }

          if (option.required) {
            if (option.long) {
              requiredOptions.long[option.long] = option;
            }

            if (option.short) {
              requiredOptions.short[option.short] = option;
            }
          } else {
            if (option.long) {
              delete requiredOptions.long[option.long];
            }

            if (option.short) {
              delete requiredOptions.short[option.short];
            }
          }
        }
      } // init arguments


      for (const arg of ctx.args) {
        if (arg.name) {
          const name = arg.camelCase || ctx.get('camelCase') ? (0, _lodash.default)(arg.name) : arg.name;

          if (this.argv[name] === undefined) {
            let value = arg.default;

            if (arg.multiple && !Array.isArray(value)) {
              value = value !== undefined ? [value] : [];
            }

            if (!this._fired.has(arg) && typeof arg.callback === 'function') {
              const newValue = await arg.callback({
                arg,
                ctx,
                data: this.opts.data,
                exitCode: this.opts.exitCode,
                name,
                opts: this.opts,
                parser: this,
                value
              });

              if (newValue !== undefined) {
                value = newValue;
              }
            }

            this.argv[name] = value;
          }

          if (arg.env && process.env[arg.env] !== undefined) {
            this.env[name] = arg.transform(process.env[arg.env]);
          }
        }
      }
    }

    this.required = new Set(Object.values(requiredOptions.long));

    for (const option of Object.values(requiredOptions.short)) {
      this.required.add(option);
    }
  }
  /**
   * Loops over the parsed arguments and populates the `argv` and `_` properties.
   *
   * @returns {Promise}
   * @access private
   */


  async fillArgv() {
    // from here, we want to deal with the most specific context
    const ctx = this.contexts[0]; // loop over the parsed args and fill in the `argv` and `_`

    log('Filling argv and _'); // combine parsed args that are options with multiple flag set

    for (let k = 0; k < this.args.length; k++) {
      let current = this.args[k];

      if (current instanceof _parsedArgument.default && current.type === 'option' && current.option.multiple) {
        for (let j = k + 1; j < this.args.length; j++) {
          let next = this.args[j];

          if (next instanceof _parsedArgument.default && next.type === 'option' && next.option === current.option) {
            if (!Array.isArray(current.value)) {
              current.value = [current.value];
            }

            if (next.value !== undefined) {
              current.value = [].concat(current.value, next.value);
            }

            this.args.splice(j--, 1);
          }
        }
      }
    }

    let index = 0;
    let extra = [];

    const setArg = async (idx, value) => {
      const arg = ctx.args[idx]; // extract the parsed arg value

      if (value instanceof _parsedArgument.default) {
        value.arg = arg;
        value = value.input[0];
      }

      if (arg) {
        const name = arg.camelCase || ctx.get('camelCase') ? (0, _lodash.default)(arg.name) : arg.name;
        value = arg.transform(value);

        if (typeof arg.callback === 'function') {
          const newValue = await arg.callback({
            arg,
            ctx,
            data: this.opts.data,
            exitCode: this.opts.exitCode,
            name,
            opts: this.opts,
            parser: this,
            value
          });

          if (newValue !== undefined) {
            value = newValue;
          }

          this._fired.add(arg);
        }

        if (arg.multiple) {
          // if this arg gobbles up multiple parsed args, then we decrement `i` so
          // that we never increment it and no further arguments will be applied
          index--;

          if (Array.isArray(this.argv[name])) {
            this.argv[name].push(value);
          } else {
            this.argv[name] = [value];
          }
        } else {
          this.argv[name] = value;
        }
      }

      this._.push(value);
    }; // loop over the parsed args and assign the values to _ and argv


    for (const parsedArg of this.args) {
      let name;
      const isParsed = parsedArg instanceof _parsedArgument.default;

      if (!isParsed || parsedArg.type === 'argument') {
        await setArg(index++, parsedArg);
        continue;
      }

      switch (parsedArg.type) {
        case 'argument':
          // already handled above
          break;

        case 'extra':
          extra = parsedArg.args;
          break;

        case 'option':
          {
            const {
              option
            } = parsedArg;
            name = option.camelCase || ctx.get('camelCase') ? (0, _lodash.default)(option.name) : option.name;
            let {
              value
            } = parsedArg;

            if (option.type === 'count') {
              value = (this.argv[name] || 0) + 1;
            } // non-multiple option callbacks have already been fired, now we need
            // to do it just for multiple value options


            if (typeof option.callback === 'function' && option.multiple) {
              log(`Firing option ${highlight(option.format)} callback ${note(`(${option.parent.name})`)}`);
              const newValue = await option.callback({
                ctx,
                data: this.opts.data,
                exitCode: this.opts.exitCode,
                input: [value],
                name,

                async next() {},

                opts: this.opts,
                option,
                parser: this,
                value
              });

              if (newValue !== undefined) {
                value = newValue;
              }

              this._fired.add(option);
            }

            if (value !== undefined) {
              // set the parsed value (overwrites the default value)
              this.argv[name] = value;
            } // argv[name] either has the new value or the default value, but either way we must re-check it


            if (this.argv[name] !== undefined && (!option.multiple || this.argv[name].length)) {
              this.required.delete(option);
            } // if argv[name] has no value and no default, at least set it to an empty string
            // note: this must be done after the required check above


            if (this.argv[name] === undefined && option.datatype === 'string') {
              this.argv[name] = option.transform('');
            }
          }
          break;

        case 'unknown':
          // since this is an unknown option, we try to guess it's type and if it's
          // a bool, we will honor the negate (e.g. --no-<name>)
          let {
            value
          } = parsedArg;
          value = value === undefined ? true : (0, _types.transformValue)(value);

          if (typeof value === 'boolean' && parsedArg.negated) {
            value = !value;
          } // clean up the name


          name = ctx.get('camelCase') ? (0, _lodash.default)(parsedArg.name) : parsedArg.name;
          this.argv[name] = this.unknown[name] = value;

          if (ctx.get('treatUnknownOptionsAsArguments')) {
            this._.push(parsedArg.input[0]);
          }

          break;
      }
    } // add the extra items


    this._.push.apply(this._, extra); // process env vars


    log('Mixing in environment variable values');
    Object.assign(this.argv, this.env);
  }
  /**
   * Parses the command line arguments.
   *
   * @param {Object} opts - Various options.
   * @param {Array} opts.args - An array of raw, unparsed arguments.
   * @param {Context} opts.ctx - The context to reference for commands, options, and arguments.
   * @returns {Promise<Parser>}
   * @access public
   */


  async parse(opts) {
    const fn = this.hook('parse', async ({
      args,
      ctx
    }) => {
      if (!Array.isArray(args)) {
        throw _errors.default.INVALID_ARGUMENT('Expected args to be an array', {
          name: 'args',
          scope: 'Parser.parse',
          value: args
        });
      }

      if (!(ctx instanceof _context.default)) {
        throw _errors.default.INVALID_ARGUMENT('Expected ctx to be a context', {
          name: 'ctx',
          scope: 'Parser.parse',
          value: ctx
        });
      }

      this.args = args;
      this.contexts = [ctx];
      log(`Processing ${(0, _pluralize.default)('argument', args.length, true)}: ${highlight(this.args.join(', '))}`); // process the arguments against the context

      await this.parseWithContext(ctx);
      return this;
    });

    try {
      return await fn({ ...opts,
        data: this.opts.data,
        parser: this
      });
    } catch (err) {
      err.contexts = this.contexts;
      throw err;
    }
  }
  /**
   * Processes the arguments against the given context. If a command is found, it recursively
   * calls itself.
   *
   * @param {CLI|Command} ctx - The context to apply when parsing the command line arguments.
   * @returns {Promise}
   * @access private
   */


  async parseWithContext(ctx) {
    // print the context's info
    log(`Context: ${highlight(ctx.name)}`);

    if (!ctx.lookup.empty) {
      log(ctx.lookup.toString());
    }

    await this.parseArg(ctx, 0);
  }
  /**
   * Parses a single argument as apart of a chain of promises.
   *
   * @param {CLI|Command} ctx - The context to apply when parsing the command line arguments.
   * @param {Number} i - The argument index number to parse.
   * @param {Number} [to] - The index to go until.
   * @returns {Promise}
   * @access private
   */


  async parseArg(ctx, i, to) {
    if (to !== undefined && i >= to) {
      // all caught up, return
      return;
    }

    let {
      rev
    } = ctx;
    let {
      length
    } = this.args;

    const checkRev = async (ctx, to) => {
      if (ctx.rev > rev) {
        // we always need a `to`
        if (to === undefined) {
          to = this.args.length;
        }

        log(`Rev changed from ${highlight(rev)} to ${highlight(ctx.rev)}, reparsing ${highlight(0)} through ${highlight(to)}`);
        rev = ctx.rev;
        await this.parseArg(ctx, 0, to);
      }
    };

    if (to === undefined && i >= length) {
      let cmd = this.contexts[0]; // if there are no more contexts to descend, check if the top-most context is actually
      // a default subcommand

      if (cmd === ctx && cmd.action instanceof _command.default) {
        cmd = cmd.action;
        cmd.link(ctx);
        this.contexts.unshift(cmd);
      }

      if (cmd !== ctx) {
        log('Descending into next context\'s parser');
        return this.parseWithContext(cmd);
      }

      await this.hook('finalize', async () => {
        await checkRev(ctx); // check if pre-finalize changed the rev

        await this.applyDefaults();
        await checkRev(ctx); // check if applyDefaults changed the rev

        await this.fillArgv();
      })({
        ctx,
        data: this.opts.data,
        parser: this
      });
      await checkRev(ctx); // check if post-finalize or fillArgv changed the rev

      log('End of the line');
      return;
    } // create a ParsedArgument object for the next argument


    const arg = await this.createParsedArgument(ctx, i); // if the length was shortened, then decrement `to`

    if (to !== undefined && this.args.length < length) {
      to -= length - this.args.length;
      log(`Argument list was shortened from ${length} to ${this.args.length} (to=${to})`);
    }

    if (arg) {
      const {
        type
      } = arg; // check if the context changed (e.g. we found a command/extension) so that we continue
      // to process arguments against the current context before we descend into the newly
      // discovered command/extension context

      const sameContext = this.contexts[0] === ctx;

      if (type !== 'command' && type !== 'extension' || sameContext) {
        this.args[i] = arg;
      }

      if ((type === 'command' || type === 'extension') && sameContext) {
        // link the context hook emitters
        const cmd = arg.command;
        cmd.link(ctx);

        if (typeof cmd.callback === 'function') {
          await cmd.callback({
            command: arg.command,
            data: this.opts.data,
            parser: this
          });
        } // add the context to the stack


        this.contexts.unshift(cmd);
      } else if (type === 'option' && !sameContext && this.contexts[0] instanceof _extension.default && !this.contexts[0].isCLIKitExtension) {
        log(`Forcing option ${highlight(arg.option.format)} to be an argument because we found a non-cli-kit extension ${highlight(this.contexts[0].name)}`);
        this.args[i] = new _parsedArgument.default('argument', {
          input: arg.input
        });
      } else if (type === 'option' && typeof arg.option.callback === 'function' && !arg.option.multiple) {
        const {
          option
        } = arg;
        log(`Firing option ${highlight(option.format)} callback ${note(`(${option.parent.name})`)}`);
        let fired = false;

        try {
          const value = await option.callback({
            ctx,
            data: this.opts.data,
            exitCode: this.opts.exitCode,
            input: arg.input,
            name: option.camelCase || ctx.get('camelCase') ? (0, _lodash.default)(option.name) : option.name,
            next: async () => {
              if (fired) {
                log('next() already fired');
                return;
              }

              fired = true;
              log(`Option ${highlight(option.format)} called next(), processing next arg`);
              await checkRev(ctx, i);
              await this.parseArg(ctx, i + 1, to);
              return this.args[i].value;
            },
            opts: this.opts,
            option,
            parser: this,
            value: arg.value
          });

          if (value === undefined) {
            log(`Option ${highlight(option.format)} callback did not change the value`);
          } else {
            log(`Option ${highlight(option.format)} callback changed value ${highlight(arg.value)} to ${highlight(value)}`);
            arg.value = value;
          }

          this._fired.add(option);

          if (fired) {
            return;
          }

          log(`Option ${highlight(option.format)} did not call next(), processing next arg`);
        } catch (err) {
          if (err.code !== 'ERR_NOT_AN_OPTION') {
            throw err;
          }

          this.args[i] = new _parsedArgument.default('argument', {
            input: arg.input
          });
        }
      }
    }

    await checkRev(ctx, i);
    await this.parseArg(ctx, i + 1, to);
  }
  /**
   * Detects what the argument is and returns an object that identifies what was found.
   *
   * @param {CLI|Command} ctx - The context to apply when parsing the command line arguments.
   * @param {Number} i - The argument index number to parse.
   * @returns {Promise<?ParsedArgument>} Resolves a `ParsedArgument` or `undefined` if the
   * argument was already a `ParsedArgument` and didn't change.
   * @access private
   */


  async createParsedArgument(ctx, i) {
    const {
      args
    } = this;

    if (i >= args.length) {
      throw _errors.default.RANGE_ERROR(`Expected argument index to be between 0 and ${args.length}`, {
        name: 'index',
        scope: 'Parser.createParsedArgument',
        value: i,
        range: [0, args.length - 1]
      });
    }

    const arg = args[i];
    const isParsed = arg instanceof _parsedArgument.default;
    const type = isParsed && arg.type;
    log(`Processing argument [${i}]: ${highlight(arg)}`); // check if the argument is a the `--` extra arguments sequence

    if (arg === '--') {
      const extra = args.splice(i + 1, args.length);
      return new _parsedArgument.default('extra', {
        args: extra,
        input: [arg, ...extra]
      });
    }

    if (type === 'extra') {
      log('Skipping extra arguments');
      return;
    }

    const {
      lookup
    } = ctx;
    let subject = isParsed ? arg.input ? arg.input[0] : null : arg; // check if the argument is an option

    if (!type || type === 'option' || type === 'unknown') {
      let m = subject.match(optRE);
      let negated = false;
      let option;

      if (m) {
        // --something or --something=foo
        negated = m[1].match(negateRegExp);
        const name = negated ? negated[1] : m[1];
        option = lookup.long[name] || null; // check if short option
      } else if (m = subject.match(dashOpt)) {
        if (m[1].length > 1) {
          log(`Splitting group: ${highlight(m[1])}`);
          const newArgs = m[1].split('').map((arg, i, arr) => i + 1 === arr.length && m[2] ? `-${arg}=${m[2]}` : `-${arg}`);
          subject = newArgs.shift();
          log(`Inserting arguments: ${newArgs.join(', ')}`);
          this.args.splice(i + 1, 0, ...newArgs);
        }

        option = lookup.short[m[1][0]] || null;
      }

      if (!option && type) {
        // not an option in this context, leave it alone
        log(`Skipping ${type === 'unknown' ? 'un' : ''}known option: ${highlight(arg.getName())}`);
        return;
      }

      if (option) {
        log(`${type === 'option' ? 'Overriding' : 'Found'} option: ${highlight(option.name)} ${note(`(${option.datatype})`)} Negated? ${highlight(!!negated)}`);
        let input = [subject];
        let value;

        if (option.isFlag) {
          value = option.transform(type && arg.value !== undefined ? arg.value : true, negated);
        } else if (type === 'option') {
          value = option.transform(args[i].value);
        } else if (m[2]) {
          value = option.transform(m[2], negated);
        } else if (i + 1 < args.length) {
          const nextArg = args[i + 1];

          if (nextArg instanceof _parsedArgument.default) {
            if (nextArg.type === 'argument') {
              input.push(...nextArg.input);
              args.splice(i + 1, 1); // maybe the unknown option is actually a value that just
              // happens to match the pattern for an option?

              value = option.transform(nextArg.input[0], negated);
            } else {
              // next arg has already been identified, so treat this option as a flag
              value = true;
            }
          } else {
            input.push(nextArg);
            args.splice(i + 1, 1);
            value = option.transform(nextArg, negated);
          }
        }

        if (value === undefined) {
          if (type && arg.value !== undefined) {
            value = option.transform(arg.value, negated);
          } else if (option.type === 'bool') {
            value = option.transform(true, negated);
          }
        }

        return new _parsedArgument.default('option', {
          input,
          option,
          value: value !== undefined && !Array.isArray(value) && option.multiple ? [value] : value
        });
      } // if the argument matched an option pattern, but didn't match a defined option, then we
      // can add it as an unknown option which will eventually become a flag


      if (option === null && !type) {
        log(`Found unknown option: ${highlight(subject)}`);
        return new _parsedArgument.default('unknown', {
          input: [subject],
          name: negated ? negated[1] : m[1],
          negated,
          value: m[2] === undefined && isParsed ? arg.value : m[2]
        });
      }
    } // check if the argument is a command


    if (type === 'command' || type === 'extension') {
      log(`Skipping known ${type}: ${highlight(arg.command.name)}`);
      return;
    } // check if command and make sure we haven't already added a command this round


    const cmd = lookup.commands[subject];

    if (cmd) {
      log(`Found command: ${highlight(cmd.name)}`);
      return new _parsedArgument.default('command', {
        command: cmd,
        input: isParsed ? arg.input : [arg]
      });
    }

    const ext = lookup.extensions[subject];

    if (ext) {
      log(`Found extension: ${highlight(ext.name)}`);

      if (typeof ext.load === 'function') {
        await ext.load(subject);
      }

      return new _parsedArgument.default('extension', {
        command: ext,
        input: isParsed ? arg.input : [arg]
      });
    }

    if (!type) {
      log(`Found unknown argument: ${highlight(arg)}`);
      return new _parsedArgument.default('argument', {
        input: isParsed ? arg.input : [arg]
      });
    }
  }
  /**
   * Reconstructs the arguments into a string.
   *
   * @returns {String}
   * @access public
   */


  toString() {
    return this.valueOf().join(' ');
  }
  /**
   * Returns a reconstruction of `process.argv`.
   *
   * @returns {Array.<String>}
   * @access public
   */


  valueOf() {
    return this.args.map(arg => String(arg));
  }

}

exports.default = Parser;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcnNlci9wYXJzZXIuanMiXSwibmFtZXMiOlsibG9nIiwiaGlnaGxpZ2h0Iiwibm90ZSIsImRlYnVnIiwic3R5bGVzIiwiZGFzaE9wdCIsIm5lZ2F0ZVJlZ0V4cCIsIm9wdFJFIiwiUGFyc2VyIiwiSG9va0VtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJTZXQiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiYXJncyIsInZhbHVlIiwid3JpdGFibGUiLCJjb250ZXh0cyIsImVudiIsInJlcXVpcmVkIiwiYXBwbHlEZWZhdWx0cyIsInJlcXVpcmVkT3B0aW9ucyIsImxvbmciLCJzaG9ydCIsImxlbiIsImxlbmd0aCIsImkiLCJjdHgiLCJvcHRpb25zIiwidmFsdWVzIiwib3B0aW9uIiwibmFtZSIsImNhbWVsQ2FzZSIsImdldCIsImFyZ3YiLCJ1bmRlZmluZWQiLCJkZWZhdWx0IiwiZGF0YXR5cGUiLCJuZWdhdGUiLCJ0eXBlIiwibXVsdGlwbGUiLCJBcnJheSIsImlzQXJyYXkiLCJfZmlyZWQiLCJoYXMiLCJjYWxsYmFjayIsIm5ld1ZhbHVlIiwiZGF0YSIsImV4aXRDb2RlIiwiaW5wdXQiLCJuZXh0IiwicGFyc2VyIiwicHJvY2VzcyIsInRyYW5zZm9ybSIsImFyZyIsImFkZCIsImZpbGxBcmd2IiwiayIsImN1cnJlbnQiLCJQYXJzZWRBcmd1bWVudCIsImoiLCJjb25jYXQiLCJzcGxpY2UiLCJpbmRleCIsImV4dHJhIiwic2V0QXJnIiwiaWR4IiwicHVzaCIsIl8iLCJwYXJzZWRBcmciLCJpc1BhcnNlZCIsImZvcm1hdCIsInBhcmVudCIsImRlbGV0ZSIsIm5lZ2F0ZWQiLCJ1bmtub3duIiwiYXBwbHkiLCJhc3NpZ24iLCJwYXJzZSIsImZuIiwiaG9vayIsIkUiLCJJTlZBTElEX0FSR1VNRU5UIiwic2NvcGUiLCJDb250ZXh0Iiwiam9pbiIsInBhcnNlV2l0aENvbnRleHQiLCJlcnIiLCJsb29rdXAiLCJlbXB0eSIsInRvU3RyaW5nIiwicGFyc2VBcmciLCJ0byIsInJldiIsImNoZWNrUmV2IiwiY21kIiwiYWN0aW9uIiwiQ29tbWFuZCIsImxpbmsiLCJ1bnNoaWZ0IiwiY3JlYXRlUGFyc2VkQXJndW1lbnQiLCJzYW1lQ29udGV4dCIsImNvbW1hbmQiLCJFeHRlbnNpb24iLCJpc0NMSUtpdEV4dGVuc2lvbiIsImZpcmVkIiwiY29kZSIsIlJBTkdFX0VSUk9SIiwicmFuZ2UiLCJzdWJqZWN0IiwibSIsIm1hdGNoIiwibmV3QXJncyIsInNwbGl0IiwibWFwIiwiYXJyIiwic2hpZnQiLCJnZXROYW1lIiwiaXNGbGFnIiwibmV4dEFyZyIsImNvbW1hbmRzIiwiZXh0IiwiZXh0ZW5zaW9ucyIsImxvYWQiLCJ2YWx1ZU9mIiwiU3RyaW5nIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7OztBQUVBLE1BQU07QUFBRUEsRUFBQUE7QUFBRixJQUFVLG9CQUFNLGdCQUFOLENBQWhCO0FBQ0EsTUFBTTtBQUFFQyxFQUFBQSxTQUFGO0FBQWFDLEVBQUFBO0FBQWIsSUFBc0JDLGVBQU1DLE1BQWxDO0FBRUEsTUFBTUMsT0FBTyxHQUFHLDBCQUFoQjtBQUNBLE1BQU1DLFlBQVksR0FBRyxXQUFyQjtBQUNBLE1BQU1DLEtBQUssR0FBRyxzQ0FBZDtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ2UsTUFBTUMsTUFBTixTQUFxQkMsb0JBQXJCLENBQWlDO0FBQy9DO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBR0M7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFHQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUdDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBR0M7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQ0MsRUFBQUEsV0FBVyxDQUFDQyxJQUFJLEdBQUcsRUFBUixFQUFZO0FBQ3RCOztBQURzQixrQ0FqQ2hC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QUFBQSxLQUFLLEVBQUVxQixRQUFRLEdBQUdoQixHQUFHLENBQUNMLEtBQVAsR0FBZSxDQUFFSyxHQUFGO0FBRlEsT0FBaEMsQ0FBUDtBQUlBOztBQUVELFFBQUksQ0FBQ2YsSUFBTCxFQUFXO0FBQ1Z4QyxNQUFBQSxHQUFHLENBQUUsMkJBQTBCQyxTQUFTLENBQUNzRCxHQUFELENBQU0sRUFBM0MsQ0FBSDtBQUNBLGFBQU8sSUFBSUssdUJBQUosQ0FBbUIsVUFBbkIsRUFBK0I7QUFDckNWLFFBQUFBLEtBQUssRUFBRXFCLFFBQVEsR0FBR2hCLEdBQUcsQ0FBQ0wsS0FBUCxHQUFlLENBQUVLLEdBQUY7QUFETyxPQUEvQixDQUFQO0FBR0E7QUFDRDtBQUVEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0NvQyxFQUFBQSxRQUFRLEdBQUc7QUFDVixXQUFPLEtBQUtrQyxPQUFMLEdBQWV2QyxJQUFmLENBQW9CLEdBQXBCLENBQVA7QUFDQTtBQUVEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0N1QyxFQUFBQSxPQUFPLEdBQUc7QUFDVCxXQUFPLEtBQUs5RyxJQUFMLENBQVVvRyxHQUFWLENBQWM1RCxHQUFHLElBQUl1RSxNQUFNLENBQUN2RSxHQUFELENBQTNCLENBQVA7QUFDQTs7QUF0eUI4QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjYW1lbENhc2UgZnJvbSAnbG9kYXNoLmNhbWVsY2FzZSc7XG5pbXBvcnQgQ29tbWFuZCBmcm9tICcuL2NvbW1hbmQnO1xuaW1wb3J0IENvbnRleHQgZnJvbSAnLi9jb250ZXh0JztcbmltcG9ydCBkZWJ1ZyBmcm9tICcuLi9saWIvZGVidWcnO1xuaW1wb3J0IEUgZnJvbSAnLi4vbGliL2Vycm9ycyc7XG5pbXBvcnQgRXh0ZW5zaW9uIGZyb20gJy4vZXh0ZW5zaW9uJztcbmltcG9ydCBIb29rRW1pdHRlciBmcm9tICdob29rLWVtaXR0ZXInO1xuaW1wb3J0IFBhcnNlZEFyZ3VtZW50IGZyb20gJy4vcGFyc2VkLWFyZ3VtZW50JztcbmltcG9ydCBwbHVyYWxpemUgZnJvbSAncGx1cmFsaXplJztcblxuaW1wb3J0IHsgZGVjbGFyZUNMSUtpdENsYXNzIH0gZnJvbSAnLi4vbGliL3V0aWwnO1xuaW1wb3J0IHsgdHJhbnNmb3JtVmFsdWUgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgeyBsb2cgfSA9IGRlYnVnKCdjbGkta2l0OnBhcnNlcicpO1xuY29uc3QgeyBoaWdobGlnaHQsIG5vdGUgfSA9IGRlYnVnLnN0eWxlcztcblxuY29uc3QgZGFzaE9wdCA9IC9eKD86LXzigJQpKC4rPykoPzo9KC4rKSk/JC87XG5jb25zdCBuZWdhdGVSZWdFeHAgPSAvXm5vLSguKykkLztcbmNvbnN0IG9wdFJFID0gL14oPzotLXzigJQpKD86KFtePV0rKSg/Oj0oW1xcc1xcU10qKSk/KSQvO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBwYXJzZWQgQ0xJIGFyZ3VtZW50cy5cbiAqXG4gKiBAZXh0ZW5kcyB7SG9va0VtaXR0ZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcnNlciBleHRlbmRzIEhvb2tFbWl0dGVyIHtcblx0LyoqXG5cdCAqIEFuIG9iamVjdCBjb250YWluaW5nIGFsbCBvZiB0aGUgcGFyc2VkIG9wdGlvbnMsIGZsYWdzLCBhbmQgbmFtZWQgYXJndW1lbnRzLlxuXHQgKlxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKi9cblx0YXJndiA9IHt9O1xuXG5cdC8qKlxuXHQgKiBBIGxpc3Qgb2Ygb3B0aW9ucyBhbmQgYXJndW1lbnRzIGluIHdoaWNoIHRoZWlyIGNhbGxiYWNrcyB3ZXJlIGZpcmVkIGR1cmluZyBwYXJzaW5nIHNvIHRoYXRcblx0ICogd2UgZG9uJ3QgZmlyZSB0aGUgY2FsbGJhY2tzIGFnYWluIHdoZW4gc2V0dGluZyB0aGUgZGVmYXVsdCB2YWx1ZXMuXG5cdCAqIEB0eXBlIHtTZXR9XG5cdCAqL1xuXHRfZmlyZWQgPSBuZXcgU2V0KCk7XG5cblx0LyoqXG5cdCAqIEFuIG9iamVjdCBjb250YWluaW5nIG9ubHkgdW5rbm93biBwYXJzZWQgb3B0aW9ucyBhbmQgZmxhZ3MuXG5cdCAqXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqL1xuXHR1bmtub3duID0ge307XG5cblx0LyoqXG5cdCAqIEFuIGFycmF5IG9mIHBhcnNlZCBhcmd1bWVudHMuXG5cdCAqXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICovXG5cdF8gPSBbXTtcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIHByb3BlcnRpZXMgYW5kIGNsYXNzIG5hbWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBWYXJpb3VzIG9wdGlvbnMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5kYXRhXSAtIFVzZXItZGVmaW5lZCBkYXRhIHRvIHBhc3MgaW50byB0aGUgc2VsZWN0ZWQgY29tbWFuZC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMuZXhpdENvZGVdIC0gQSBmdW5jdGlvbiB0aGF0IHNldHMgdGhlIGV4aXQgY29kZS5cblx0ICogQHBhcmFtIHtUZXJtaWFubH0gW29wdHMudGVybWluYWxdIC0gQSB0ZXJtaW5hbCBpbnN0YW5jZSB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBDTEkgdGVybWluYWxcblx0ICogaW5zdGFuY2UuXG5cdCAqIEBhY2Nlc3MgcHVibGljXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgYXJyYXkgb2YgYXJndW1lbnRzLiBBcyBhcmd1bWVudHMgYXJlIGlkZW50aWZpZWQsIHRoZXkgYXJlIHJlcGxhY2VkIHdpdGhcblx0XHRcdCAqIGBQYXJzZWRBcmd1bWVudGAgaW5zdGFuY2VzIGFuZCBpbiB0aGUgY2FzZSBvZiBvcHRpb25zIHdpdGggdmFsdWVzIGFuZCBleHRyYSBvcHRpb25zLFxuXHRcdFx0ICogdGhlIGFycmF5IGlzIHNob3J0ZW5lZC5cblx0XHRcdCAqIEB0eXBlIHtBcnJheS48U3RyaW5nfFBhcnNlZEFyZ3VtZW50Pn1cblx0XHRcdCAqL1xuXHRcdFx0YXJnczoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbCxcblx0XHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQSBzdGFjayBvZiBjb250ZXh0cyBhcHBsaWVkIHRvIHRoZSBhcmd1bWVudHMuIFRoZSBmaXJzdCBlbGVtZW50IGlzIHRoZSBtb3N0IHNwZWNpZmljXG5cdFx0XHQgKiBjb250ZXh0LCB1c3VhbGx5IGEgY29tbWFuZC4gVGhlIGxhc3QgZWxlbWVudCBpcyB0eXBpY2FsbHkgdGhlIHJvb3QgYENMSWAgaW5zdGFuY2UuXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXkuPENvbnRleHQ+fVxuXHRcdFx0ICovXG5cdFx0XHRjb250ZXh0czoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbCxcblx0XHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQSBtYXAgb2Ygb3B0aW9uIGFuZCBhcmd1bWVudCBlbnZpcm9ubWVudCB2YXJpYWJsZSB2YWx1ZXMgZGVyaXZlZCBmcm9tIGFsbCBvcHRpb25zXG5cdFx0XHQgKiBhbmQgYXJndW1lbnRzIGZvdW5kIGFjcm9zcyBhbGwgY29udGV4dHMuXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICovXG5cdFx0XHRlbnY6IHtcblx0XHRcdFx0dmFsdWU6IG51bGwsXG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIE9wdGlvbnMgcG9zc2libHkgY29udGFpbmluZyBhIGBkYXRhYCBwYXlsb2FkLCBgZXhpdENvZGVgLCBhbmQgYHRlcm1pbmFsYCBpbnN0YW5jZS5cblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKi9cblx0XHRcdG9wdHM6IHtcblx0XHRcdFx0dmFsdWU6IG9wdHNcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQSBsaXN0IG9mIGFsbCByZXF1aXJlZCBhcmd1bWVudHMgYW5kIG9wdGlvbnMgdGhhdCB3ZXJlIG1pc3NpbmcuIFRoZSBjYWxsZXIgKGUuZy5cblx0XHRcdCAqIHRoZSBgQ0xJYCBpbnN0YW5jZSkgaXMgcmVzcG9uc2libGUgZm9yIGVuZm9yY2luZyBtaXNzaW5nIGFyZ3VtZW50cy5cblx0XHRcdCAqIEB0eXBlIHtTZXR9XG5cdFx0XHQgKi9cblx0XHRcdHJlcXVpcmVkOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0ZGVjbGFyZUNMSUtpdENsYXNzKHRoaXMsICdQYXJzZXInKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMb29wcyBvdmVyIHRoZSBjb250ZXh0cyBpbiByZXZlcnNlIGZyb20gdGhlIHRvcC1sZXZlbCB0byB0aGUgbW9zdCBzcGVjaWZpYyBjb250ZXh0IGFuZFxuXHQgKiBnYXRoZXJzIHRoZSBvcHRpb24gZGVmYXVsdHMgYXMgd2VsbCBhcyBhbnkgb3B0aW9ucyBzcGVjaWZpZWQgYXMgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZX1cblx0ICogQGFjY2VzcyBwcml2YXRlXG5cdCAqL1xuXHRhc3luYyBhcHBseURlZmF1bHRzKCkge1xuXHRcdGNvbnN0IHJlcXVpcmVkT3B0aW9ucyA9IHtcblx0XHRcdGxvbmc6IHt9LFxuXHRcdFx0c2hvcnQ6IHt9XG5cdFx0fTtcblx0XHRjb25zdCBsZW4gPSB0aGlzLmNvbnRleHRzLmxlbmd0aDtcblx0XHRsb2coYFByb2Nlc3NpbmcgZGVmYXVsdCBvcHRpb25zIGFuZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZm9yICR7aGlnaGxpZ2h0KGxlbil9ICR7cGx1cmFsaXplKCdjb250ZXh0JywgbGVuKX1gKTtcblxuXHRcdHRoaXMuZW52ID0ge307XG5cblx0XHQvLyBsb29wIHRocm91Z2ggZXZlcnkgY29udGV4dFxuXHRcdGZvciAobGV0IGkgPSBsZW47IGk7IGktLSkge1xuXHRcdFx0Y29uc3QgY3R4ID0gdGhpcy5jb250ZXh0c1tpIC0gMV07XG5cblx0XHRcdC8vIGluaXQgb3B0aW9uc1xuXHRcdFx0Zm9yIChjb25zdCBvcHRpb25zIG9mIGN0eC5vcHRpb25zLnZhbHVlcygpKSB7XG5cdFx0XHRcdGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcblx0XHRcdFx0XHRpZiAob3B0aW9uLm5hbWUpIHtcblx0XHRcdFx0XHRcdGNvbnN0IG5hbWUgPSBvcHRpb24uY2FtZWxDYXNlIHx8IGN0eC5nZXQoJ2NhbWVsQ2FzZScpID8gY2FtZWxDYXNlKG9wdGlvbi5uYW1lKSA6IG9wdGlvbi5uYW1lO1xuXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5hcmd2W25hbWVdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0bGV0IHZhbHVlID0gb3B0aW9uLmRlZmF1bHQ7XG5cblx0XHRcdFx0XHRcdFx0aWYgKG9wdGlvbi5kYXRhdHlwZSA9PT0gJ2Jvb2wnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSAhIW9wdGlvbi5uZWdhdGU7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAob3B0aW9uLnR5cGUgPT09ICdjb3VudCcpIHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IDA7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAob3B0aW9uLm11bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IFsgdmFsdWUgXSA6IFtdO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKCF0aGlzLl9maXJlZC5oYXMob3B0aW9uKSAmJiB0eXBlb2Ygb3B0aW9uLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgbmV3VmFsdWUgPSBhd2FpdCBvcHRpb24uY2FsbGJhY2soe1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3R4LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YTogdGhpcy5vcHRzLmRhdGEsXG5cdFx0XHRcdFx0XHRcdFx0XHRleGl0Q29kZTogdGhpcy5vcHRzLmV4aXRDb2RlLFxuXHRcdFx0XHRcdFx0XHRcdFx0aW5wdXQ6IFsgdmFsdWUgXSxcblx0XHRcdFx0XHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRhc3luYyBuZXh0KCkge30sXG5cdFx0XHRcdFx0XHRcdFx0XHRvcHRzOiB0aGlzLm9wdHMsXG5cdFx0XHRcdFx0XHRcdFx0XHRvcHRpb24sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJzZXI6IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IG5ld1ZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHRoaXMuYXJndltuYW1lXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAob3B0aW9uLmVudiAmJiBwcm9jZXNzLmVudltvcHRpb24uZW52XSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZW52W25hbWVdID0gb3B0aW9uLnRyYW5zZm9ybShwcm9jZXNzLmVudltvcHRpb24uZW52XSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKG9wdGlvbi5yZXF1aXJlZCkge1xuXHRcdFx0XHRcdFx0aWYgKG9wdGlvbi5sb25nKSB7XG5cdFx0XHRcdFx0XHRcdHJlcXVpcmVkT3B0aW9ucy5sb25nW29wdGlvbi5sb25nXSA9IG9wdGlvbjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChvcHRpb24uc2hvcnQpIHtcblx0XHRcdFx0XHRcdFx0cmVxdWlyZWRPcHRpb25zLnNob3J0W29wdGlvbi5zaG9ydF0gPSBvcHRpb247XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChvcHRpb24ubG9uZykge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgcmVxdWlyZWRPcHRpb25zLmxvbmdbb3B0aW9uLmxvbmddO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKG9wdGlvbi5zaG9ydCkge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgcmVxdWlyZWRPcHRpb25zLnNob3J0W29wdGlvbi5zaG9ydF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGluaXQgYXJndW1lbnRzXG5cdFx0XHRmb3IgKGNvbnN0IGFyZyBvZiBjdHguYXJncykge1xuXHRcdFx0XHRpZiAoYXJnLm5hbWUpIHtcblx0XHRcdFx0XHRjb25zdCBuYW1lID0gYXJnLmNhbWVsQ2FzZSB8fCBjdHguZ2V0KCdjYW1lbENhc2UnKSA/IGNhbWVsQ2FzZShhcmcubmFtZSkgOiBhcmcubmFtZTtcblxuXHRcdFx0XHRcdGlmICh0aGlzLmFyZ3ZbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0bGV0IHZhbHVlID0gYXJnLmRlZmF1bHQ7XG5cblx0XHRcdFx0XHRcdGlmIChhcmcubXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IFsgdmFsdWUgXSA6IFtdO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIXRoaXMuX2ZpcmVkLmhhcyhhcmcpICYmIHR5cGVvZiBhcmcuY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbmV3VmFsdWUgPSBhd2FpdCBhcmcuY2FsbGJhY2soe1xuXHRcdFx0XHRcdFx0XHRcdGFyZyxcblx0XHRcdFx0XHRcdFx0XHRjdHgsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YTogdGhpcy5vcHRzLmRhdGEsXG5cdFx0XHRcdFx0XHRcdFx0ZXhpdENvZGU6IHRoaXMub3B0cy5leGl0Q29kZSxcblx0XHRcdFx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdFx0XHRcdG9wdHM6IHRoaXMub3B0cyxcblx0XHRcdFx0XHRcdFx0XHRwYXJzZXI6IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWVcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGlmIChuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBuZXdWYWx1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0aGlzLmFyZ3ZbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoYXJnLmVudiAmJiBwcm9jZXNzLmVudlthcmcuZW52XSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmVudltuYW1lXSA9IGFyZy50cmFuc2Zvcm0ocHJvY2Vzcy5lbnZbYXJnLmVudl0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMucmVxdWlyZWQgPSBuZXcgU2V0KE9iamVjdC52YWx1ZXMocmVxdWlyZWRPcHRpb25zLmxvbmcpKTtcblx0XHRmb3IgKGNvbnN0IG9wdGlvbiBvZiBPYmplY3QudmFsdWVzKHJlcXVpcmVkT3B0aW9ucy5zaG9ydCkpIHtcblx0XHRcdHRoaXMucmVxdWlyZWQuYWRkKG9wdGlvbik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIExvb3BzIG92ZXIgdGhlIHBhcnNlZCBhcmd1bWVudHMgYW5kIHBvcHVsYXRlcyB0aGUgYGFyZ3ZgIGFuZCBgX2AgcHJvcGVydGllcy5cblx0ICpcblx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdCAqIEBhY2Nlc3MgcHJpdmF0ZVxuXHQgKi9cblx0YXN5bmMgZmlsbEFyZ3YoKSB7XG5cdFx0Ly8gZnJvbSBoZXJlLCB3ZSB3YW50IHRvIGRlYWwgd2l0aCB0aGUgbW9zdCBzcGVjaWZpYyBjb250ZXh0XG5cdFx0Y29uc3QgY3R4ID0gdGhpcy5jb250ZXh0c1swXTtcblxuXHRcdC8vIGxvb3Agb3ZlciB0aGUgcGFyc2VkIGFyZ3MgYW5kIGZpbGwgaW4gdGhlIGBhcmd2YCBhbmQgYF9gXG5cdFx0bG9nKCdGaWxsaW5nIGFyZ3YgYW5kIF8nKTtcblxuXHRcdC8vIGNvbWJpbmUgcGFyc2VkIGFyZ3MgdGhhdCBhcmUgb3B0aW9ucyB3aXRoIG11bHRpcGxlIGZsYWcgc2V0XG5cdFx0Zm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLmFyZ3MubGVuZ3RoOyBrKyspIHtcblx0XHRcdGxldCBjdXJyZW50ID0gdGhpcy5hcmdzW2tdO1xuXHRcdFx0aWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBQYXJzZWRBcmd1bWVudCAmJiBjdXJyZW50LnR5cGUgPT09ICdvcHRpb24nICYmIGN1cnJlbnQub3B0aW9uLm11bHRpcGxlKSB7XG5cdFx0XHRcdGZvciAobGV0IGogPSBrICsgMTsgaiA8IHRoaXMuYXJncy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGxldCBuZXh0ID0gdGhpcy5hcmdzW2pdO1xuXHRcdFx0XHRcdGlmIChuZXh0IGluc3RhbmNlb2YgUGFyc2VkQXJndW1lbnQgJiYgbmV4dC50eXBlID09PSAnb3B0aW9uJyAmJiBuZXh0Lm9wdGlvbiA9PT0gY3VycmVudC5vcHRpb24pIHtcblx0XHRcdFx0XHRcdGlmICghQXJyYXkuaXNBcnJheShjdXJyZW50LnZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50LnZhbHVlID0gWyBjdXJyZW50LnZhbHVlIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAobmV4dC52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQudmFsdWUgPSBbXS5jb25jYXQoY3VycmVudC52YWx1ZSwgbmV4dC52YWx1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLmFyZ3Muc3BsaWNlKGotLSwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IGluZGV4ID0gMDtcblx0XHRsZXQgZXh0cmEgPSBbXTtcblxuXHRcdGNvbnN0IHNldEFyZyA9IGFzeW5jIChpZHgsIHZhbHVlKSA9PiB7XG5cdFx0XHRjb25zdCBhcmcgPSBjdHguYXJnc1tpZHhdO1xuXG5cdFx0XHQvLyBleHRyYWN0IHRoZSBwYXJzZWQgYXJnIHZhbHVlXG5cdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBQYXJzZWRBcmd1bWVudCkge1xuXHRcdFx0XHR2YWx1ZS5hcmcgPSBhcmc7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUuaW5wdXRbMF07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChhcmcpIHtcblx0XHRcdFx0Y29uc3QgbmFtZSA9IGFyZy5jYW1lbENhc2UgfHwgY3R4LmdldCgnY2FtZWxDYXNlJykgPyBjYW1lbENhc2UoYXJnLm5hbWUpIDogYXJnLm5hbWU7XG5cdFx0XHRcdHZhbHVlID0gYXJnLnRyYW5zZm9ybSh2YWx1ZSk7XG5cblx0XHRcdFx0aWYgKHR5cGVvZiBhcmcuY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCBuZXdWYWx1ZSA9IGF3YWl0IGFyZy5jYWxsYmFjayh7XG5cdFx0XHRcdFx0XHRhcmcsXG5cdFx0XHRcdFx0XHRjdHgsXG5cdFx0XHRcdFx0XHRkYXRhOiB0aGlzLm9wdHMuZGF0YSxcblx0XHRcdFx0XHRcdGV4aXRDb2RlOiB0aGlzLm9wdHMuZXhpdENvZGUsXG5cdFx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdFx0b3B0czogdGhpcy5vcHRzLFxuXHRcdFx0XHRcdFx0cGFyc2VyOiB0aGlzLFxuXHRcdFx0XHRcdFx0dmFsdWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRpZiAobmV3VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBuZXdWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fZmlyZWQuYWRkKGFyZyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYXJnLm11bHRpcGxlKSB7XG5cdFx0XHRcdFx0Ly8gaWYgdGhpcyBhcmcgZ29iYmxlcyB1cCBtdWx0aXBsZSBwYXJzZWQgYXJncywgdGhlbiB3ZSBkZWNyZW1lbnQgYGlgIHNvXG5cdFx0XHRcdFx0Ly8gdGhhdCB3ZSBuZXZlciBpbmNyZW1lbnQgaXQgYW5kIG5vIGZ1cnRoZXIgYXJndW1lbnRzIHdpbGwgYmUgYXBwbGllZFxuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodGhpcy5hcmd2W25hbWVdKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5hcmd2W25hbWVdLnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLmFyZ3ZbbmFtZV0gPSBbIHZhbHVlIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuYXJndltuYW1lXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuXy5wdXNoKHZhbHVlKTtcblx0XHR9O1xuXG5cdFx0Ly8gbG9vcCBvdmVyIHRoZSBwYXJzZWQgYXJncyBhbmQgYXNzaWduIHRoZSB2YWx1ZXMgdG8gXyBhbmQgYXJndlxuXHRcdGZvciAoY29uc3QgcGFyc2VkQXJnIG9mIHRoaXMuYXJncykge1xuXHRcdFx0bGV0IG5hbWU7XG5cdFx0XHRjb25zdCBpc1BhcnNlZCA9IHBhcnNlZEFyZyBpbnN0YW5jZW9mIFBhcnNlZEFyZ3VtZW50O1xuXG5cdFx0XHRpZiAoIWlzUGFyc2VkIHx8IHBhcnNlZEFyZy50eXBlID09PSAnYXJndW1lbnQnKSB7XG5cdFx0XHRcdGF3YWl0IHNldEFyZyhpbmRleCsrLCBwYXJzZWRBcmcpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3dpdGNoIChwYXJzZWRBcmcudHlwZSkge1xuXHRcdFx0XHRjYXNlICdhcmd1bWVudCc6XG5cdFx0XHRcdFx0Ly8gYWxyZWFkeSBoYW5kbGVkIGFib3ZlXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZXh0cmEnOlxuXHRcdFx0XHRcdGV4dHJhID0gcGFyc2VkQXJnLmFyZ3M7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnb3B0aW9uJzpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCB7IG9wdGlvbiB9ID0gcGFyc2VkQXJnO1xuXHRcdFx0XHRcdFx0bmFtZSA9IG9wdGlvbi5jYW1lbENhc2UgfHwgY3R4LmdldCgnY2FtZWxDYXNlJykgPyBjYW1lbENhc2Uob3B0aW9uLm5hbWUpIDogb3B0aW9uLm5hbWU7XG5cblx0XHRcdFx0XHRcdGxldCB7IHZhbHVlIH0gPSBwYXJzZWRBcmc7XG5cdFx0XHRcdFx0XHRpZiAob3B0aW9uLnR5cGUgPT09ICdjb3VudCcpIHtcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSAodGhpcy5hcmd2W25hbWVdIHx8IDApICsgMTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gbm9uLW11bHRpcGxlIG9wdGlvbiBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gZmlyZWQsIG5vdyB3ZSBuZWVkXG5cdFx0XHRcdFx0XHQvLyB0byBkbyBpdCBqdXN0IGZvciBtdWx0aXBsZSB2YWx1ZSBvcHRpb25zXG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIG9wdGlvbi5jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb24ubXVsdGlwbGUpIHtcblx0XHRcdFx0XHRcdFx0bG9nKGBGaXJpbmcgb3B0aW9uICR7aGlnaGxpZ2h0KG9wdGlvbi5mb3JtYXQpfSBjYWxsYmFjayAke25vdGUoYCgke29wdGlvbi5wYXJlbnQubmFtZX0pYCl9YCk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG5ld1ZhbHVlID0gYXdhaXQgb3B0aW9uLmNhbGxiYWNrKHtcblx0XHRcdFx0XHRcdFx0XHRjdHgsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YTogdGhpcy5vcHRzLmRhdGEsXG5cdFx0XHRcdFx0XHRcdFx0ZXhpdENvZGU6IHRoaXMub3B0cy5leGl0Q29kZSxcblx0XHRcdFx0XHRcdFx0XHRpbnB1dDogWyB2YWx1ZSBdLFxuXHRcdFx0XHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0YXN5bmMgbmV4dCgpIHt9LFxuXHRcdFx0XHRcdFx0XHRcdG9wdHM6IHRoaXMub3B0cyxcblx0XHRcdFx0XHRcdFx0XHRvcHRpb24sXG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VyOiB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRpZiAobmV3VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gbmV3VmFsdWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGhpcy5fZmlyZWQuYWRkKG9wdGlvbik7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHNldCB0aGUgcGFyc2VkIHZhbHVlIChvdmVyd3JpdGVzIHRoZSBkZWZhdWx0IHZhbHVlKVxuXHRcdFx0XHRcdFx0XHR0aGlzLmFyZ3ZbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gYXJndltuYW1lXSBlaXRoZXIgaGFzIHRoZSBuZXcgdmFsdWUgb3IgdGhlIGRlZmF1bHQgdmFsdWUsIGJ1dCBlaXRoZXIgd2F5IHdlIG11c3QgcmUtY2hlY2sgaXRcblx0XHRcdFx0XHRcdGlmICh0aGlzLmFyZ3ZbbmFtZV0gIT09IHVuZGVmaW5lZCAmJiAoIW9wdGlvbi5tdWx0aXBsZSB8fCB0aGlzLmFyZ3ZbbmFtZV0ubGVuZ3RoKSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnJlcXVpcmVkLmRlbGV0ZShvcHRpb24pO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBpZiBhcmd2W25hbWVdIGhhcyBubyB2YWx1ZSBhbmQgbm8gZGVmYXVsdCwgYXQgbGVhc3Qgc2V0IGl0IHRvIGFuIGVtcHR5IHN0cmluZ1xuXHRcdFx0XHRcdFx0Ly8gbm90ZTogdGhpcyBtdXN0IGJlIGRvbmUgYWZ0ZXIgdGhlIHJlcXVpcmVkIGNoZWNrIGFib3ZlXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5hcmd2W25hbWVdID09PSB1bmRlZmluZWQgJiYgb3B0aW9uLmRhdGF0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmFyZ3ZbbmFtZV0gPSBvcHRpb24udHJhbnNmb3JtKCcnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndW5rbm93bic6XG5cdFx0XHRcdFx0Ly8gc2luY2UgdGhpcyBpcyBhbiB1bmtub3duIG9wdGlvbiwgd2UgdHJ5IHRvIGd1ZXNzIGl0J3MgdHlwZSBhbmQgaWYgaXQnc1xuXHRcdFx0XHRcdC8vIGEgYm9vbCwgd2Ugd2lsbCBob25vciB0aGUgbmVnYXRlIChlLmcuIC0tbm8tPG5hbWU+KVxuXHRcdFx0XHRcdGxldCB7IHZhbHVlIH0gPSBwYXJzZWRBcmc7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHRyYW5zZm9ybVZhbHVlKHZhbHVlKTtcblx0XHRcdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgJiYgcGFyc2VkQXJnLm5lZ2F0ZWQpIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gIXZhbHVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGNsZWFuIHVwIHRoZSBuYW1lXG5cdFx0XHRcdFx0bmFtZSA9IGN0eC5nZXQoJ2NhbWVsQ2FzZScpID8gY2FtZWxDYXNlKHBhcnNlZEFyZy5uYW1lKSA6IHBhcnNlZEFyZy5uYW1lO1xuXHRcdFx0XHRcdHRoaXMuYXJndltuYW1lXSA9IHRoaXMudW5rbm93bltuYW1lXSA9IHZhbHVlO1xuXG5cdFx0XHRcdFx0aWYgKGN0eC5nZXQoJ3RyZWF0VW5rbm93bk9wdGlvbnNBc0FyZ3VtZW50cycpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl8ucHVzaChwYXJzZWRBcmcuaW5wdXRbMF0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBhZGQgdGhlIGV4dHJhIGl0ZW1zXG5cdFx0dGhpcy5fLnB1c2guYXBwbHkodGhpcy5fLCBleHRyYSk7XG5cblx0XHQvLyBwcm9jZXNzIGVudiB2YXJzXG5cdFx0bG9nKCdNaXhpbmcgaW4gZW52aXJvbm1lbnQgdmFyaWFibGUgdmFsdWVzJyk7XG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLmFyZ3YsIHRoaXMuZW52KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgdGhlIGNvbW1hbmQgbGluZSBhcmd1bWVudHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVmFyaW91cyBvcHRpb25zLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBvcHRzLmFyZ3MgLSBBbiBhcnJheSBvZiByYXcsIHVucGFyc2VkIGFyZ3VtZW50cy5cblx0ICogQHBhcmFtIHtDb250ZXh0fSBvcHRzLmN0eCAtIFRoZSBjb250ZXh0IHRvIHJlZmVyZW5jZSBmb3IgY29tbWFuZHMsIG9wdGlvbnMsIGFuZCBhcmd1bWVudHMuXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPFBhcnNlcj59XG5cdCAqIEBhY2Nlc3MgcHVibGljXG5cdCAqL1xuXHRhc3luYyBwYXJzZShvcHRzKSB7XG5cdFx0Y29uc3QgZm4gPSB0aGlzLmhvb2soJ3BhcnNlJywgYXN5bmMgKHsgYXJncywgY3R4IH0pID0+IHtcblx0XHRcdGlmICghQXJyYXkuaXNBcnJheShhcmdzKSkge1xuXHRcdFx0XHR0aHJvdyBFLklOVkFMSURfQVJHVU1FTlQoJ0V4cGVjdGVkIGFyZ3MgdG8gYmUgYW4gYXJyYXknLCB7IG5hbWU6ICdhcmdzJywgc2NvcGU6ICdQYXJzZXIucGFyc2UnLCB2YWx1ZTogYXJncyB9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCEoY3R4IGluc3RhbmNlb2YgQ29udGV4dCkpIHtcblx0XHRcdFx0dGhyb3cgRS5JTlZBTElEX0FSR1VNRU5UKCdFeHBlY3RlZCBjdHggdG8gYmUgYSBjb250ZXh0JywgeyBuYW1lOiAnY3R4Jywgc2NvcGU6ICdQYXJzZXIucGFyc2UnLCB2YWx1ZTogY3R4IH0pO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmFyZ3MgPSBhcmdzO1xuXHRcdFx0dGhpcy5jb250ZXh0cyA9IFsgY3R4IF07XG5cblx0XHRcdGxvZyhgUHJvY2Vzc2luZyAke3BsdXJhbGl6ZSgnYXJndW1lbnQnLCBhcmdzLmxlbmd0aCwgdHJ1ZSl9OiAke2hpZ2hsaWdodCh0aGlzLmFyZ3Muam9pbignLCAnKSl9YCk7XG5cblx0XHRcdC8vIHByb2Nlc3MgdGhlIGFyZ3VtZW50cyBhZ2FpbnN0IHRoZSBjb250ZXh0XG5cdFx0XHRhd2FpdCB0aGlzLnBhcnNlV2l0aENvbnRleHQoY3R4KTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSk7XG5cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGF3YWl0IGZuKHtcblx0XHRcdFx0Li4ub3B0cyxcblx0XHRcdFx0ZGF0YTogdGhpcy5vcHRzLmRhdGEsXG5cdFx0XHRcdHBhcnNlcjogdGhpc1xuXHRcdFx0fSk7XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRlcnIuY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuXHRcdFx0dGhyb3cgZXJyO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBQcm9jZXNzZXMgdGhlIGFyZ3VtZW50cyBhZ2FpbnN0IHRoZSBnaXZlbiBjb250ZXh0LiBJZiBhIGNvbW1hbmQgaXMgZm91bmQsIGl0IHJlY3Vyc2l2ZWx5XG5cdCAqIGNhbGxzIGl0c2VsZi5cblx0ICpcblx0ICogQHBhcmFtIHtDTEl8Q29tbWFuZH0gY3R4IC0gVGhlIGNvbnRleHQgdG8gYXBwbHkgd2hlbiBwYXJzaW5nIHRoZSBjb21tYW5kIGxpbmUgYXJndW1lbnRzLlxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZX1cblx0ICogQGFjY2VzcyBwcml2YXRlXG5cdCAqL1xuXHRhc3luYyBwYXJzZVdpdGhDb250ZXh0KGN0eCkge1xuXHRcdC8vIHByaW50IHRoZSBjb250ZXh0J3MgaW5mb1xuXHRcdGxvZyhgQ29udGV4dDogJHtoaWdobGlnaHQoY3R4Lm5hbWUpfWApO1xuXHRcdGlmICghY3R4Lmxvb2t1cC5lbXB0eSkge1xuXHRcdFx0bG9nKGN0eC5sb29rdXAudG9TdHJpbmcoKSk7XG5cdFx0fVxuXG5cdFx0YXdhaXQgdGhpcy5wYXJzZUFyZyhjdHgsIDApO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlcyBhIHNpbmdsZSBhcmd1bWVudCBhcyBhcGFydCBvZiBhIGNoYWluIG9mIHByb21pc2VzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0NMSXxDb21tYW5kfSBjdHggLSBUaGUgY29udGV4dCB0byBhcHBseSB3aGVuIHBhcnNpbmcgdGhlIGNvbW1hbmQgbGluZSBhcmd1bWVudHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpIC0gVGhlIGFyZ3VtZW50IGluZGV4IG51bWJlciB0byBwYXJzZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0b10gLSBUaGUgaW5kZXggdG8gZ28gdW50aWwuXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHQgKiBAYWNjZXNzIHByaXZhdGVcblx0ICovXG5cdGFzeW5jIHBhcnNlQXJnKGN0eCwgaSwgdG8pIHtcblx0XHRpZiAodG8gIT09IHVuZGVmaW5lZCAmJiBpID49IHRvKSB7XG5cdFx0XHQvLyBhbGwgY2F1Z2h0IHVwLCByZXR1cm5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgeyByZXYgfSA9IGN0eDtcblx0XHRsZXQgeyBsZW5ndGggfSA9IHRoaXMuYXJncztcblx0XHRjb25zdCBjaGVja1JldiA9IGFzeW5jIChjdHgsIHRvKSA9PiB7XG5cdFx0XHRpZiAoY3R4LnJldiA+IHJldikge1xuXHRcdFx0XHQvLyB3ZSBhbHdheXMgbmVlZCBhIGB0b2Bcblx0XHRcdFx0aWYgKHRvID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0byA9IHRoaXMuYXJncy5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0bG9nKGBSZXYgY2hhbmdlZCBmcm9tICR7aGlnaGxpZ2h0KHJldil9IHRvICR7aGlnaGxpZ2h0KGN0eC5yZXYpfSwgcmVwYXJzaW5nICR7aGlnaGxpZ2h0KDApfSB0aHJvdWdoICR7aGlnaGxpZ2h0KHRvKX1gKTtcblx0XHRcdFx0cmV2ID0gY3R4LnJldjtcblx0XHRcdFx0YXdhaXQgdGhpcy5wYXJzZUFyZyhjdHgsIDAsIHRvKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0aWYgKHRvID09PSB1bmRlZmluZWQgJiYgaSA+PSBsZW5ndGgpIHtcblx0XHRcdGxldCBjbWQgPSB0aGlzLmNvbnRleHRzWzBdO1xuXG5cdFx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjb250ZXh0cyB0byBkZXNjZW5kLCBjaGVjayBpZiB0aGUgdG9wLW1vc3QgY29udGV4dCBpcyBhY3R1YWxseVxuXHRcdFx0Ly8gYSBkZWZhdWx0IHN1YmNvbW1hbmRcblx0XHRcdGlmIChjbWQgPT09IGN0eCAmJiBjbWQuYWN0aW9uIGluc3RhbmNlb2YgQ29tbWFuZCkge1xuXHRcdFx0XHRjbWQgPSBjbWQuYWN0aW9uO1xuXHRcdFx0XHRjbWQubGluayhjdHgpO1xuXHRcdFx0XHR0aGlzLmNvbnRleHRzLnVuc2hpZnQoY21kKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNtZCAhPT0gY3R4KSB7XG5cdFx0XHRcdGxvZygnRGVzY2VuZGluZyBpbnRvIG5leHQgY29udGV4dFxcJ3MgcGFyc2VyJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnBhcnNlV2l0aENvbnRleHQoY21kKTtcblx0XHRcdH1cblxuXHRcdFx0YXdhaXQgdGhpcy5ob29rKCdmaW5hbGl6ZScsIGFzeW5jICgpID0+IHtcblx0XHRcdFx0YXdhaXQgY2hlY2tSZXYoY3R4KTsgLy8gY2hlY2sgaWYgcHJlLWZpbmFsaXplIGNoYW5nZWQgdGhlIHJldlxuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcGx5RGVmYXVsdHMoKTtcblx0XHRcdFx0YXdhaXQgY2hlY2tSZXYoY3R4KTsgLy8gY2hlY2sgaWYgYXBwbHlEZWZhdWx0cyBjaGFuZ2VkIHRoZSByZXZcblx0XHRcdFx0YXdhaXQgdGhpcy5maWxsQXJndigpO1xuXHRcdFx0fSkoeyBjdHgsIGRhdGE6IHRoaXMub3B0cy5kYXRhLCBwYXJzZXI6IHRoaXMgfSk7XG5cdFx0XHRhd2FpdCBjaGVja1JldihjdHgpOyAvLyBjaGVjayBpZiBwb3N0LWZpbmFsaXplIG9yIGZpbGxBcmd2IGNoYW5nZWQgdGhlIHJldlxuXG5cdFx0XHRsb2coJ0VuZCBvZiB0aGUgbGluZScpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGNyZWF0ZSBhIFBhcnNlZEFyZ3VtZW50IG9iamVjdCBmb3IgdGhlIG5leHQgYXJndW1lbnRcblx0XHRjb25zdCBhcmcgPSBhd2FpdCB0aGlzLmNyZWF0ZVBhcnNlZEFyZ3VtZW50KGN0eCwgaSk7XG5cblx0XHQvLyBpZiB0aGUgbGVuZ3RoIHdhcyBzaG9ydGVuZWQsIHRoZW4gZGVjcmVtZW50IGB0b2Bcblx0XHRpZiAodG8gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmFyZ3MubGVuZ3RoIDwgbGVuZ3RoKSB7XG5cdFx0XHR0byAtPSAobGVuZ3RoIC0gdGhpcy5hcmdzLmxlbmd0aCk7XG5cdFx0XHRsb2coYEFyZ3VtZW50IGxpc3Qgd2FzIHNob3J0ZW5lZCBmcm9tICR7bGVuZ3RofSB0byAke3RoaXMuYXJncy5sZW5ndGh9ICh0bz0ke3RvfSlgKTtcblx0XHR9XG5cblx0XHRpZiAoYXJnKSB7XG5cdFx0XHRjb25zdCB7IHR5cGUgfSA9IGFyZztcblxuXHRcdFx0Ly8gY2hlY2sgaWYgdGhlIGNvbnRleHQgY2hhbmdlZCAoZS5nLiB3ZSBmb3VuZCBhIGNvbW1hbmQvZXh0ZW5zaW9uKSBzbyB0aGF0IHdlIGNvbnRpbnVlXG5cdFx0XHQvLyB0byBwcm9jZXNzIGFyZ3VtZW50cyBhZ2FpbnN0IHRoZSBjdXJyZW50IGNvbnRleHQgYmVmb3JlIHdlIGRlc2NlbmQgaW50byB0aGUgbmV3bHlcblx0XHRcdC8vIGRpc2NvdmVyZWQgY29tbWFuZC9leHRlbnNpb24gY29udGV4dFxuXHRcdFx0Y29uc3Qgc2FtZUNvbnRleHQgPSB0aGlzLmNvbnRleHRzWzBdID09PSBjdHg7XG5cblx0XHRcdGlmICgodHlwZSAhPT0gJ2NvbW1hbmQnICYmIHR5cGUgIT09ICdleHRlbnNpb24nKSB8fCBzYW1lQ29udGV4dCkge1xuXHRcdFx0XHR0aGlzLmFyZ3NbaV0gPSBhcmc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICgodHlwZSA9PT0gJ2NvbW1hbmQnIHx8IHR5cGUgPT09ICdleHRlbnNpb24nKSAmJiBzYW1lQ29udGV4dCkge1xuXHRcdFx0XHQvLyBsaW5rIHRoZSBjb250ZXh0IGhvb2sgZW1pdHRlcnNcblx0XHRcdFx0Y29uc3QgY21kID0gYXJnLmNvbW1hbmQ7XG5cdFx0XHRcdGNtZC5saW5rKGN0eCk7XG5cdFx0XHRcdGlmICh0eXBlb2YgY21kLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0YXdhaXQgY21kLmNhbGxiYWNrKHtcblx0XHRcdFx0XHRcdGNvbW1hbmQ6IGFyZy5jb21tYW5kLFxuXHRcdFx0XHRcdFx0ZGF0YTogdGhpcy5vcHRzLmRhdGEsXG5cdFx0XHRcdFx0XHRwYXJzZXI6IHRoaXNcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFkZCB0aGUgY29udGV4dCB0byB0aGUgc3RhY2tcblx0XHRcdFx0dGhpcy5jb250ZXh0cy51bnNoaWZ0KGNtZCk7XG5cblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ29wdGlvbicgJiYgIXNhbWVDb250ZXh0ICYmIHRoaXMuY29udGV4dHNbMF0gaW5zdGFuY2VvZiBFeHRlbnNpb24gJiYgIXRoaXMuY29udGV4dHNbMF0uaXNDTElLaXRFeHRlbnNpb24pIHtcblx0XHRcdFx0bG9nKGBGb3JjaW5nIG9wdGlvbiAke2hpZ2hsaWdodChhcmcub3B0aW9uLmZvcm1hdCl9IHRvIGJlIGFuIGFyZ3VtZW50IGJlY2F1c2Ugd2UgZm91bmQgYSBub24tY2xpLWtpdCBleHRlbnNpb24gJHtoaWdobGlnaHQodGhpcy5jb250ZXh0c1swXS5uYW1lKX1gKTtcblx0XHRcdFx0dGhpcy5hcmdzW2ldID0gbmV3IFBhcnNlZEFyZ3VtZW50KCdhcmd1bWVudCcsIHtcblx0XHRcdFx0XHRpbnB1dDogYXJnLmlucHV0XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdvcHRpb24nICYmIHR5cGVvZiBhcmcub3B0aW9uLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nICYmICFhcmcub3B0aW9uLm11bHRpcGxlKSB7XG5cdFx0XHRcdGNvbnN0IHsgb3B0aW9uIH0gPSBhcmc7XG5cdFx0XHRcdGxvZyhgRmlyaW5nIG9wdGlvbiAke2hpZ2hsaWdodChvcHRpb24uZm9ybWF0KX0gY2FsbGJhY2sgJHtub3RlKGAoJHtvcHRpb24ucGFyZW50Lm5hbWV9KWApfWApO1xuXHRcdFx0XHRsZXQgZmlyZWQgPSBmYWxzZTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gYXdhaXQgb3B0aW9uLmNhbGxiYWNrKHtcblx0XHRcdFx0XHRcdGN0eCxcblx0XHRcdFx0XHRcdGRhdGE6IHRoaXMub3B0cy5kYXRhLFxuXHRcdFx0XHRcdFx0ZXhpdENvZGU6IHRoaXMub3B0cy5leGl0Q29kZSxcblx0XHRcdFx0XHRcdGlucHV0OiBhcmcuaW5wdXQsXG5cdFx0XHRcdFx0XHRuYW1lOiBvcHRpb24uY2FtZWxDYXNlIHx8IGN0eC5nZXQoJ2NhbWVsQ2FzZScpID8gY2FtZWxDYXNlKG9wdGlvbi5uYW1lKSA6IG9wdGlvbi5uYW1lLFxuXHRcdFx0XHRcdFx0bmV4dDogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRpZiAoZmlyZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRsb2coJ25leHQoKSBhbHJlYWR5IGZpcmVkJyk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0ZmlyZWQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdGxvZyhgT3B0aW9uICR7aGlnaGxpZ2h0KG9wdGlvbi5mb3JtYXQpfSBjYWxsZWQgbmV4dCgpLCBwcm9jZXNzaW5nIG5leHQgYXJnYCk7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IGNoZWNrUmV2KGN0eCwgaSk7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGFyc2VBcmcoY3R4LCBpICsgMSwgdG8pO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hcmdzW2ldLnZhbHVlO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG9wdHM6IHRoaXMub3B0cyxcblx0XHRcdFx0XHRcdG9wdGlvbixcblx0XHRcdFx0XHRcdHBhcnNlcjogdGhpcyxcblx0XHRcdFx0XHRcdHZhbHVlOiBhcmcudmFsdWVcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRsb2coYE9wdGlvbiAke2hpZ2hsaWdodChvcHRpb24uZm9ybWF0KX0gY2FsbGJhY2sgZGlkIG5vdCBjaGFuZ2UgdGhlIHZhbHVlYCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxvZyhgT3B0aW9uICR7aGlnaGxpZ2h0KG9wdGlvbi5mb3JtYXQpfSBjYWxsYmFjayBjaGFuZ2VkIHZhbHVlICR7aGlnaGxpZ2h0KGFyZy52YWx1ZSl9IHRvICR7aGlnaGxpZ2h0KHZhbHVlKX1gKTtcblx0XHRcdFx0XHRcdGFyZy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuX2ZpcmVkLmFkZChvcHRpb24pO1xuXG5cdFx0XHRcdFx0aWYgKGZpcmVkKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bG9nKGBPcHRpb24gJHtoaWdobGlnaHQob3B0aW9uLmZvcm1hdCl9IGRpZCBub3QgY2FsbCBuZXh0KCksIHByb2Nlc3NpbmcgbmV4dCBhcmdgKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0aWYgKGVyci5jb2RlICE9PSAnRVJSX05PVF9BTl9PUFRJT04nKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlcnI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5hcmdzW2ldID0gbmV3IFBhcnNlZEFyZ3VtZW50KCdhcmd1bWVudCcsIHtcblx0XHRcdFx0XHRcdGlucHV0OiBhcmcuaW5wdXRcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGF3YWl0IGNoZWNrUmV2KGN0eCwgaSk7XG5cdFx0YXdhaXQgdGhpcy5wYXJzZUFyZyhjdHgsIGkgKyAxLCB0byk7XG5cdH1cblxuXHQvKipcblx0ICogRGV0ZWN0cyB3aGF0IHRoZSBhcmd1bWVudCBpcyBhbmQgcmV0dXJucyBhbiBvYmplY3QgdGhhdCBpZGVudGlmaWVzIHdoYXQgd2FzIGZvdW5kLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0NMSXxDb21tYW5kfSBjdHggLSBUaGUgY29udGV4dCB0byBhcHBseSB3aGVuIHBhcnNpbmcgdGhlIGNvbW1hbmQgbGluZSBhcmd1bWVudHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpIC0gVGhlIGFyZ3VtZW50IGluZGV4IG51bWJlciB0byBwYXJzZS5cblx0ICogQHJldHVybnMge1Byb21pc2U8P1BhcnNlZEFyZ3VtZW50Pn0gUmVzb2x2ZXMgYSBgUGFyc2VkQXJndW1lbnRgIG9yIGB1bmRlZmluZWRgIGlmIHRoZVxuXHQgKiBhcmd1bWVudCB3YXMgYWxyZWFkeSBhIGBQYXJzZWRBcmd1bWVudGAgYW5kIGRpZG4ndCBjaGFuZ2UuXG5cdCAqIEBhY2Nlc3MgcHJpdmF0ZVxuXHQgKi9cblx0YXN5bmMgY3JlYXRlUGFyc2VkQXJndW1lbnQoY3R4LCBpKSB7XG5cdFx0Y29uc3QgeyBhcmdzIH0gPSB0aGlzO1xuXHRcdGlmIChpID49IGFyZ3MubGVuZ3RoKSB7XG5cdFx0XHR0aHJvdyBFLlJBTkdFX0VSUk9SKGBFeHBlY3RlZCBhcmd1bWVudCBpbmRleCB0byBiZSBiZXR3ZWVuIDAgYW5kICR7YXJncy5sZW5ndGh9YCwgeyBuYW1lOiAnaW5kZXgnLCBzY29wZTogJ1BhcnNlci5jcmVhdGVQYXJzZWRBcmd1bWVudCcsIHZhbHVlOiBpLCByYW5nZTogWyAwLCBhcmdzLmxlbmd0aCAtIDEgXSB9KTtcblx0XHR9XG5cblx0XHRjb25zdCBhcmcgPSBhcmdzW2ldO1xuXHRcdGNvbnN0IGlzUGFyc2VkID0gYXJnIGluc3RhbmNlb2YgUGFyc2VkQXJndW1lbnQ7XG5cdFx0Y29uc3QgdHlwZSA9IGlzUGFyc2VkICYmIGFyZy50eXBlO1xuXG5cdFx0bG9nKGBQcm9jZXNzaW5nIGFyZ3VtZW50IFske2l9XTogJHtoaWdobGlnaHQoYXJnKX1gKTtcblxuXHRcdC8vIGNoZWNrIGlmIHRoZSBhcmd1bWVudCBpcyBhIHRoZSBgLS1gIGV4dHJhIGFyZ3VtZW50cyBzZXF1ZW5jZVxuXHRcdGlmIChhcmcgPT09ICctLScpIHtcblx0XHRcdGNvbnN0IGV4dHJhID0gYXJncy5zcGxpY2UoaSArIDEsIGFyZ3MubGVuZ3RoKTtcblx0XHRcdHJldHVybiBuZXcgUGFyc2VkQXJndW1lbnQoJ2V4dHJhJywge1xuXHRcdFx0XHRhcmdzOiBleHRyYSxcblx0XHRcdFx0aW5wdXQ6IFsgYXJnLCAuLi5leHRyYSBdXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAodHlwZSA9PT0gJ2V4dHJhJykge1xuXHRcdFx0bG9nKCdTa2lwcGluZyBleHRyYSBhcmd1bWVudHMnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCB7IGxvb2t1cCB9ID0gY3R4O1xuXHRcdGxldCBzdWJqZWN0ID0gaXNQYXJzZWQgPyAoYXJnLmlucHV0ID8gYXJnLmlucHV0WzBdIDogbnVsbCkgOiBhcmc7XG5cblx0XHQvLyBjaGVjayBpZiB0aGUgYXJndW1lbnQgaXMgYW4gb3B0aW9uXG5cdFx0aWYgKCF0eXBlIHx8IHR5cGUgPT09ICdvcHRpb24nIHx8IHR5cGUgPT09ICd1bmtub3duJykge1xuXHRcdFx0bGV0IG0gPSBzdWJqZWN0Lm1hdGNoKG9wdFJFKTtcblx0XHRcdGxldCBuZWdhdGVkID0gZmFsc2U7XG5cdFx0XHRsZXQgb3B0aW9uO1xuXG5cdFx0XHRpZiAobSkge1xuXHRcdFx0XHQvLyAtLXNvbWV0aGluZyBvciAtLXNvbWV0aGluZz1mb29cblx0XHRcdFx0bmVnYXRlZCA9IG1bMV0ubWF0Y2gobmVnYXRlUmVnRXhwKTtcblx0XHRcdFx0Y29uc3QgbmFtZSA9IG5lZ2F0ZWQgPyBuZWdhdGVkWzFdIDogbVsxXTtcblx0XHRcdFx0b3B0aW9uID0gbG9va3VwLmxvbmdbbmFtZV0gfHwgbnVsbDtcblxuXHRcdFx0Ly8gY2hlY2sgaWYgc2hvcnQgb3B0aW9uXG5cdFx0XHR9IGVsc2UgaWYgKG0gPSBzdWJqZWN0Lm1hdGNoKGRhc2hPcHQpKSB7XG5cdFx0XHRcdGlmIChtWzFdLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRsb2coYFNwbGl0dGluZyBncm91cDogJHtoaWdobGlnaHQobVsxXSl9YCk7XG5cdFx0XHRcdFx0Y29uc3QgbmV3QXJncyA9IG1bMV0uc3BsaXQoJycpLm1hcCgoYXJnLCBpLCBhcnIpID0+IGkgKyAxID09PSBhcnIubGVuZ3RoICYmIG1bMl0gPyBgLSR7YXJnfT0ke21bMl19YCA6IGAtJHthcmd9YCk7XG5cdFx0XHRcdFx0c3ViamVjdCA9IG5ld0FyZ3Muc2hpZnQoKTtcblx0XHRcdFx0XHRsb2coYEluc2VydGluZyBhcmd1bWVudHM6ICR7bmV3QXJncy5qb2luKCcsICcpfWApO1xuXHRcdFx0XHRcdHRoaXMuYXJncy5zcGxpY2UoaSArIDEsIDAsIC4uLm5ld0FyZ3MpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0b3B0aW9uID0gbG9va3VwLnNob3J0W21bMV1bMF1dIHx8IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghb3B0aW9uICYmIHR5cGUpIHtcblx0XHRcdFx0Ly8gbm90IGFuIG9wdGlvbiBpbiB0aGlzIGNvbnRleHQsIGxlYXZlIGl0IGFsb25lXG5cdFx0XHRcdGxvZyhgU2tpcHBpbmcgJHt0eXBlID09PSAndW5rbm93bicgPyAndW4nIDogJyd9a25vd24gb3B0aW9uOiAke2hpZ2hsaWdodChhcmcuZ2V0TmFtZSgpKX1gKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0aW9uKSB7XG5cdFx0XHRcdGxvZyhgJHt0eXBlID09PSAnb3B0aW9uJyA/ICdPdmVycmlkaW5nJyA6ICdGb3VuZCd9IG9wdGlvbjogJHtoaWdobGlnaHQob3B0aW9uLm5hbWUpfSAke25vdGUoYCgke29wdGlvbi5kYXRhdHlwZX0pYCl9IE5lZ2F0ZWQ/ICR7aGlnaGxpZ2h0KCEhbmVnYXRlZCl9YCk7XG5cblx0XHRcdFx0bGV0IGlucHV0ID0gWyBzdWJqZWN0IF07XG5cdFx0XHRcdGxldCB2YWx1ZTtcblxuXHRcdFx0XHRpZiAob3B0aW9uLmlzRmxhZykge1xuXHRcdFx0XHRcdHZhbHVlID0gb3B0aW9uLnRyYW5zZm9ybSh0eXBlICYmIGFyZy52YWx1ZSAhPT0gdW5kZWZpbmVkID8gYXJnLnZhbHVlIDogdHJ1ZSwgbmVnYXRlZCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ29wdGlvbicpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IG9wdGlvbi50cmFuc2Zvcm0oYXJnc1tpXS52YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAobVsyXSkge1xuXHRcdFx0XHRcdHZhbHVlID0gb3B0aW9uLnRyYW5zZm9ybShtWzJdLCBuZWdhdGVkKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpICsgMSA8IGFyZ3MubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y29uc3QgbmV4dEFyZyA9IGFyZ3NbaSArIDFdO1xuXHRcdFx0XHRcdGlmIChuZXh0QXJnIGluc3RhbmNlb2YgUGFyc2VkQXJndW1lbnQpIHtcblx0XHRcdFx0XHRcdGlmIChuZXh0QXJnLnR5cGUgPT09ICdhcmd1bWVudCcpIHtcblx0XHRcdFx0XHRcdFx0aW5wdXQucHVzaCguLi5uZXh0QXJnLmlucHV0KTtcblx0XHRcdFx0XHRcdFx0YXJncy5zcGxpY2UoaSArIDEsIDEpO1xuXHRcdFx0XHRcdFx0XHQvLyBtYXliZSB0aGUgdW5rbm93biBvcHRpb24gaXMgYWN0dWFsbHkgYSB2YWx1ZSB0aGF0IGp1c3Rcblx0XHRcdFx0XHRcdFx0Ly8gaGFwcGVucyB0byBtYXRjaCB0aGUgcGF0dGVybiBmb3IgYW4gb3B0aW9uP1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IG9wdGlvbi50cmFuc2Zvcm0obmV4dEFyZy5pbnB1dFswXSwgbmVnYXRlZCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBuZXh0IGFyZyBoYXMgYWxyZWFkeSBiZWVuIGlkZW50aWZpZWQsIHNvIHRyZWF0IHRoaXMgb3B0aW9uIGFzIGEgZmxhZ1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlucHV0LnB1c2gobmV4dEFyZyk7XG5cdFx0XHRcdFx0XHRhcmdzLnNwbGljZShpICsgMSwgMSk7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IG9wdGlvbi50cmFuc2Zvcm0obmV4dEFyZywgbmVnYXRlZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRpZiAodHlwZSAmJiBhcmcudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBvcHRpb24udHJhbnNmb3JtKGFyZy52YWx1ZSwgbmVnYXRlZCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChvcHRpb24udHlwZSA9PT0gJ2Jvb2wnKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IG9wdGlvbi50cmFuc2Zvcm0odHJ1ZSwgbmVnYXRlZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBQYXJzZWRBcmd1bWVudCgnb3B0aW9uJywge1xuXHRcdFx0XHRcdGlucHV0LFxuXHRcdFx0XHRcdG9wdGlvbixcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgb3B0aW9uLm11bHRpcGxlID8gWyB2YWx1ZSBdIDogdmFsdWVcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIHRoZSBhcmd1bWVudCBtYXRjaGVkIGFuIG9wdGlvbiBwYXR0ZXJuLCBidXQgZGlkbid0IG1hdGNoIGEgZGVmaW5lZCBvcHRpb24sIHRoZW4gd2Vcblx0XHRcdC8vIGNhbiBhZGQgaXQgYXMgYW4gdW5rbm93biBvcHRpb24gd2hpY2ggd2lsbCBldmVudHVhbGx5IGJlY29tZSBhIGZsYWdcblx0XHRcdGlmIChvcHRpb24gPT09IG51bGwgJiYgIXR5cGUpIHtcblx0XHRcdFx0bG9nKGBGb3VuZCB1bmtub3duIG9wdGlvbjogJHtoaWdobGlnaHQoc3ViamVjdCl9YCk7XG5cdFx0XHRcdHJldHVybiBuZXcgUGFyc2VkQXJndW1lbnQoJ3Vua25vd24nLCB7XG5cdFx0XHRcdFx0aW5wdXQ6IFsgc3ViamVjdCBdLFxuXHRcdFx0XHRcdG5hbWU6IG5lZ2F0ZWQgPyBuZWdhdGVkWzFdIDogbVsxXSxcblx0XHRcdFx0XHRuZWdhdGVkLFxuXHRcdFx0XHRcdHZhbHVlOiBtWzJdID09PSB1bmRlZmluZWQgJiYgaXNQYXJzZWQgPyBhcmcudmFsdWUgOiBtWzJdXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGNoZWNrIGlmIHRoZSBhcmd1bWVudCBpcyBhIGNvbW1hbmRcblx0XHRpZiAodHlwZSA9PT0gJ2NvbW1hbmQnIHx8IHR5cGUgPT09ICdleHRlbnNpb24nKSB7XG5cdFx0XHRsb2coYFNraXBwaW5nIGtub3duICR7dHlwZX06ICR7aGlnaGxpZ2h0KGFyZy5jb21tYW5kLm5hbWUpfWApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGNoZWNrIGlmIGNvbW1hbmQgYW5kIG1ha2Ugc3VyZSB3ZSBoYXZlbid0IGFscmVhZHkgYWRkZWQgYSBjb21tYW5kIHRoaXMgcm91bmRcblx0XHRjb25zdCBjbWQgPSBsb29rdXAuY29tbWFuZHNbc3ViamVjdF07XG5cdFx0aWYgKGNtZCkge1xuXHRcdFx0bG9nKGBGb3VuZCBjb21tYW5kOiAke2hpZ2hsaWdodChjbWQubmFtZSl9YCk7XG5cdFx0XHRyZXR1cm4gbmV3IFBhcnNlZEFyZ3VtZW50KCdjb21tYW5kJywge1xuXHRcdFx0XHRjb21tYW5kOiBjbWQsXG5cdFx0XHRcdGlucHV0OiBpc1BhcnNlZCA/IGFyZy5pbnB1dCA6IFsgYXJnIF1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGNvbnN0IGV4dCA9IGxvb2t1cC5leHRlbnNpb25zW3N1YmplY3RdO1xuXHRcdGlmIChleHQpIHtcblx0XHRcdGxvZyhgRm91bmQgZXh0ZW5zaW9uOiAke2hpZ2hsaWdodChleHQubmFtZSl9YCk7XG5cdFx0XHRpZiAodHlwZW9mIGV4dC5sb2FkID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGF3YWl0IGV4dC5sb2FkKHN1YmplY3QpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ldyBQYXJzZWRBcmd1bWVudCgnZXh0ZW5zaW9uJywge1xuXHRcdFx0XHRjb21tYW5kOiBleHQsXG5cdFx0XHRcdGlucHV0OiBpc1BhcnNlZCA/IGFyZy5pbnB1dCA6IFsgYXJnIF1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICghdHlwZSkge1xuXHRcdFx0bG9nKGBGb3VuZCB1bmtub3duIGFyZ3VtZW50OiAke2hpZ2hsaWdodChhcmcpfWApO1xuXHRcdFx0cmV0dXJuIG5ldyBQYXJzZWRBcmd1bWVudCgnYXJndW1lbnQnLCB7XG5cdFx0XHRcdGlucHV0OiBpc1BhcnNlZCA/IGFyZy5pbnB1dCA6IFsgYXJnIF1cblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWNvbnN0cnVjdHMgdGhlIGFyZ3VtZW50cyBpbnRvIGEgc3RyaW5nLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHQgKiBAYWNjZXNzIHB1YmxpY1xuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVPZigpLmpvaW4oJyAnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgcmVjb25zdHJ1Y3Rpb24gb2YgYHByb2Nlc3MuYXJndmAuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtBcnJheS48U3RyaW5nPn1cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICovXG5cdHZhbHVlT2YoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXJncy5tYXAoYXJnID0+IFN0cmluZyhhcmcpKTtcblx0fVxufVxuIl0sImZpbGUiOiJwYXJzZXIvcGFyc2VyLmpzIn0=
