"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _errors = _interopRequireDefault(require("../lib/errors"));

var _types = require("./types");

var _util = require("../lib/util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const formatRegExp = /^(?:-(\w)(?:[ ,|]+)?)?(?:--([^\s=]+))?(?:[\s=]+(.+))?$/;
const valueRegExp = /^(\[(?=.+\]$)|<(?=.+>$))(.+)[\]>]$/;
const negateRegExp = /^no-(.+)$/;
const aliasRegExp = /^(!)?(?:-(.)|--(no-)?(.+))$/;
const numberRegExp = /^\d+(\.\d*)?$/;
/**
 * Defines an option and it's parameters.
 */

class Option {
  /**
   * Creates an option descriptor.
   *
   * @param {String|Object} format - The option format or a option parameters.
   * @param {String|Object} [params] - Either a description or parameters when `format` is a
   * `String`.
   * @param {Array.<String>|String} [params.aliases] - An array of aliases. If an alias starts
   * with a `!`, then it is hidden from the help.
   * @param {Function} [params.callback] - A function to call when the option has been parsed.
   * @param {Boolean} [params.camelCase=true] - If option has a name or can derive a name from the
   * long option format, then it the name be camel cased.
   * @param {*} [params.default] - A default value. Defaults to `undefined` unless the `type` is
   * set to `bool` and `negate` is `true`, then the default value will be set to `true`.
   * @param {String} [params.desc] - The description of the option used in the help display.
   * @param {String} [params.env] - The environment variable name to get a value from. If the
   * environment variable is set, it overrides the value parsed from the arguments.
   * @param {String} [params.errorMsg] - A generic message when the value is invalid.
   * @param {Boolean} [params.hidden=false] - When `true`, the option is not displayed on the help
   * screen or auto-suggest.
   * @param {String} [params.hint] - The hint label if the option expects a value.
   * @param {Number} [params.max] - When `type` is `int`, `number`, or `positiveInt`, the
   * validator will assert the value is less than or equal to the specified value.
   * @param {Number} [params.min] - When `type` is `int`, `number`, or `positiveInt`, the
   * validator will assert the value is greater than or equal to the specified value.
   * @param {Boolean} [params.multiple] - When `true`, if this option is parsed more than once,
   * the values are put in an array. When `false`, the last parsed value overwrites the previously
   * parsed value.
   * @param {Boolean} [params.negate] - When `true`, it will automatically prepend `no-` to the
   * option name on the help screen and convert the value from truthy to `false` or falsey to
   * `true`.
   * @param {Number} [params.order=Infinity] - A number used to sort the options within the group
   * on the help screen. Options with a lower order are sorted before those with a higher order.
   * If two options have the same order, then they are sorted alphabetically based on the name.
   * @param {Boolean} [params.required] - Marks the option value as required.
   * @param {String|RegExp} [params.type] - The option type to coerce the data type into. If type
   * is a regular expression, then it'll use it to validate the option.
   * @access public
   */
  constructor(format, params) {
    if (format && typeof format === 'object' && format.clikit instanceof Set && format.clikit.has('Option')) {
      params = format;
      format = format.format;
    }

    if (!format || typeof format !== 'string') {
      throw _errors.default.INVALID_ARGUMENT('Expected option format to be a non-empty string', {
        name: 'format',
        scope: 'Option.constructor',
        value: format
      });
    }

    if (params === undefined || params === null) {
      params = {};
    } else if (typeof params === 'string') {
      params = {
        desc: params
      };
    }

    if (typeof params !== 'object' || Array.isArray(params)) {
      throw _errors.default.INVALID_ARGUMENT('Expected params to be an object', {
        name: 'params',
        scope: 'Option.constructor',
        value: params
      });
    }

    if (params.callback && typeof params.callback !== 'function') {
      throw _errors.default.INVALID_ARGUMENT('Expected option callback to be a function', {
        name: 'params.callback',
        scope: 'Option.constructor',
        value: params.callback
      });
    }

    this.callback = params.callback;
    this.desc = params.desc;
    this.env = params.env;
    this.errorMsg = params.errorMsg;
    this.format = format.trim();
    this.hidden = !!params.hidden;
    this.max = params.max || null;
    this.min = params.min || null;
    this.multiple = !!params.multiple;
    this.negate = false;
    this.order = params.order || Infinity;
    this.regex = params.type instanceof RegExp ? params.type : null;
    this.required = !!params.required;
    this.type = params.type; // first try to see if we have a valid option format

    const m = this.format.match(formatRegExp);

    if (!m || !m[1] && !m[2]) {
      throw _errors.default.INVALID_OPTION_FORMAT(`Invalid option format "${this.format}"`, {
        name: 'format',
        scope: 'Option.constructor',
        value: this.format
      });
    }

    this.aliases = processAliases(params.aliases);
    this.short = m[1] || null; // check if we have a long option and name

    if (m[2]) {
      const negate = m[2].match(negateRegExp);
      this.negate = !!negate;
      this.name = negate ? negate[1] : m[2];
      this.long = negate ? negate[1] : m[2];
    }

    this.name = this.name || this.long || this.short || this.format;

    if (!this.name) {
      throw _errors.default.INVALID_OPTION(`Option "${this.format}" has no name`, {
        name: 'name',
        scope: 'Option.constructor',
        value: params.name
      });
    }

    let hint = this.type !== 'count' && params.hint || m[3];

    if (hint) {
      const value = hint.match(valueRegExp);

      if (value) {
        this.hint = hint = value[2].trim();
        this.required = this.required || value[1] === '<';
      } else {
        this.hint = hint;
      }
    }

    this.camelCase = this.name ? params.camelCase !== false : false;
    this.isFlag = !hint;
    this.redact = params.redact === undefined ? !this.isFlag : params.redact !== false; // determine the datatype

    if (this.isFlag) {
      this.datatype = (0, _types.checkType)(params.type, 'bool');

      if (this.datatype !== 'bool' && this.datatype !== 'count') {
        throw _errors.default.CONFLICT(`Option "${this.format}" is a flag and must be type bool`, {
          name: 'flag',
          scope: 'Option.constructor',
          value: params.dataType
        });
      }
    } else {
      this.datatype = (0, _types.checkType)(params.type, this.hint, 'string');
    }

    if (this.datatype !== 'bool' && this.negate) {
      throw _errors.default.CONFLICT(`Option "${this.format}" is negated and must be type bool`, {
        name: 'negate',
        scope: 'Option.constructor',
        value: params.negate
      });
    }

    this.default = params.default !== undefined ? params.default : this.datatype === 'bool' && this.negate ? true : undefined;
    (0, _util.declareCLIKitClass)(this, 'Option'); // mix in any other custom props

    for (const [key, value] of Object.entries(params)) {
      if (!Object.prototype.hasOwnProperty.call(this, key)) {
        this[key] = value;
      }
    }
  }
  /**
   * Returns this option's schema.
   *
   * @returns {Object}
   * @access public
   */


  schema() {
    return {
      aliases: this.aliases,
      desc: this.desc,
      format: this.format,
      hint: this.hint,
      type: this.type
    };
  }
  /**
   * Transforms the given option value based on its type.
   *
   * @param {*} value - The value to transform.
   * @param {Boolean} [negated] - Set to `true` if the parsed argument started with `no-`.
   * @returns {*}
   * @access public
   */


  transform(value, negated) {
    value = (0, _types.transformValue)(value, this.datatype);

    switch (this.datatype) {
      case 'bool':
        // for bools, we need to negate, but only if the option name specified negated version
        if (negated) {
          value = !value;
        }

        break;

      case 'count':
        break;

      case 'int':
      case 'number':
      case 'positiveInt':
        if (this.min !== null && value < this.min) {
          throw _errors.default.RANGE_ERROR(`Value must be greater than or equal to ${this.min}`, {
            max: this.max,
            min: this.min,
            name: 'min',
            scope: 'Option.transform',
            value
          });
        }

        if (this.max !== null && value > this.max) {
          throw _errors.default.RANGE_ERROR(`Value must be less than or equal to ${this.max}`, {
            max: this.max,
            min: this.min,
            name: 'max',
            scope: 'Option.transform',
            value
          });
        }

        break;

      case 'regex':
        if (!this.regex.test(value)) {
          throw _errors.default.INVALID_VALUE(this.errorMsg || 'Invalid value', {
            name: 'regex',
            regex: this.regex,
            scope: 'Option.transform',
            value
          });
        }

        break;

      default:
        // check if value could be a number
        if (numberRegExp.test(value)) {
          const n = parseFloat(value);

          if (!isNaN(n)) {
            return n;
          }
        }

    }

    return value;
  }

}
/**
 * Processes aliases into sorted buckets for faster lookup.
 *
 * @param {Array.<String>|String} aliases - An array, object, or string containing aliases.
 * @returns {Object}
 */


exports.default = Option;

function processAliases(aliases) {
  const result = {
    long: {},
    short: {}
  };

  if (!aliases) {
    return result;
  }

  if (!Array.isArray(aliases)) {
    if (typeof aliases === 'object') {
      if (aliases.long && typeof aliases.long === 'object') {
        Object.assign(result.long, aliases.long);
      }

      if (aliases.short && typeof aliases.short === 'object') {
        Object.assign(result.short, aliases.short);
      }

      return result;
    }

    aliases = [aliases];
  }

  for (const alias of aliases) {
    if (!alias || typeof alias !== 'string') {
      throw _errors.default.INVALID_ALIAS('Expected aliases to be a string or an array of strings', {
        name: 'aliases',
        scope: 'Option.constructor',
        value: alias
      });
    }

    for (const a of alias.split(/[ ,|]+/)) {
      const m = a.match(aliasRegExp);

      if (!m) {
        throw _errors.default.INVALID_ALIAS(`Invalid alias format "${alias}"`, {
          name: 'aliases',
          scope: 'Option.constructor',
          value: alias
        });
      } // note: m[3] contains the negate sequence, but we ignore since it's handled during parsing


      if (m[2]) {
        result.short[m[2]] = !m[1];
      } else if (m[4]) {
        result.long[m[4]] = !m[1];
      }
    }
  }

  return result;
}
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcnNlci9vcHRpb24uanMiXSwibmFtZXMiOlsiZm9ybWF0UmVnRXhwIiwidmFsdWVSZWdFeHAiLCJuZWdhdGVSZWdFeHAiLCJhbGlhc1JlZ0V4cCIsIm51bWJlclJlZ0V4cCIsIk9wdGlvbiIsImNvbnN0cnVjdG9yIiwiZm9ybWF0IiwicGFyYW1zIiwiY2xpa2l0IiwiU2V0IiwiaGFzIiwiRSIsIklOVkFMSURfQVJHVU1FTlQiLCJuYW1lIiwic2NvcGUiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImRlc2MiLCJBcnJheSIsImlzQXJyYXkiLCJjYWxsYmFjayIsImVudiIsImVycm9yTXNnIiwidHJpbSIsImhpZGRlbiIsIm1heCIsIm1pbiIsIm11bHRpcGxlIiwibmVnYXRlIiwib3JkZXIiLCJJbmZpbml0eSIsInJlZ2V4IiwidHlwZSIsIlJlZ0V4cCIsInJlcXVpcmVkIiwibSIsIm1hdGNoIiwiSU5WQUxJRF9PUFRJT05fRk9STUFUIiwiYWxpYXNlcyIsInByb2Nlc3NBbGlhc2VzIiwic2hvcnQiLCJsb25nIiwiSU5WQUxJRF9PUFRJT04iLCJoaW50IiwiY2FtZWxDYXNlIiwiaXNGbGFnIiwicmVkYWN0IiwiZGF0YXR5cGUiLCJDT05GTElDVCIsImRhdGFUeXBlIiwiZGVmYXVsdCIsImtleSIsIk9iamVjdCIsImVudHJpZXMiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJzY2hlbWEiLCJ0cmFuc2Zvcm0iLCJuZWdhdGVkIiwiUkFOR0VfRVJST1IiLCJ0ZXN0IiwiSU5WQUxJRF9WQUxVRSIsIm4iLCJwYXJzZUZsb2F0IiwiaXNOYU4iLCJyZXN1bHQiLCJhc3NpZ24iLCJhbGlhcyIsIklOVkFMSURfQUxJQVMiLCJhIiwic3BsaXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFFQTs7QUFDQTs7OztBQUVBLE1BQU1BLFlBQVksR0FBRyx3REFBckI7QUFDQSxNQUFNQyxXQUFXLEdBQUcsb0NBQXBCO0FBQ0EsTUFBTUMsWUFBWSxHQUFH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QUNEO0FBQ0Q7O0FBRUQsU0FBTytCLE1BQVA7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFIGZyb20gJy4uL2xpYi9lcnJvcnMnO1xuXG5pbXBvcnQgeyBjaGVja1R5cGUsIHRyYW5zZm9ybVZhbHVlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBkZWNsYXJlQ0xJS2l0Q2xhc3MgfSBmcm9tICcuLi9saWIvdXRpbCc7XG5cbmNvbnN0IGZvcm1hdFJlZ0V4cCA9IC9eKD86LShcXHcpKD86WyAsfF0rKT8pPyg/Oi0tKFteXFxzPV0rKSk/KD86W1xccz1dKyguKykpPyQvO1xuY29uc3QgdmFsdWVSZWdFeHAgPSAvXihcXFsoPz0uK1xcXSQpfDwoPz0uKz4kKSkoLispW1xcXT5dJC87XG5jb25zdCBuZWdhdGVSZWdFeHAgPSAvXm5vLSguKykkLztcbmNvbnN0IGFsaWFzUmVnRXhwID0gL14oISk/KD86LSguKXwtLShuby0pPyguKykpJC87XG5jb25zdCBudW1iZXJSZWdFeHAgPSAvXlxcZCsoXFwuXFxkKik/JC87XG5cbi8qKlxuICogRGVmaW5lcyBhbiBvcHRpb24gYW5kIGl0J3MgcGFyYW1ldGVycy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3B0aW9uIHtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gb3B0aW9uIGRlc2NyaXB0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZm9ybWF0IC0gVGhlIG9wdGlvbiBmb3JtYXQgb3IgYSBvcHRpb24gcGFyYW1ldGVycy5cblx0ICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBbcGFyYW1zXSAtIEVpdGhlciBhIGRlc2NyaXB0aW9uIG9yIHBhcmFtZXRlcnMgd2hlbiBgZm9ybWF0YCBpcyBhXG5cdCAqIGBTdHJpbmdgLlxuXHQgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fFN0cmluZ30gW3BhcmFtcy5hbGlhc2VzXSAtIEFuIGFycmF5IG9mIGFsaWFzZXMuIElmIGFuIGFsaWFzIHN0YXJ0c1xuXHQgKiB3aXRoIGEgYCFgLCB0aGVuIGl0IGlzIGhpZGRlbiBmcm9tIHRoZSBoZWxwLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGFyYW1zLmNhbGxiYWNrXSAtIEEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBvcHRpb24gaGFzIGJlZW4gcGFyc2VkLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuY2FtZWxDYXNlPXRydWVdIC0gSWYgb3B0aW9uIGhhcyBhIG5hbWUgb3IgY2FuIGRlcml2ZSBhIG5hbWUgZnJvbSB0aGVcblx0ICogbG9uZyBvcHRpb24gZm9ybWF0LCB0aGVuIGl0IHRoZSBuYW1lIGJlIGNhbWVsIGNhc2VkLlxuXHQgKiBAcGFyYW0geyp9IFtwYXJhbXMuZGVmYXVsdF0gLSBBIGRlZmF1bHQgdmFsdWUuIERlZmF1bHRzIHRvIGB1bmRlZmluZWRgIHVubGVzcyB0aGUgYHR5cGVgIGlzXG5cdCAqIHNldCB0byBgYm9vbGAgYW5kIGBuZWdhdGVgIGlzIGB0cnVlYCwgdGhlbiB0aGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHNldCB0byBgdHJ1ZWAuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLmRlc2NdIC0gVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBvcHRpb24gdXNlZCBpbiB0aGUgaGVscCBkaXNwbGF5LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5lbnZdIC0gVGhlIGVudmlyb25tZW50IHZhcmlhYmxlIG5hbWUgdG8gZ2V0IGEgdmFsdWUgZnJvbS4gSWYgdGhlXG5cdCAqIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIHNldCwgaXQgb3ZlcnJpZGVzIHRoZSB2YWx1ZSBwYXJzZWQgZnJvbSB0aGUgYXJndW1lbnRzLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5lcnJvck1zZ10gLSBBIGdlbmVyaWMgbWVzc2FnZSB3aGVuIHRoZSB2YWx1ZSBpcyBpbnZhbGlkLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuaGlkZGVuPWZhbHNlXSAtIFdoZW4gYHRydWVgLCB0aGUgb3B0aW9uIGlzIG5vdCBkaXNwbGF5ZWQgb24gdGhlIGhlbHBcblx0ICogc2NyZWVuIG9yIGF1dG8tc3VnZ2VzdC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMuaGludF0gLSBUaGUgaGludCBsYWJlbCBpZiB0aGUgb3B0aW9uIGV4cGVjdHMgYSB2YWx1ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMubWF4XSAtIFdoZW4gYHR5cGVgIGlzIGBpbnRgLCBgbnVtYmVyYCwgb3IgYHBvc2l0aXZlSW50YCwgdGhlXG5cdCAqIHZhbGlkYXRvciB3aWxsIGFzc2VydCB0aGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLm1pbl0gLSBXaGVuIGB0eXBlYCBpcyBgaW50YCwgYG51bWJlcmAsIG9yIGBwb3NpdGl2ZUludGAsIHRoZVxuXHQgKiB2YWxpZGF0b3Igd2lsbCBhc3NlcnQgdGhlIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkIHZhbHVlLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMubXVsdGlwbGVdIC0gV2hlbiBgdHJ1ZWAsIGlmIHRoaXMgb3B0aW9uIGlzIHBhcnNlZCBtb3JlIHRoYW4gb25jZSxcblx0ICogdGhlIHZhbHVlcyBhcmUgcHV0IGluIGFuIGFycmF5LiBXaGVuIGBmYWxzZWAsIHRoZSBsYXN0IHBhcnNlZCB2YWx1ZSBvdmVyd3JpdGVzIHRoZSBwcmV2aW91c2x5XG5cdCAqIHBhcnNlZCB2YWx1ZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLm5lZ2F0ZV0gLSBXaGVuIGB0cnVlYCwgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IHByZXBlbmQgYG5vLWAgdG8gdGhlXG5cdCAqIG9wdGlvbiBuYW1lIG9uIHRoZSBoZWxwIHNjcmVlbiBhbmQgY29udmVydCB0aGUgdmFsdWUgZnJvbSB0cnV0aHkgdG8gYGZhbHNlYCBvciBmYWxzZXkgdG9cblx0ICogYHRydWVgLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5vcmRlcj1JbmZpbml0eV0gLSBBIG51bWJlciB1c2VkIHRvIHNvcnQgdGhlIG9wdGlvbnMgd2l0aGluIHRoZSBncm91cFxuXHQgKiBvbiB0aGUgaGVscCBzY3JlZW4uIE9wdGlvbnMgd2l0aCBhIGxvd2VyIG9yZGVyIGFyZSBzb3J0ZWQgYmVmb3JlIHRob3NlIHdpdGggYSBoaWdoZXIgb3JkZXIuXG5cdCAqIElmIHR3byBvcHRpb25zIGhhdmUgdGhlIHNhbWUgb3JkZXIsIHRoZW4gdGhleSBhcmUgc29ydGVkIGFscGhhYmV0aWNhbGx5IGJhc2VkIG9uIHRoZSBuYW1lLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMucmVxdWlyZWRdIC0gTWFya3MgdGhlIG9wdGlvbiB2YWx1ZSBhcyByZXF1aXJlZC5cblx0ICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBbcGFyYW1zLnR5cGVdIC0gVGhlIG9wdGlvbiB0eXBlIHRvIGNvZXJjZSB0aGUgZGF0YSB0eXBlIGludG8uIElmIHR5cGVcblx0ICogaXMgYSByZWd1bGFyIGV4cHJlc3Npb24sIHRoZW4gaXQnbGwgdXNlIGl0IHRvIHZhbGlkYXRlIHRoZSBvcHRpb24uXG5cdCAqIEBhY2Nlc3MgcHVibGljXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihmb3JtYXQsIHBhcmFtcykge1xuXHRcdGlmIChmb3JtYXQgJiYgdHlwZW9mIGZvcm1hdCA9PT0gJ29iamVjdCcgJiYgZm9ybWF0LmNsaWtpdCBpbnN0YW5jZW9mIFNldCAmJiBmb3JtYXQuY2xpa2l0LmhhcygnT3B0aW9uJykpIHtcblx0XHRcdHBhcmFtcyA9IGZvcm1hdDtcblx0XHRcdGZvcm1hdCA9IGZvcm1hdC5mb3JtYXQ7XG5cdFx0fVxuXG5cdFx0aWYgKCFmb3JtYXQgfHwgdHlwZW9mIGZvcm1hdCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHRocm93IEUuSU5WQUxJRF9BUkdVTUVOVCgnRXhwZWN0ZWQgb3B0aW9uIGZvcm1hdCB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnLCB7IG5hbWU6ICdmb3JtYXQnLCBzY29wZTogJ09wdGlvbi5jb25zdHJ1Y3RvcicsIHZhbHVlOiBmb3JtYXQgfSk7XG5cdFx0fVxuXG5cdFx0aWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcyA9PT0gbnVsbCkge1xuXHRcdFx0cGFyYW1zID0ge307XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJykge1xuXHRcdFx0cGFyYW1zID0geyBkZXNjOiBwYXJhbXMgfTtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIHBhcmFtcyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG5cdFx0XHR0aHJvdyBFLklOVkFMSURfQVJHVU1FTlQoJ0V4cGVjdGVkIHBhcmFtcyB0byBiZSBhbiBvYmplY3QnLCB7IG5hbWU6ICdwYXJhbXMnLCBzY29wZTogJ09wdGlvbi5jb25zdHJ1Y3RvcicsIHZhbHVlOiBwYXJhbXMgfSk7XG5cdFx0fVxuXG5cdFx0aWYgKHBhcmFtcy5jYWxsYmFjayAmJiB0eXBlb2YgcGFyYW1zLmNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aHJvdyBFLklOVkFMSURfQVJHVU1FTlQoJ0V4cGVjdGVkIG9wdGlvbiBjYWxsYmFjayB0byBiZSBhIGZ1bmN0aW9uJywgeyBuYW1lOiAncGFyYW1zLmNhbGxiYWNrJywgc2NvcGU6ICdPcHRpb24uY29uc3RydWN0b3InLCB2YWx1ZTogcGFyYW1zLmNhbGxiYWNrIH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuY2FsbGJhY2sgPSBwYXJhbXMuY2FsbGJhY2s7XG5cdFx0dGhpcy5kZXNjICAgICA9IHBhcmFtcy5kZXNjO1xuXHRcdHRoaXMuZW52ICAgICAgPSBwYXJhbXMuZW52O1xuXHRcdHRoaXMuZXJyb3JNc2cgPSBwYXJhbXMuZXJyb3JNc2c7XG5cdFx0dGhpcy5mb3JtYXQgICA9IGZvcm1hdC50cmltKCk7XG5cdFx0dGhpcy5oaWRkZW4gICA9ICEhcGFyYW1zLmhpZGRlbjtcblx0XHR0aGlzLm1heCAgICAgID0gcGFyYW1zLm1heCB8fCBudWxsO1xuXHRcdHRoaXMubWluICAgICAgPSBwYXJhbXMubWluIHx8IG51bGw7XG5cdFx0dGhpcy5tdWx0aXBsZSA9ICEhcGFyYW1zLm11bHRpcGxlO1xuXHRcdHRoaXMubmVnYXRlICAgPSBmYWxzZTtcblx0XHR0aGlzLm9yZGVyICAgID0gcGFyYW1zLm9yZGVyIHx8IEluZmluaXR5O1xuXHRcdHRoaXMucmVnZXggICAgPSBwYXJhbXMudHlwZSBpbnN0YW5jZW9mIFJlZ0V4cCA/IHBhcmFtcy50eXBlIDogbnVsbDtcblx0XHR0aGlzLnJlcXVpcmVkID0gISFwYXJhbXMucmVxdWlyZWQ7XG5cdFx0dGhpcy50eXBlICAgICA9IHBhcmFtcy50eXBlO1xuXG5cdFx0Ly8gZmlyc3QgdHJ5IHRvIHNlZSBpZiB3ZSBoYXZlIGEgdmFsaWQgb3B0aW9uIGZvcm1hdFxuXHRcdGNvbnN0IG0gPSB0aGlzLmZvcm1hdC5tYXRjaChmb3JtYXRSZWdFeHApO1xuXHRcdGlmICghbSB8fCAoIW1bMV0gJiYgIW1bMl0pKSB7XG5cdFx0XHR0aHJvdyBFLklOVkFMSURfT1BUSU9OX0ZPUk1BVChgSW52YWxpZCBvcHRpb24gZm9ybWF0IFwiJHt0aGlzLmZvcm1hdH1cImAsIHsgbmFtZTogJ2Zvcm1hdCcsIHNjb3BlOiAnT3B0aW9uLmNvbnN0cnVjdG9yJywgdmFsdWU6IHRoaXMuZm9ybWF0IH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuYWxpYXNlcyAgPSBwcm9jZXNzQWxpYXNlcyhwYXJhbXMuYWxpYXNlcyk7XG5cdFx0dGhpcy5zaG9ydCAgICA9IG1bMV0gfHwgbnVsbDtcblxuXHRcdC8vIGNoZWNrIGlmIHdlIGhhdmUgYSBsb25nIG9wdGlvbiBhbmQgbmFtZVxuXHRcdGlmIChtWzJdKSB7XG5cdFx0XHRjb25zdCBuZWdhdGUgID0gbVsyXS5tYXRjaChuZWdhdGVSZWdFeHApO1xuXHRcdFx0dGhpcy5uZWdhdGUgPSAhIW5lZ2F0ZTtcblx0XHRcdHRoaXMubmFtZSAgID0gbmVnYXRlID8gbmVnYXRlWzFdIDogbVsyXTtcblx0XHRcdHRoaXMubG9uZyAgID0gbmVnYXRlID8gbmVnYXRlWzFdIDogbVsyXTtcblx0XHR9XG5cblx0XHR0aGlzLm5hbWUgPSB0aGlzLm5hbWUgfHwgdGhpcy5sb25nIHx8IHRoaXMuc2hvcnQgfHwgdGhpcy5mb3JtYXQ7XG5cdFx0aWYgKCF0aGlzLm5hbWUpIHtcblx0XHRcdHRocm93IEUuSU5WQUxJRF9PUFRJT04oYE9wdGlvbiBcIiR7dGhpcy5mb3JtYXR9XCIgaGFzIG5vIG5hbWVgLCB7IG5hbWU6ICduYW1lJywgc2NvcGU6ICdPcHRpb24uY29uc3RydWN0b3InLCB2YWx1ZTogcGFyYW1zLm5hbWUgfSk7XG5cdFx0fVxuXG5cdFx0bGV0IGhpbnQgPSB0aGlzLnR5cGUgIT09ICdjb3VudCcgJiYgcGFyYW1zLmhpbnQgfHwgbVszXTtcblx0XHRpZiAoaGludCkge1xuXHRcdFx0Y29uc3QgdmFsdWUgPSBoaW50Lm1hdGNoKHZhbHVlUmVnRXhwKTtcblx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHR0aGlzLmhpbnQgPSBoaW50ID0gdmFsdWVbMl0udHJpbSgpO1xuXHRcdFx0XHR0aGlzLnJlcXVpcmVkID0gdGhpcy5yZXF1aXJlZCB8fCB2YWx1ZVsxXSA9PT0gJzwnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5oaW50ID0gaGludDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5jYW1lbENhc2UgPSB0aGlzLm5hbWUgPyBwYXJhbXMuY2FtZWxDYXNlICE9PSBmYWxzZSA6IGZhbHNlO1xuXHRcdHRoaXMuaXNGbGFnICAgID0gIWhpbnQ7XG5cdFx0dGhpcy5yZWRhY3QgICAgPSBwYXJhbXMucmVkYWN0ID09PSB1bmRlZmluZWQgPyAhdGhpcy5pc0ZsYWcgOiBwYXJhbXMucmVkYWN0ICE9PSBmYWxzZTtcblxuXHRcdC8vIGRldGVybWluZSB0aGUgZGF0YXR5cGVcblx0XHRpZiAodGhpcy5pc0ZsYWcpIHtcblx0XHRcdHRoaXMuZGF0YXR5cGUgPSBjaGVja1R5cGUocGFyYW1zLnR5cGUsICdib29sJyk7XG5cdFx0XHRpZiAodGhpcy5kYXRhdHlwZSAhPT0gJ2Jvb2wnICYmIHRoaXMuZGF0YXR5cGUgIT09ICdjb3VudCcpIHtcblx0XHRcdFx0dGhyb3cgRS5DT05GTElDVChgT3B0aW9uIFwiJHt0aGlzLmZvcm1hdH1cIiBpcyBhIGZsYWcgYW5kIG11c3QgYmUgdHlwZSBib29sYCwgeyBuYW1lOiAnZmxhZycsIHNjb3BlOiAnT3B0aW9uLmNvbnN0cnVjdG9yJywgdmFsdWU6IHBhcmFtcy5kYXRhVHlwZSB9KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5kYXRhdHlwZSA9IGNoZWNrVHlwZShwYXJhbXMudHlwZSwgdGhpcy5oaW50LCAnc3RyaW5nJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuZGF0YXR5cGUgIT09ICdib29sJyAmJiB0aGlzLm5lZ2F0ZSkge1xuXHRcdFx0dGhyb3cgRS5DT05GTElDVChgT3B0aW9uIFwiJHt0aGlzLmZvcm1hdH1cIiBpcyBuZWdhdGVkIGFuZCBtdXN0IGJlIHR5cGUgYm9vbGAsIHsgbmFtZTogJ25lZ2F0ZScsIHNjb3BlOiAnT3B0aW9uLmNvbnN0cnVjdG9yJywgdmFsdWU6IHBhcmFtcy5uZWdhdGUgfSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5kZWZhdWx0ID0gcGFyYW1zLmRlZmF1bHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtcy5kZWZhdWx0IDogKHRoaXMuZGF0YXR5cGUgPT09ICdib29sJyAmJiB0aGlzLm5lZ2F0ZSA/IHRydWUgOiB1bmRlZmluZWQpO1xuXG5cdFx0ZGVjbGFyZUNMSUtpdENsYXNzKHRoaXMsICdPcHRpb24nKTtcblxuXHRcdC8vIG1peCBpbiBhbnkgb3RoZXIgY3VzdG9tIHByb3BzXG5cdFx0Zm9yIChjb25zdCBbIGtleSwgdmFsdWUgXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKSB7XG5cdFx0XHRpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBrZXkpKSB7XG5cdFx0XHRcdHRoaXNba2V5XSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoaXMgb3B0aW9uJ3Mgc2NoZW1hLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHQgKiBAYWNjZXNzIHB1YmxpY1xuXHQgKi9cblx0c2NoZW1hKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRhbGlhc2VzOiB0aGlzLmFsaWFzZXMsXG5cdFx0XHRkZXNjOiAgICB0aGlzLmRlc2MsXG5cdFx0XHRmb3JtYXQ6ICB0aGlzLmZvcm1hdCxcblx0XHRcdGhpbnQ6ICAgIHRoaXMuaGludCxcblx0XHRcdHR5cGU6ICAgIHRoaXMudHlwZVxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gb3B0aW9uIHZhbHVlIGJhc2VkIG9uIGl0cyB0eXBlLlxuXHQgKlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbbmVnYXRlZF0gLSBTZXQgdG8gYHRydWVgIGlmIHRoZSBwYXJzZWQgYXJndW1lbnQgc3RhcnRlZCB3aXRoIGBuby1gLlxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICovXG5cdHRyYW5zZm9ybSh2YWx1ZSwgbmVnYXRlZCkge1xuXHRcdHZhbHVlID0gdHJhbnNmb3JtVmFsdWUodmFsdWUsIHRoaXMuZGF0YXR5cGUpO1xuXG5cdFx0c3dpdGNoICh0aGlzLmRhdGF0eXBlKSB7XG5cdFx0XHRjYXNlICdib29sJzpcblx0XHRcdFx0Ly8gZm9yIGJvb2xzLCB3ZSBuZWVkIHRvIG5lZ2F0ZSwgYnV0IG9ubHkgaWYgdGhlIG9wdGlvbiBuYW1lIHNwZWNpZmllZCBuZWdhdGVkIHZlcnNpb25cblx0XHRcdFx0aWYgKG5lZ2F0ZWQpIHtcblx0XHRcdFx0XHR2YWx1ZSA9ICF2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnY291bnQnOlxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnaW50Jzpcblx0XHRcdGNhc2UgJ251bWJlcic6XG5cdFx0XHRjYXNlICdwb3NpdGl2ZUludCc6XG5cdFx0XHRcdGlmICh0aGlzLm1pbiAhPT0gbnVsbCAmJiB2YWx1ZSA8IHRoaXMubWluKSB7XG5cdFx0XHRcdFx0dGhyb3cgRS5SQU5HRV9FUlJPUihgVmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHt0aGlzLm1pbn1gLCB7IG1heDogdGhpcy5tYXgsIG1pbjogdGhpcy5taW4sIG5hbWU6ICdtaW4nLCBzY29wZTogJ09wdGlvbi50cmFuc2Zvcm0nLCB2YWx1ZSB9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5tYXggIT09IG51bGwgJiYgdmFsdWUgPiB0aGlzLm1heCkge1xuXHRcdFx0XHRcdHRocm93IEUuUkFOR0VfRVJST1IoYFZhbHVlIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7dGhpcy5tYXh9YCwgeyBtYXg6IHRoaXMubWF4LCBtaW46IHRoaXMubWluLCBuYW1lOiAnbWF4Jywgc2NvcGU6ICdPcHRpb24udHJhbnNmb3JtJywgdmFsdWUgfSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ3JlZ2V4Jzpcblx0XHRcdFx0aWYgKCF0aGlzLnJlZ2V4LnRlc3QodmFsdWUpKSB7XG5cdFx0XHRcdFx0dGhyb3cgRS5JTlZBTElEX1ZBTFVFKHRoaXMuZXJyb3JNc2cgfHwgJ0ludmFsaWQgdmFsdWUnLCB7IG5hbWU6ICdyZWdleCcsIHJlZ2V4OiB0aGlzLnJlZ2V4LCBzY29wZTogJ09wdGlvbi50cmFuc2Zvcm0nLCB2YWx1ZSB9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Ly8gY2hlY2sgaWYgdmFsdWUgY291bGQgYmUgYSBudW1iZXJcblx0XHRcdFx0aWYgKG51bWJlclJlZ0V4cC50ZXN0KHZhbHVlKSkge1xuXHRcdFx0XHRcdGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbHVlKTtcblx0XHRcdFx0XHRpZiAoIWlzTmFOKG4pKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cbn1cblxuLyoqXG4gKiBQcm9jZXNzZXMgYWxpYXNlcyBpbnRvIHNvcnRlZCBidWNrZXRzIGZvciBmYXN0ZXIgbG9va3VwLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz58U3RyaW5nfSBhbGlhc2VzIC0gQW4gYXJyYXksIG9iamVjdCwgb3Igc3RyaW5nIGNvbnRhaW5pbmcgYWxpYXNlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NBbGlhc2VzKGFsaWFzZXMpIHtcblx0Y29uc3QgcmVzdWx0ID0ge1xuXHRcdGxvbmc6IHt9LFxuXHRcdHNob3J0OiB7fVxuXHR9O1xuXG5cdGlmICghYWxpYXNlcykge1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRpZiAoIUFycmF5LmlzQXJyYXkoYWxpYXNlcykpIHtcblx0XHRpZiAodHlwZW9mIGFsaWFzZXMgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRpZiAoYWxpYXNlcy5sb25nICYmIHR5cGVvZiBhbGlhc2VzLmxvbmcgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdE9iamVjdC5hc3NpZ24ocmVzdWx0LmxvbmcsIGFsaWFzZXMubG9uZyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYWxpYXNlcy5zaG9ydCAmJiB0eXBlb2YgYWxpYXNlcy5zaG9ydCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0T2JqZWN0LmFzc2lnbihyZXN1bHQuc2hvcnQsIGFsaWFzZXMuc2hvcnQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cblx0XHRhbGlhc2VzID0gWyBhbGlhc2VzIF07XG5cdH1cblxuXHRmb3IgKGNvbnN0IGFsaWFzIG9mIGFsaWFzZXMpIHtcblx0XHRpZiAoIWFsaWFzIHx8IHR5cGVvZiBhbGlhcyAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHRocm93IEUuSU5WQUxJRF9BTElBUygnRXhwZWN0ZWQgYWxpYXNlcyB0byBiZSBhIHN0cmluZyBvciBhbiBhcnJheSBvZiBzdHJpbmdzJyxcblx0XHRcdFx0eyBuYW1lOiAnYWxpYXNlcycsIHNjb3BlOiAnT3B0aW9uLmNvbnN0cnVjdG9yJywgdmFsdWU6IGFsaWFzIH0pO1xuXHRcdH1cblxuXHRcdGZvciAoY29uc3QgYSBvZiBhbGlhcy5zcGxpdCgvWyAsfF0rLykpIHtcblx0XHRcdGNvbnN0IG0gPSBhLm1hdGNoKGFsaWFzUmVnRXhwKTtcblx0XHRcdGlmICghbSkge1xuXHRcdFx0XHR0aHJvdyBFLklOVkFMSURfQUxJQVMoYEludmFsaWQgYWxpYXMgZm9ybWF0IFwiJHthbGlhc31cImAsIHsgbmFtZTogJ2FsaWFzZXMnLCBzY29wZTogJ09wdGlvbi5jb25zdHJ1Y3RvcicsIHZhbHVlOiBhbGlhcyB9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbm90ZTogbVszXSBjb250YWlucyB0aGUgbmVnYXRlIHNlcXVlbmNlLCBidXQgd2UgaWdub3JlIHNpbmNlIGl0J3MgaGFuZGxlZCBkdXJpbmcgcGFyc2luZ1xuXG5cdFx0XHRpZiAobVsyXSkge1xuXHRcdFx0XHRyZXN1bHQuc2hvcnRbbVsyXV0gPSAhbVsxXTtcblx0XHRcdH0gZWxzZSBpZiAobVs0XSkge1xuXHRcdFx0XHRyZXN1bHQubG9uZ1ttWzRdXSA9ICFtWzFdO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG4iXSwiZmlsZSI6InBhcnNlci9vcHRpb24uanMifQ==
