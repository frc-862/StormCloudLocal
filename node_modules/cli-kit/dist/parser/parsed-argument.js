"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _errors = _interopRequireDefault(require("../lib/errors"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Encapsulates a parsed argument.
 */
class ParsedArgument {
  /**
   * Sets the parsed argument type and its data.
   *
   * @param {String} type - The parsed argument type such as `command`, `option`, `extra`, or
   * `unknown`.
   * @param {Object} [data] - An optional data payload to mix into this parsed argument instance.
   * @access public
   */
  constructor(type, data) {
    if (!type || typeof type !== 'string') {
      throw _errors.default.INVALID_ARGUMENT('Expected parsed argument type to be a non-empty string', {
        name: 'type',
        scope: 'ParsedArgument.constructor',
        value: type
      });
    }

    if (data && typeof data !== 'object') {
      throw _errors.default.INVALID_ARGUMENT('Expected parsed argument data to be an object', {
        name: 'data',
        scope: 'ParsedArgument.constructor',
        value: data
      });
    }

    this.type = type;
    Object.assign(this, data);
  }
  /**
   * Attempts to form a name of the given parsed argument.
   *
   * @returns {String}
   * @access public
   */


  getName() {
    let name;

    switch (this.type) {
      case 'command':
        name = this.command && this.command.name;
        break;

      case 'option':
        name = this.option && this.option.name;
        break;
    }

    return name || this.input && this.input[0];
  }
  /**
   * Builds a string describing this parsed argument.
   *
   * @returns {String}
   * @access public
   */


  toString() {
    const name = this.getName();
    return `[parsed ${this.type}${name ? `: ${name}` : ''}]`;
  }

}

exports.default = ParsedArgument;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcnNlci9wYXJzZWQtYXJndW1lbnQuanMiXSwibmFtZXMiOlsiUGFyc2VkQXJndW1lbnQiLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJkYXRhIiwiRSIsIklOVkFMSURfQVJHVU1FTlQiLCJuYW1lIiwic2NvcGUiLCJ2YWx1ZSIsIk9iamVjdCIsImFzc2lnbiIsImdldE5hbWUiLCJjb21tYW5kIiwib3B0aW9uIiwiaW5wdXQiLCJ0b1N0cmluZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ2UsTUFBTUEsY0FBTixDQUFxQjtBQUNuQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0NDLEVBQUFBLFdBQVcsQ0FBQ0MsSUFBRCxFQUFPQyxJQUFQLEVBQWE7QUFDdkIsUUFBSSxDQUFDRCxJQUFELElBQVMsT0FBT0EsSUFBUCxLQUFnQixRQUE3QixFQUF1QztBQUN0QyxZQUFNRSxnQkFBRUMsZ0JBQUYsQ0FBbUIsd0RBQW5CLEVBQTZFO0FBQUVDLFFBQUFBLElBQUksRUFBRSxNQUFSO0FBQWdCQyxRQUFBQSxLQUFLLEVBQUUsNEJBQXZCO0FBQXFEQyxRQUFBQSxLQUFLLEVBQUVOO0FBQTVELE9BQTdFLENBQU47QUFDQTs7QUFFRCxRQUFJQyxJQUFJLElBQUksT0FBT0EsSUFBUCxLQUFnQixRQUE1QixFQUFzQztBQUNyQyxZQUFNQyxnQkFBRUMsZ0JBQUYsQ0FBbUIsK0NBQW5CLEVBQW9FO0FBQUVDLFFBQUFBLElBQUksRUFBRSxNQUFSO0FBQWdCQyxRQUFBQSxLQUFLLEVBQUUsNEJBQXZCO0FBQXFEQyxRQUFBQSxLQUFLLEVBQUVMO0FBQTVELE9BQXBFLENBQU47QUFDQTs7QUFFRCxTQUFLRCxJQUFMLEdBQVlBLElBQVo7QUFDQU8sSUFBQUEsTUFBTSxDQUFDQyxNQUFQLENBQWMsSUFBZCxFQUFvQlAsSUFBcEI7QUFDQTtBQUVEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0NRLEVBQUFBLE9BQU8sR0FBRztBQUNULFFBQUlMLElBQUo7O0FBQ0EsWUFBUSxLQUFLSixJQUFiO0FBQ0MsV0FBSyxTQUFMO0FBQ0NJLFFBQUFBLElBQUksR0FBRyxLQUFLTSxPQUFMLElBQWdCLEtBQUtBLE9BQUwsQ0FBYU4sSUFBcEM7QUFDQTs7QUFDRCxXQUFLLFFBQUw7QUFDQ0EsUUFBQUEsSUFBSSxHQUFHLEtBQUtPLE1BQUwsSUFBZSxLQUFLQSxNQUFMLENBQVlQLElBQWxDO0FBQ0E7QUFORjs7QUFRQSxXQUFPQSxJQUFJLElBQUksS0FBS1EsS0FBTCxJQUFjLEtBQUtBLEtBQUwsQ0FBVyxDQUFYLENBQTdCO0FBQ0E7QUFFRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNDQyxFQUFBQSxRQUFRLEdBQUc7QUFDVixVQUFNVCxJQUFJLEdBQUcsS0FBS0ssT0FBTCxFQUFiO0FBQ0EsV0FBUSxXQUFVLEtBQUtULElBQUssR0FBRUksSUFBSSxHQUFJLEtBQUlBLElBQUssRUFBYixHQUFpQixFQUFHLEdBQXREO0FBQ0E7O0FBbERrQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFIGZyb20gJy4uL2xpYi9lcnJvcnMnO1xuXG4vKipcbiAqIEVuY2Fwc3VsYXRlcyBhIHBhcnNlZCBhcmd1bWVudC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFyc2VkQXJndW1lbnQge1xuXHQvKipcblx0ICogU2V0cyB0aGUgcGFyc2VkIGFyZ3VtZW50IHR5cGUgYW5kIGl0cyBkYXRhLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSBwYXJzZWQgYXJndW1lbnQgdHlwZSBzdWNoIGFzIGBjb21tYW5kYCwgYG9wdGlvbmAsIGBleHRyYWAsIG9yXG5cdCAqIGB1bmtub3duYC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXSAtIEFuIG9wdGlvbmFsIGRhdGEgcGF5bG9hZCB0byBtaXggaW50byB0aGlzIHBhcnNlZCBhcmd1bWVudCBpbnN0YW5jZS5cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICovXG5cdGNvbnN0cnVjdG9yKHR5cGUsIGRhdGEpIHtcblx0XHRpZiAoIXR5cGUgfHwgdHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHR0aHJvdyBFLklOVkFMSURfQVJHVU1FTlQoJ0V4cGVjdGVkIHBhcnNlZCBhcmd1bWVudCB0eXBlIHRvIGJlIGEgbm9uLWVtcHR5IHN0cmluZycsIHsgbmFtZTogJ3R5cGUnLCBzY29wZTogJ1BhcnNlZEFyZ3VtZW50LmNvbnN0cnVjdG9yJywgdmFsdWU6IHR5cGUgfSk7XG5cdFx0fVxuXG5cdFx0aWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XG5cdFx0XHR0aHJvdyBFLklOVkFMSURfQVJHVU1FTlQoJ0V4cGVjdGVkIHBhcnNlZCBhcmd1bWVudCBkYXRhIHRvIGJlIGFuIG9iamVjdCcsIHsgbmFtZTogJ2RhdGEnLCBzY29wZTogJ1BhcnNlZEFyZ3VtZW50LmNvbnN0cnVjdG9yJywgdmFsdWU6IGRhdGEgfSk7XG5cdFx0fVxuXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHRPYmplY3QuYXNzaWduKHRoaXMsIGRhdGEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEF0dGVtcHRzIHRvIGZvcm0gYSBuYW1lIG9mIHRoZSBnaXZlbiBwYXJzZWQgYXJndW1lbnQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdCAqIEBhY2Nlc3MgcHVibGljXG5cdCAqL1xuXHRnZXROYW1lKCkge1xuXHRcdGxldCBuYW1lO1xuXHRcdHN3aXRjaCAodGhpcy50eXBlKSB7XG5cdFx0XHRjYXNlICdjb21tYW5kJzpcblx0XHRcdFx0bmFtZSA9IHRoaXMuY29tbWFuZCAmJiB0aGlzLmNvbW1hbmQubmFtZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdvcHRpb24nOlxuXHRcdFx0XHRuYW1lID0gdGhpcy5vcHRpb24gJiYgdGhpcy5vcHRpb24ubmFtZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lIHx8IHRoaXMuaW5wdXQgJiYgdGhpcy5pbnB1dFswXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCdWlsZHMgYSBzdHJpbmcgZGVzY3JpYmluZyB0aGlzIHBhcnNlZCBhcmd1bWVudC5cblx0ICpcblx0ICogQHJldHVybnMge1N0cmluZ31cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdGNvbnN0IG5hbWUgPSB0aGlzLmdldE5hbWUoKTtcblx0XHRyZXR1cm4gYFtwYXJzZWQgJHt0aGlzLnR5cGV9JHtuYW1lID8gYDogJHtuYW1lfWAgOiAnJ31dYDtcblx0fVxufVxuIl0sImZpbGUiOiJwYXJzZXIvcGFyc2VkLWFyZ3VtZW50LmpzIn0=
