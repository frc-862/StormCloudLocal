"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _command = _interopRequireDefault(require("./command"));

var _debug = _interopRequireDefault(require("../lib/debug"));

var _errors = _interopRequireDefault(require("../lib/errors"));

var _help = _interopRequireDefault(require("../commands/help"));

var _path2 = _interopRequireDefault(require("path"));

var _util = require("../lib/util");

var _child_process = require("child_process");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const {
  log,
  warn
} = (0, _debug.default)('cli-kit:extension');
const {
  highlight
} = _debug.default.styles;
const nameRegExp = /^(?:(@\w+)\/)?(.*)$/;
/**
 * Defines a namespace that wraps an external program or script.
 *
 * @extends {Command}
 */

class Extension {
  /**
   * Detects the extension defined in the specified path and initializes it.
   *
   * @param {String|Object} pathOrParams - The path to the extension or a params object. If the
   * path is a Node.js package with a `package.json` containing a `"cli-kit"` property, it will
   * merge the external cli-kit context tree into this namespace.
   * @param {Object} [params] - Various parameters when `extensionPath` is a `String`.
   * @param {Object} [params.exports] - A map of exported command names to descriptors containing
   * `aliases`, `desc`, `exe`, `main`, and `name` props.
   * @param {String} [params.name] - The extension name. If not set, it will load it from the
   * extension's `package.json` or the filename.
   * @param {String} [params.path] - The path to an executable, a JavaScript file, or Node.js
   * package.
   * @access public
   */
  constructor(pathOrParams, params) {
    let path = pathOrParams;

    if (typeof path === 'string' && !params) {
      params = {};
    } else if (pathOrParams && typeof pathOrParams === 'object') {
      ({
        path
      } = params = pathOrParams);
    }

    if (!path || typeof path !== 'string') {
      throw _errors.default.INVALID_ARGUMENT('Expected an extension path or params object', {
        name: 'pathOrParams',
        scope: 'Extension.constructor',
        value: pathOrParams
      });
    }

    if (typeof params !== 'object') {
      throw _errors.default.INVALID_ARGUMENT('Expected extension params to be an object or Context', {
        name: 'params',
        scope: 'Extension.constructor',
        value: params
      });
    }

    this.exports = params.exports || {};
    this.name = params.name;
    this.path = path;

    if (typeof this.exports !== 'object') {
      throw _errors.default.INVALID_ARGUMENT('Expected extension exports to be an object', {
        name: 'params.exports',
        scope: 'Extension.constructor',
        value: params.exports
      });
    } // we need to determine if this extension is a binary or if it's a Node package


    try {
      const exe = (0, _util.isExecutable)(path);

      if (!this.name) {
        this.name = (0, _util.filename)(exe[0]);
      }

      this.registerExtension(this.name, {
        exe
      }, {
        action: async ({
          __argv,
          cmd,
          terminal
        }) => {
          if (!Array.isArray(exe)) {
            throw _errors.default.NO_EXECUTABLE(`Extension "${this.name}" has no executable!`);
          }

          const bin = exe[0];
          const args = exe.slice(1);

          const p = __argv.findIndex(arg => arg && arg.type === 'extension' && arg.command === cmd);

          if (p !== -1) {
            for (let i = p + 1, len = __argv.length; i < len; i++) {
              args.push.apply(args, __argv[i].input);
            }
          } // spawn the process


          log(`Running: ${highlight(`${bin} ${args.join(' ')}`)}`);
          const child = (0, _child_process.spawn)(bin, args, {
            windowsHide: true
          });
          child.stdout.on('data', data => terminal.stdout.write(data.toString()));
          child.stderr.on('data', data => terminal.stderr.write(data.toString()));
          await new Promise(resolve => child.on('close', (code = 0) => resolve({
            code
          })));
        },
        desc: params.desc
      });
    } catch (e) {
      // maybe a Node package?
      try {
        let pkg;

        try {
          pkg = (0, _util.findPackage)(path);

          if (!pkg.root) {
            throw new Error();
          }
        } catch (e) {
          throw _errors.default.INVALID_EXTENSION(`Invalid extension: Unable to find executable, script, or package: ${typeof path === 'string' ? `"${path}"` : JSON.stringify(path)}`);
        }

        if (!this.name) {
          this.name = pkg.json.name;
        }

        if (!this.name) {
          this.name = (0, _util.filename)(path);
        }

        const makeDefaultAction = main => {
          return async ({
            __argv,
            cmd
          }) => {
            process.argv = [process.execPath, main];

            const p = __argv.findIndex(arg => arg && arg.type === 'extension' && arg.command === cmd);

            if (p !== -1) {
              for (let i = p + 1, len = __argv.length; i < len; i++) {
                process.argv.push.apply(process.argv, __argv[i].input);
              }
            }

            log(`Requiring ${highlight(main)}`);
            log(`Args: ${highlight(process.argv.join(' '))}`);

            require(main);
          };
        };

        if (!pkg.json.exports && pkg.main) {
          // legacy Node.js extension
          let {
            name
          } = this;
          const aliases = Array.isArray(pkg.json.aliases) ? pkg.json.aliases : []; // if the package name contains a scope, add the scoped package name as a hidden
          // alias and strip the scope from the name

          const m = name.match(nameRegExp);

          if (m) {
            aliases.push(`!${name}`);
            name = m[2];
          } // if the name is different than the one in the package.json, add it to the aliases


          if (name && name !== pkg.json.name && !aliases.includes(name)) {
            aliases.push(name);
          } // if the package has a bin script that matches the package name, then add any other
          // bin name that aliases the package named bin


          if (pkg.json.bin && typeof pkg.json.bin === 'object') {
            const bins = Object.keys(pkg.json.bin);
            const primary = pkg.json.bin[pkg.json.name] || bins && pkg.json.bin[bins[0]];

            for (const [name, bin] of Object.entries(pkg.json.bin)) {
              if (bin !== primary && !aliases.includes(name)) {
                aliases.push(name);
              }
            }
          }

          this.registerExtension(name, {
            pkg
          }, {
            action: makeDefaultAction(pkg.main),
            aliases,
            desc: pkg.json.description
          });
        } else if (typeof pkg.json.exports !== 'object') {
          throw _errors.default.INVALID_EXTENSION('Invalid extension: Expected exports to be an object', {
            name: 'pkg.json.exports',
            scope: 'Extension.constructor',
            value: pkg.json.exports
          });
        } else {
          for (let [name, params] of Object.entries(pkg.json.exports)) {
            if (typeof params === 'string') {
              params = {
                main: params
              };
            }

            if (params.main && !_path2.default.isAbsolute(params.main)) {
              params.main = _path2.default.resolve(pkg.root, params.main);
            }

            this.registerExtension(name, {
              pkg: { ...pkg,
                ...params
              }
            }, {
              action: makeDefaultAction(params.main),
              desc: pkg.json.description,
              ...params
            });
          }
        }

        if (!Object.keys(this.exports).length) {
          throw _errors.default.INVALID_EXTENSION(`Invalid extension: Unable to find extension's main file: ${typeof path === 'string' ? `"${path}"` : JSON.stringify(path)}`);
        }
      } catch (e) {
        this.err = e;
        warn(e);
        warn('Found bad extension, creating error action');
        this.registerExtension(this.name, {}, {
          action: ({
            terminal
          }) => {
            const {
              stderr
            } = terminal;

            if (this.err) {
              let {
                stack
              } = e;
              const p = stack.indexOf('\n\n');

              if (p !== -1) {
                stack = stack.substring(0, p).trim();
              }

              for (const line of stack.split('\n')) {
                stderr.write(`  ${line}\n`);
              }
            } else {
              stderr.write(`Invalid extension: ${this.name}\n`);
            }
          }
        });
      }
    }

    (0, _util.declareCLIKitClass)(this, 'Extension'); // mix in any other custom props

    for (const [key, value] of Object.entries(params)) {
      if (!Object.prototype.hasOwnProperty.call(this, key)) {
        this[key] = value;
      }
    }
  }
  /**
   * Initializes a command with the extension export info.
   *
   * @param {String} name - The command name.
   * @param {Object} meta - Metadata to mix into the command instance.
   * @param {Object} params - Command specific constructor parameters.
   * @access private
   */


  registerExtension(name, meta, params) {
    var _meta$pkg, _meta$pkg$json$depend;

    log(`Registering extension command: ${highlight(`${this.name}:${name}`)}`);
    const cmd = new _command.default(name, {
      parent: this,
      ...params
    });
    this.exports[name] = Object.assign(cmd, meta);
    cmd.isExtension = true;
    cmd.isCLIKitExtension = !!(meta !== null && meta !== void 0 && (_meta$pkg = meta.pkg) !== null && _meta$pkg !== void 0 && _meta$pkg.clikit);

    if (!cmd.isCLIKitExtension || !((_meta$pkg$json$depend = meta.pkg.json.dependencies) !== null && _meta$pkg$json$depend !== void 0 && _meta$pkg$json$depend['cli-kit'])) {
      return;
    } // we only want to define `cmd.load()` if main exports a cli-kit object


    cmd.load = async function load() {
      log(`Requiring cli-kit extension: ${highlight(this.name)} -> ${highlight(meta.pkg.main)}`);
      let ctx;

      try {
        ctx = require(meta.pkg.main);

        if (!ctx || typeof ctx !== 'object' && typeof ctx !== 'function') {
          throw new Error('Extension must export an object or function');
        } // if this is an ES6 module, grab the default export


        if (ctx.__esModule) {
          ctx = ctx.default;
        } // if the export was a function, call it now to get its CLI definition


        if (typeof ctx === 'function') {
          ctx = await ctx(this);
        }

        if (!ctx || typeof ctx !== 'object') {
          throw new Error('Extension does not resolve an object');
        }
      } catch (err) {
        throw _errors.default.INVALID_EXTENSION(`Bad extension "${this.name}": ${err.message}`, {
          name: this.name,
          scope: 'Extension.load',
          value: err
        });
      }

      this.aliases = ctx.aliases;
      this.camelCase = ctx.camelCase;
      this.defaultCommand = ctx.defaultCommand;
      this.help = ctx.help;
      this.remoteHelp = ctx.remoteHelp;
      this.treatUnknownOptionsAsArguments = ctx.treatUnknownOptionsAsArguments;
      this.version = ctx.version;
      this.init({
        args: ctx.args,
        banner: ctx.banner,
        commands: ctx.commands,
        desc: ctx.desc || this.desc,
        extensions: ctx.extensions,
        name: this.name || ctx.name,
        options: ctx.options,
        parent: this.parent,
        title: ctx.title !== 'Global' && ctx.title || this.name
      });
      const versionOption = this.version && this.lookup.long.version;

      if (versionOption && typeof versionOption.callback !== 'function') {
        versionOption.callback = async ({
          exitCode,
          opts,
          next
        }) => {
          if (await next()) {
            let {
              version
            } = this;

            if (typeof version === 'function') {
              version = await version(opts);
            }

            (opts.terminal || this.get('terminal')).stdout.write(`${version}\n`);
            exitCode(0);
            return false;
          }
        };
      }

      if (typeof ctx.action === 'function') {
        this.action = ctx.action;
      } else {
        this.action = async parser => {
          if (this.defaultCommand !== 'help' || !this.get('help')) {
            const defcmd = this.defaultCommand && this.commands[this.defaultCommand];

            if (defcmd) {
              return await defcmd.action.call(defcmd, parser);
            }
          }

          return await _help.default.action.call(_help.default, parser);
        };
      }
    }.bind(cmd);
  }
  /**
   * Returns the schema for this extension and all child contexts.
   *
   * @returns {Object}
   * @access public
   */


  schema() {
    return { ...super.schema,
      path: this.path
    };
  }

}

exports.default = Extension;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcnNlci9leHRlbnNpb24uanMiXSwibmFtZXMiOlsibG9nIiwid2FybiIsImhpZ2hsaWdodCIsImRlYnVnIiwic3R5bGVzIiwibmFtZVJlZ0V4cCIsIkV4dGVuc2lvbiIsImNvbnN0cnVjdG9yIiwicGF0aE9yUGFyYW1zIiwicGFyYW1zIiwicGF0aCIsIkUiLCJJTlZBTElEX0FSR1VNRU5UIiwibmFtZSIsInNjb3BlIiwidmFsdWUiLCJleHBvcnRzIiwiZXhlIiwicmVnaXN0ZXJFeHRlbnNpb24iLCJhY3Rpb24iLCJfX2FyZ3YiLCJjbWQiLCJ0ZXJtaW5hbCIsIkFycmF5IiwiaXNBcnJheSIsIk5PX0VYRUNVVEFCTEUiLCJiaW4iLCJhcmdzIiwic2xpY2UiLCJwIiwiZmluZEluZGV4IiwiYXJnIiwidHlwZSIsImNvbW1hbmQiLCJpIiwibGVuIiwibGVuZ3RoIiwicHVzaCIsImFwcGx5IiwiaW5wdXQiLCJqb2luIiwiY2hpbGQiLCJ3aW5kb3dzSGlkZSIsInN0ZG91dCIsIm9uIiwiZGF0YSIsIndyaXRlIiwidG9TdHJpbmciLCJzdGRlcnIiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNvZGUiLCJkZXNjIiwiZSIsInBrZyIsInJvb3QiLCJFcnJvciIsIklOVkFMSURfRVhURU5TSU9OIiwiSlNPTiIsInN0cmluZ2lmeSIsImpzb24iLCJtYWtlRGVmYXVsdEFjdGlvbiIsIm1haW4iLCJwcm9jZXNzIiwiYXJndiIsImV4ZWNQYXRoIiwicmVxdWlyZSIsImFsaWFzZXMiLCJtIiwibWF0Y2giLCJpbmNsdWRlcyIsImJpbnMiLCJPYmplY3QiLCJrZXlzIiwicHJpbWFyeSIsImVudHJpZXMiLCJkZXNjcmlwdGlvbiIsIl9wYXRoIiwiaXNBYnNvbHV0ZSIsImVyciIsInN0YWNrIiwiaW5kZXhPZiIsInN1YnN0cmluZyIsInRyaW0iLCJsaW5lIiwic3BsaXQiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJtZXRhIiwiQ29tbWFuZCIsInBhcmVudCIsImFzc2lnbiIsImlzRXh0ZW5zaW9uIiwiaXNDTElLaXRFeHRlbnNpb24iLCJjbGlraXQiLCJkZXBlbmRlbmNpZXMiLCJsb2FkIiwiY3R4IiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJtZXNzYWdlIiwiY2FtZWxDYXNlIiwiZGVmYXVsdENvbW1hbmQiLCJoZWxwIiwicmVtb3RlSGVscCIsInRyZWF0VW5rbm93bk9wdGlvbnNBc0FyZ3VtZW50cyIsInZlcnNpb24iLCJpbml0IiwiYmFubmVyIiwiY29tbWFuZHMiLCJleHRlbnNpb25zIiwib3B0aW9ucyIsInRpdGxlIiwidmVyc2lvbk9wdGlvbiIsImxvb2t1cCIsImxvbmciLCJjYWxsYmFjayIsImV4aXRDb2RlIiwib3B0cyIsIm5leHQiLCJnZXQiLCJwYXJzZXIiLCJkZWZjbWQiLCJoZWxwQ29tbWFuZCIsImJpbmQiLCJzY2hlbWEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7OztBQUVBLE1BQU07QUFBRUEsRUFBQUEsR0FBRjtBQUFPQyxFQUFBQTtBQUFQLElBQWdCLG9CQUFNLG1CQUFOLENBQXRCO0FBQ0EsTUFBTTtBQUFFQyxFQUFBQTtBQUFGLElBQWdCQyxlQUFNQyxNQUE1QjtBQUVBLE1BQU1DLFVBQVUsR0FBRyxxQkFBbkI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNlLE1BQU1DLFNBQU4sQ0FBZ0I7QUFDOUI7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0NDLEVBQUFBLFdBQVcsQ0FBQ0MsWUFBRCxFQUFlQyxNQUFmLEVBQXVCO0FBQ2pDLFFBQUlDLElBQUksR0FBR0YsWUFBWDs7QUFFQSxRQUFJLE9BQU9FLElBQVAsS0FBZ0IsUUFBaEIsSUFBNEIsQ0FBQ0QsTUFBakMsRUFBeUM7QUFDeENBLE1BQUFBLE1BQU0sR0FBRyxFQUFUO0FBQ0EsS0FGRCxNQUVPLElBQUlE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Q3pHLE1BQVAsQ0FBY3NFLElBQWQsQ0FBbUJtQyxNQUFuQixFQUEyQkQsTUFBM0IsQ0FBYjtBQUNBO0FBQ0Q7O0FBQ0QsaUJBQU8sTUFBTUUsY0FBWTFHLE1BQVosQ0FBbUJzRSxJQUFuQixDQUF3Qm9DLGFBQXhCLEVBQXFDRixNQUFyQyxDQUFiO0FBQ0EsU0FSRDtBQVNBO0FBQ0QsS0F6RVUsQ0F5RVRHLElBekVTLENBeUVKekcsR0F6RUksQ0FBWDtBQTBFQTtBQUVEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0MwRyxFQUFBQSxNQUFNLEdBQUc7QUFDUixXQUFPLEVBQ04sR0FBRyxNQUFNQSxNQURIO0FBRU5ySCxNQUFBQSxJQUFJLEVBQUUsS0FBS0E7QUFGTCxLQUFQO0FBSUE7O0FBalU2QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb21tYW5kIGZyb20gJy4vY29tbWFuZCc7XG5pbXBvcnQgZGVidWcgZnJvbSAnLi4vbGliL2RlYnVnJztcbmltcG9ydCBFIGZyb20gJy4uL2xpYi9lcnJvcnMnO1xuaW1wb3J0IGhlbHBDb21tYW5kIGZyb20gJy4uL2NvbW1hbmRzL2hlbHAnO1xuaW1wb3J0IF9wYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyBkZWNsYXJlQ0xJS2l0Q2xhc3MsIGZpbGVuYW1lLCBmaW5kUGFja2FnZSwgaXNFeGVjdXRhYmxlIH0gZnJvbSAnLi4vbGliL3V0aWwnO1xuaW1wb3J0IHsgc3Bhd24gfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcblxuY29uc3QgeyBsb2csIHdhcm4gfSA9IGRlYnVnKCdjbGkta2l0OmV4dGVuc2lvbicpO1xuY29uc3QgeyBoaWdobGlnaHQgfSA9IGRlYnVnLnN0eWxlcztcblxuY29uc3QgbmFtZVJlZ0V4cCA9IC9eKD86KEBcXHcrKVxcLyk/KC4qKSQvO1xuXG4vKipcbiAqIERlZmluZXMgYSBuYW1lc3BhY2UgdGhhdCB3cmFwcyBhbiBleHRlcm5hbCBwcm9ncmFtIG9yIHNjcmlwdC5cbiAqXG4gKiBAZXh0ZW5kcyB7Q29tbWFuZH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXh0ZW5zaW9uIHtcblx0LyoqXG5cdCAqIERldGVjdHMgdGhlIGV4dGVuc2lvbiBkZWZpbmVkIGluIHRoZSBzcGVjaWZpZWQgcGF0aCBhbmQgaW5pdGlhbGl6ZXMgaXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcGF0aE9yUGFyYW1zIC0gVGhlIHBhdGggdG8gdGhlIGV4dGVuc2lvbiBvciBhIHBhcmFtcyBvYmplY3QuIElmIHRoZVxuXHQgKiBwYXRoIGlzIGEgTm9kZS5qcyBwYWNrYWdlIHdpdGggYSBgcGFja2FnZS5qc29uYCBjb250YWluaW5nIGEgYFwiY2xpLWtpdFwiYCBwcm9wZXJ0eSwgaXQgd2lsbFxuXHQgKiBtZXJnZSB0aGUgZXh0ZXJuYWwgY2xpLWtpdCBjb250ZXh0IHRyZWUgaW50byB0aGlzIG5hbWVzcGFjZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gVmFyaW91cyBwYXJhbWV0ZXJzIHdoZW4gYGV4dGVuc2lvblBhdGhgIGlzIGEgYFN0cmluZ2AuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zLmV4cG9ydHNdIC0gQSBtYXAgb2YgZXhwb3J0ZWQgY29tbWFuZCBuYW1lcyB0byBkZXNjcmlwdG9ycyBjb250YWluaW5nXG5cdCAqIGBhbGlhc2VzYCwgYGRlc2NgLCBgZXhlYCwgYG1haW5gLCBhbmQgYG5hbWVgIHByb3BzLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5uYW1lXSAtIFRoZSBleHRlbnNpb24gbmFtZS4gSWYgbm90IHNldCwgaXQgd2lsbCBsb2FkIGl0IGZyb20gdGhlXG5cdCAqIGV4dGVuc2lvbidzIGBwYWNrYWdlLmpzb25gIG9yIHRoZSBmaWxlbmFtZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMucGF0aF0gLSBUaGUgcGF0aCB0byBhbiBleGVjdXRhYmxlLCBhIEphdmFTY3JpcHQgZmlsZSwgb3IgTm9kZS5qc1xuXHQgKiBwYWNrYWdlLlxuXHQgKiBAYWNjZXNzIHB1YmxpY1xuXHQgKi9cblx0Y29uc3RydWN0b3IocGF0aE9yUGFyYW1zLCBwYXJhbXMpIHtcblx0XHRsZXQgcGF0aCA9IHBhdGhPclBhcmFtcztcblxuXHRcdGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgJiYgIXBhcmFtcykge1xuXHRcdFx0cGFyYW1zID0ge307XG5cdFx0fSBlbHNlIGlmIChwYXRoT3JQYXJhbXMgJiYgdHlwZW9mIHBhdGhPclBhcmFtcyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdCh7IHBhdGggfSA9IHBhcmFtcyA9IHBhdGhPclBhcmFtcyk7XG5cdFx0fVxuXG5cdFx0aWYgKCFwYXRoIHx8IHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuXHRcdFx0dGhyb3cgRS5JTlZBTElEX0FSR1VNRU5UKCdFeHBlY3RlZCBhbiBleHRlbnNpb24gcGF0aCBvciBwYXJhbXMgb2JqZWN0JywgeyBuYW1lOiAncGF0aE9yUGFyYW1zJywgc2NvcGU6ICdFeHRlbnNpb24uY29uc3RydWN0b3InLCB2YWx1ZTogcGF0aE9yUGFyYW1zIH0pO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgcGFyYW1zICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0dGhyb3cgRS5JTlZBTElEX0FSR1VNRU5UKCdFeHBlY3RlZCBleHRlbnNpb24gcGFyYW1zIHRvIGJlIGFuIG9iamVjdCBvciBDb250ZXh0JywgeyBuYW1lOiAncGFyYW1zJywgc2NvcGU6ICdFeHRlbnNpb24uY29uc3RydWN0b3InLCB2YWx1ZTogcGFyYW1zIH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuZXhwb3J0cyA9IHBhcmFtcy5leHBvcnRzIHx8IHt9O1xuXHRcdHRoaXMubmFtZSA9IHBhcmFtcy5uYW1lO1xuXHRcdHRoaXMucGF0aCA9IHBhdGg7XG5cblx0XHRpZiAodHlwZW9mIHRoaXMuZXhwb3J0cyAhPT0gJ29iamVjdCcpIHtcblx0XHRcdHRocm93IEUuSU5WQUxJRF9BUkdVTUVOVCgnRXhwZWN0ZWQgZXh0ZW5zaW9uIGV4cG9ydHMgdG8gYmUgYW4gb2JqZWN0JywgeyBuYW1lOiAncGFyYW1zLmV4cG9ydHMnLCBzY29wZTogJ0V4dGVuc2lvbi5jb25zdHJ1Y3RvcicsIHZhbHVlOiBwYXJhbXMuZXhwb3J0cyB9KTtcblx0XHR9XG5cblx0XHQvLyB3ZSBuZWVkIHRvIGRldGVybWluZSBpZiB0aGlzIGV4dGVuc2lvbiBpcyBhIGJpbmFyeSBvciBpZiBpdCdzIGEgTm9kZSBwYWNrYWdlXG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGV4ZSA9IGlzRXhlY3V0YWJsZShwYXRoKTtcblx0XHRcdGlmICghdGhpcy5uYW1lKSB7XG5cdFx0XHRcdHRoaXMubmFtZSA9IGZpbGVuYW1lKGV4ZVswXSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMucmVnaXN0ZXJFeHRlbnNpb24odGhpcy5uYW1lLCB7IGV4ZSB9LCB7XG5cdFx0XHRcdGFjdGlvbjogYXN5bmMgKHsgX19hcmd2LCBjbWQsIHRlcm1pbmFsIH0pID0+IHtcblx0XHRcdFx0XHRpZiAoIUFycmF5LmlzQXJyYXkoZXhlKSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgRS5OT19FWEVDVVRBQkxFKGBFeHRlbnNpb24gXCIke3RoaXMubmFtZX1cIiBoYXMgbm8gZXhlY3V0YWJsZSFgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCBiaW4gPSBleGVbMF07XG5cdFx0XHRcdFx0Y29uc3QgYXJncyA9IGV4ZS5zbGljZSgxKTtcblx0XHRcdFx0XHRjb25zdCBwID0gX19hcmd2LmZpbmRJbmRleChhcmcgPT4gYXJnICYmIGFyZy50eXBlID09PSAnZXh0ZW5zaW9uJyAmJiBhcmcuY29tbWFuZCA9PT0gY21kKTtcblxuXHRcdFx0XHRcdGlmIChwICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IHAgKyAxLCBsZW4gPSBfX2FyZ3YubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0YXJncy5wdXNoLmFwcGx5KGFyZ3MsIF9fYXJndltpXS5pbnB1dCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gc3Bhd24gdGhlIHByb2Nlc3Ncblx0XHRcdFx0XHRsb2coYFJ1bm5pbmc6ICR7aGlnaGxpZ2h0KGAke2Jpbn0gJHthcmdzLmpvaW4oJyAnKX1gKX1gKTtcblx0XHRcdFx0XHRjb25zdCBjaGlsZCA9IHNwYXduKGJpbiwgYXJncywgeyB3aW5kb3dzSGlkZTogdHJ1ZSB9KTtcblx0XHRcdFx0XHRjaGlsZC5zdGRvdXQub24oJ2RhdGEnLCBkYXRhID0+IHRlcm1pbmFsLnN0ZG91dC53cml0ZShkYXRhLnRvU3RyaW5nKCkpKTtcblx0XHRcdFx0XHRjaGlsZC5zdGRlcnIub24oJ2RhdGEnLCBkYXRhID0+IHRlcm1pbmFsLnN0ZGVyci53cml0ZShkYXRhLnRvU3RyaW5nKCkpKTtcblx0XHRcdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IGNoaWxkLm9uKCdjbG9zZScsIChjb2RlID0gMCkgPT4gcmVzb2x2ZSh7IGNvZGUgfSkpKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZGVzYzogcGFyYW1zLmRlc2Ncblx0XHRcdH0pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vIG1heWJlIGEgTm9kZSBwYWNrYWdlP1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0bGV0IHBrZztcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwa2cgPSBmaW5kUGFja2FnZShwYXRoKTtcblx0XHRcdFx0XHRpZiAoIXBrZy5yb290KSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHR0aHJvdyBFLklOVkFMSURfRVhURU5TSU9OKGBJbnZhbGlkIGV4dGVuc2lvbjogVW5hYmxlIHRvIGZpbmQgZXhlY3V0YWJsZSwgc2NyaXB0LCBvciBwYWNrYWdlOiAke3R5cGVvZiBwYXRoID09PSAnc3RyaW5nJyA/IGBcIiR7cGF0aH1cImAgOiBKU09OLnN0cmluZ2lmeShwYXRoKX1gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghdGhpcy5uYW1lKSB7XG5cdFx0XHRcdFx0dGhpcy5uYW1lID0gcGtnLmpzb24ubmFtZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghdGhpcy5uYW1lKSB7XG5cdFx0XHRcdFx0dGhpcy5uYW1lID0gZmlsZW5hbWUocGF0aCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBtYWtlRGVmYXVsdEFjdGlvbiA9IG1haW4gPT4ge1xuXHRcdFx0XHRcdHJldHVybiBhc3luYyAoeyBfX2FyZ3YsIGNtZCB9KSA9PiB7XG5cdFx0XHRcdFx0XHRwcm9jZXNzLmFyZ3YgPSBbXG5cdFx0XHRcdFx0XHRcdHByb2Nlc3MuZXhlY1BhdGgsXG5cdFx0XHRcdFx0XHRcdG1haW5cblx0XHRcdFx0XHRcdF07XG5cblx0XHRcdFx0XHRcdGNvbnN0IHAgPSBfX2FyZ3YuZmluZEluZGV4KGFyZyA9PiBhcmcgJiYgYXJnLnR5cGUgPT09ICdleHRlbnNpb24nICYmIGFyZy5jb21tYW5kID09PSBjbWQpO1xuXHRcdFx0XHRcdFx0aWYgKHAgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSBwICsgMSwgbGVuID0gX19hcmd2Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5hcmd2LnB1c2guYXBwbHkocHJvY2Vzcy5hcmd2LCBfX2FyZ3ZbaV0uaW5wdXQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGxvZyhgUmVxdWlyaW5nICR7aGlnaGxpZ2h0KG1haW4pfWApO1xuXHRcdFx0XHRcdFx0bG9nKGBBcmdzOiAke2hpZ2hsaWdodChwcm9jZXNzLmFyZ3Yuam9pbignICcpKX1gKTtcblx0XHRcdFx0XHRcdHJlcXVpcmUobWFpbik7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZiAoIXBrZy5qc29uLmV4cG9ydHMgJiYgcGtnLm1haW4pIHtcblx0XHRcdFx0XHQvLyBsZWdhY3kgTm9kZS5qcyBleHRlbnNpb25cblx0XHRcdFx0XHRsZXQgeyBuYW1lIH0gPSB0aGlzO1xuXHRcdFx0XHRcdGNvbnN0IGFsaWFzZXMgPSBBcnJheS5pc0FycmF5KHBrZy5qc29uLmFsaWFzZXMpID8gcGtnLmpzb24uYWxpYXNlcyA6IFtdO1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlIHBhY2thZ2UgbmFtZSBjb250YWlucyBhIHNjb3BlLCBhZGQgdGhlIHNjb3BlZCBwYWNrYWdlIG5hbWUgYXMgYSBoaWRkZW5cblx0XHRcdFx0XHQvLyBhbGlhcyBhbmQgc3RyaXAgdGhlIHNjb3BlIGZyb20gdGhlIG5hbWVcblx0XHRcdFx0XHRjb25zdCBtID0gbmFtZS5tYXRjaChuYW1lUmVnRXhwKTtcblx0XHRcdFx0XHRpZiAobSkge1xuXHRcdFx0XHRcdFx0YWxpYXNlcy5wdXNoKGAhJHtuYW1lfWApO1xuXHRcdFx0XHRcdFx0bmFtZSA9IG1bMl07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlIG5hbWUgaXMgZGlmZmVyZW50IHRoYW4gdGhlIG9uZSBpbiB0aGUgcGFja2FnZS5qc29uLCBhZGQgaXQgdG8gdGhlIGFsaWFzZXNcblx0XHRcdFx0XHRpZiAobmFtZSAmJiBuYW1lICE9PSBwa2cuanNvbi5uYW1lICYmICFhbGlhc2VzLmluY2x1ZGVzKG5hbWUpKSB7XG5cdFx0XHRcdFx0XHRhbGlhc2VzLnB1c2gobmFtZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlIHBhY2thZ2UgaGFzIGEgYmluIHNjcmlwdCB0aGF0IG1hdGNoZXMgdGhlIHBhY2thZ2UgbmFtZSwgdGhlbiBhZGQgYW55IG90aGVyXG5cdFx0XHRcdFx0Ly8gYmluIG5hbWUgdGhhdCBhbGlhc2VzIHRoZSBwYWNrYWdlIG5hbWVkIGJpblxuXHRcdFx0XHRcdGlmIChwa2cuanNvbi5iaW4gJiYgdHlwZW9mIHBrZy5qc29uLmJpbiA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGJpbnMgPSBPYmplY3Qua2V5cyhwa2cuanNvbi5iaW4pO1xuXHRcdFx0XHRcdFx0Y29uc3QgcHJpbWFyeSA9IHBrZy5qc29uLmJpbltwa2cuanNvbi5uYW1lXSB8fCAoYmlucyAmJiBwa2cuanNvbi5iaW5bYmluc1swXV0pO1xuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBbIG5hbWUsIGJpbiBdIG9mIE9iamVjdC5lbnRyaWVzKHBrZy5qc29uLmJpbikpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGJpbiAhPT0gcHJpbWFyeSAmJiAhYWxpYXNlcy5pbmNsdWRlcyhuYW1lKSkge1xuXHRcdFx0XHRcdFx0XHRcdGFsaWFzZXMucHVzaChuYW1lKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMucmVnaXN0ZXJFeHRlbnNpb24obmFtZSwgeyBwa2cgfSwge1xuXHRcdFx0XHRcdFx0YWN0aW9uOiBtYWtlRGVmYXVsdEFjdGlvbihwa2cubWFpbiksXG5cdFx0XHRcdFx0XHRhbGlhc2VzLFxuXHRcdFx0XHRcdFx0ZGVzYzogcGtnLmpzb24uZGVzY3JpcHRpb25cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgcGtnLmpzb24uZXhwb3J0cyAhPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHR0aHJvdyBFLklOVkFMSURfRVhURU5TSU9OKCdJbnZhbGlkIGV4dGVuc2lvbjogRXhwZWN0ZWQgZXhwb3J0cyB0byBiZSBhbiBvYmplY3QnLCB7IG5hbWU6ICdwa2cuanNvbi5leHBvcnRzJywgc2NvcGU6ICdFeHRlbnNpb24uY29uc3RydWN0b3InLCB2YWx1ZTogcGtnLmpzb24uZXhwb3J0cyB9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKGxldCBbIG5hbWUsIHBhcmFtcyBdIG9mIE9iamVjdC5lbnRyaWVzKHBrZy5qc29uLmV4cG9ydHMpKSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdFx0cGFyYW1zID0geyBtYWluOiBwYXJhbXMgfTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChwYXJhbXMubWFpbiAmJiAhX3BhdGguaXNBYnNvbHV0ZShwYXJhbXMubWFpbikpIHtcblx0XHRcdFx0XHRcdFx0cGFyYW1zLm1haW4gPSBfcGF0aC5yZXNvbHZlKHBrZy5yb290LCBwYXJhbXMubWFpbik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLnJlZ2lzdGVyRXh0ZW5zaW9uKG5hbWUsIHtcblx0XHRcdFx0XHRcdFx0cGtnOiB7XG5cdFx0XHRcdFx0XHRcdFx0Li4ucGtnLFxuXHRcdFx0XHRcdFx0XHRcdC4uLnBhcmFtc1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCB7XG5cdFx0XHRcdFx0XHRcdGFjdGlvbjogbWFrZURlZmF1bHRBY3Rpb24ocGFyYW1zLm1haW4pLFxuXHRcdFx0XHRcdFx0XHRkZXNjOiBwa2cuanNvbi5kZXNjcmlwdGlvbixcblx0XHRcdFx0XHRcdFx0Li4ucGFyYW1zXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIU9iamVjdC5rZXlzKHRoaXMuZXhwb3J0cykubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dGhyb3cgRS5JTlZBTElEX0VYVEVOU0lPTihgSW52YWxpZCBleHRlbnNpb246IFVuYWJsZSB0byBmaW5kIGV4dGVuc2lvbidzIG1haW4gZmlsZTogJHt0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgPyBgXCIke3BhdGh9XCJgIDogSlNPTi5zdHJpbmdpZnkocGF0aCl9YCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0dGhpcy5lcnIgPSBlO1xuXHRcdFx0XHR3YXJuKGUpO1xuXHRcdFx0XHR3YXJuKCdGb3VuZCBiYWQgZXh0ZW5zaW9uLCBjcmVhdGluZyBlcnJvciBhY3Rpb24nKTtcblxuXHRcdFx0XHR0aGlzLnJlZ2lzdGVyRXh0ZW5zaW9uKHRoaXMubmFtZSwge30sIHtcblx0XHRcdFx0XHRhY3Rpb246ICh7IHRlcm1pbmFsIH0pID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IHsgc3RkZXJyIH0gPSB0ZXJtaW5hbDtcblx0XHRcdFx0XHRcdGlmICh0aGlzLmVycikge1xuXHRcdFx0XHRcdFx0XHRsZXQgeyBzdGFjayB9ID0gZTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgcCA9IHN0YWNrLmluZGV4T2YoJ1xcblxcbicpO1xuXHRcdFx0XHRcdFx0XHRpZiAocCAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHRzdGFjayA9IHN0YWNrLnN1YnN0cmluZygwLCBwKS50cmltKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Zm9yIChjb25zdCBsaW5lIG9mIHN0YWNrLnNwbGl0KCdcXG4nKSkge1xuXHRcdFx0XHRcdFx0XHRcdHN0ZGVyci53cml0ZShgICAke2xpbmV9XFxuYCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHN0ZGVyci53cml0ZShgSW52YWxpZCBleHRlbnNpb246ICR7dGhpcy5uYW1lfVxcbmApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZGVjbGFyZUNMSUtpdENsYXNzKHRoaXMsICdFeHRlbnNpb24nKTtcblxuXHRcdC8vIG1peCBpbiBhbnkgb3RoZXIgY3VzdG9tIHByb3BzXG5cdFx0Zm9yIChjb25zdCBbIGtleSwgdmFsdWUgXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKSB7XG5cdFx0XHRpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBrZXkpKSB7XG5cdFx0XHRcdHRoaXNba2V5XSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyBhIGNvbW1hbmQgd2l0aCB0aGUgZXh0ZW5zaW9uIGV4cG9ydCBpbmZvLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBjb21tYW5kIG5hbWUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhIC0gTWV0YWRhdGEgdG8gbWl4IGludG8gdGhlIGNvbW1hbmQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBDb21tYW5kIHNwZWNpZmljIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMuXG5cdCAqIEBhY2Nlc3MgcHJpdmF0ZVxuXHQgKi9cblx0cmVnaXN0ZXJFeHRlbnNpb24obmFtZSwgbWV0YSwgcGFyYW1zKSB7XG5cdFx0bG9nKGBSZWdpc3RlcmluZyBleHRlbnNpb24gY29tbWFuZDogJHtoaWdobGlnaHQoYCR7dGhpcy5uYW1lfToke25hbWV9YCl9YCk7XG5cdFx0Y29uc3QgY21kID0gbmV3IENvbW1hbmQobmFtZSwge1xuXHRcdFx0cGFyZW50OiB0aGlzLFxuXHRcdFx0Li4ucGFyYW1zXG5cdFx0fSk7XG5cdFx0dGhpcy5leHBvcnRzW25hbWVdID0gT2JqZWN0LmFzc2lnbihjbWQsIG1ldGEpO1xuXHRcdGNtZC5pc0V4dGVuc2lvbiA9IHRydWU7XG5cdFx0Y21kLmlzQ0xJS2l0RXh0ZW5zaW9uID0gISFtZXRhPy5wa2c/LmNsaWtpdDtcblxuXHRcdGlmICghY21kLmlzQ0xJS2l0RXh0ZW5zaW9uIHx8ICFtZXRhLnBrZy5qc29uLmRlcGVuZGVuY2llcz8uWydjbGkta2l0J10pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyB3ZSBvbmx5IHdhbnQgdG8gZGVmaW5lIGBjbWQubG9hZCgpYCBpZiBtYWluIGV4cG9ydHMgYSBjbGkta2l0IG9iamVjdFxuXG5cdFx0Y21kLmxvYWQgPSBhc3luYyBmdW5jdGlvbiBsb2FkKCkge1xuXHRcdFx0bG9nKGBSZXF1aXJpbmcgY2xpLWtpdCBleHRlbnNpb246ICR7aGlnaGxpZ2h0KHRoaXMubmFtZSl9IC0+ICR7aGlnaGxpZ2h0KG1ldGEucGtnLm1haW4pfWApO1xuXHRcdFx0bGV0IGN0eDtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGN0eCA9IHJlcXVpcmUobWV0YS5wa2cubWFpbik7XG5cdFx0XHRcdGlmICghY3R4IHx8ICh0eXBlb2YgY3R4ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgY3R4ICE9PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXh0ZW5zaW9uIG11c3QgZXhwb3J0IGFuIG9iamVjdCBvciBmdW5jdGlvbicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgdGhpcyBpcyBhbiBFUzYgbW9kdWxlLCBncmFiIHRoZSBkZWZhdWx0IGV4cG9ydFxuXHRcdFx0XHRpZiAoY3R4Ll9fZXNNb2R1bGUpIHtcblx0XHRcdFx0XHRjdHggPSBjdHguZGVmYXVsdDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIHRoZSBleHBvcnQgd2FzIGEgZnVuY3Rpb24sIGNhbGwgaXQgbm93IHRvIGdldCBpdHMgQ0xJIGRlZmluaXRpb25cblx0XHRcdFx0aWYgKHR5cGVvZiBjdHggPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjdHggPSBhd2FpdCBjdHgodGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFjdHggfHwgdHlwZW9mIGN0eCAhPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0V4dGVuc2lvbiBkb2VzIG5vdCByZXNvbHZlIGFuIG9iamVjdCcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0dGhyb3cgRS5JTlZBTElEX0VYVEVOU0lPTihgQmFkIGV4dGVuc2lvbiBcIiR7dGhpcy5uYW1lfVwiOiAke2Vyci5tZXNzYWdlfWAsIHsgbmFtZTogdGhpcy5uYW1lLCBzY29wZTogJ0V4dGVuc2lvbi5sb2FkJywgdmFsdWU6IGVyciB9KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5hbGlhc2VzICAgICAgICAgICAgICAgICAgICAgICAgPSBjdHguYWxpYXNlcztcblx0XHRcdHRoaXMuY2FtZWxDYXNlICAgICAgICAgICAgICAgICAgICAgID0gY3R4LmNhbWVsQ2FzZTtcblx0XHRcdHRoaXMuZGVmYXVsdENvbW1hbmQgICAgICAgICAgICAgICAgID0gY3R4LmRlZmF1bHRDb21tYW5kO1xuXHRcdFx0dGhpcy5oZWxwICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBjdHguaGVscDtcblx0XHRcdHRoaXMucmVtb3RlSGVscCAgICAgICAgICAgICAgICAgICAgID0gY3R4LnJlbW90ZUhlbHA7XG5cdFx0XHR0aGlzLnRyZWF0VW5rbm93bk9wdGlvbnNBc0FyZ3VtZW50cyA9IGN0eC50cmVhdFVua25vd25PcHRpb25zQXNBcmd1bWVudHM7XG5cdFx0XHR0aGlzLnZlcnNpb24gICAgICAgICAgICAgICAgICAgICAgICA9IGN0eC52ZXJzaW9uO1xuXG5cdFx0XHR0aGlzLmluaXQoe1xuXHRcdFx0XHRhcmdzOiAgICAgICBjdHguYXJncyxcblx0XHRcdFx0YmFubmVyOiAgICAgY3R4LmJhbm5lcixcblx0XHRcdFx0Y29tbWFuZHM6ICAgY3R4LmNvbW1hbmRzLFxuXHRcdFx0XHRkZXNjOiAgICAgICBjdHguZGVzYyB8fCB0aGlzLmRlc2MsXG5cdFx0XHRcdGV4dGVuc2lvbnM6IGN0eC5leHRlbnNpb25zLFxuXHRcdFx0XHRuYW1lOiAgICAgICB0aGlzLm5hbWUgfHwgY3R4Lm5hbWUsXG5cdFx0XHRcdG9wdGlvbnM6ICAgIGN0eC5vcHRpb25zLFxuXHRcdFx0XHRwYXJlbnQ6ICAgICB0aGlzLnBhcmVudCxcblx0XHRcdFx0dGl0bGU6ICAgICAgY3R4LnRpdGxlICE9PSAnR2xvYmFsJyAmJiBjdHgudGl0bGUgfHwgdGhpcy5uYW1lXG5cdFx0XHR9KTtcblxuXHRcdFx0Y29uc3QgdmVyc2lvbk9wdGlvbiA9IHRoaXMudmVyc2lvbiAmJiB0aGlzLmxvb2t1cC5sb25nLnZlcnNpb247XG5cdFx0XHRpZiAodmVyc2lvbk9wdGlvbiAmJiB0eXBlb2YgdmVyc2lvbk9wdGlvbi5jYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR2ZXJzaW9uT3B0aW9uLmNhbGxiYWNrID0gYXN5bmMgKHsgZXhpdENvZGUsIG9wdHMsIG5leHQgfSkgPT4ge1xuXHRcdFx0XHRcdGlmIChhd2FpdCBuZXh0KCkpIHtcblx0XHRcdFx0XHRcdGxldCB7IHZlcnNpb24gfSA9IHRoaXM7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHZlcnNpb24gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdFx0dmVyc2lvbiA9IGF3YWl0IHZlcnNpb24ob3B0cyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQob3B0cy50ZXJtaW5hbCB8fCB0aGlzLmdldCgndGVybWluYWwnKSkuc3Rkb3V0LndyaXRlKGAke3ZlcnNpb259XFxuYCk7XG5cdFx0XHRcdFx0XHRleGl0Q29kZSgwKTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgY3R4LmFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR0aGlzLmFjdGlvbiA9IGN0eC5hY3Rpb247XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmFjdGlvbiA9IGFzeW5jIHBhcnNlciA9PiB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuZGVmYXVsdENvbW1hbmQgIT09ICdoZWxwJyB8fCAhdGhpcy5nZXQoJ2hlbHAnKSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgZGVmY21kID0gdGhpcy5kZWZhdWx0Q29tbWFuZCAmJiB0aGlzLmNvbW1hbmRzW3RoaXMuZGVmYXVsdENvbW1hbmRdO1xuXHRcdFx0XHRcdFx0aWYgKGRlZmNtZCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYXdhaXQgZGVmY21kLmFjdGlvbi5jYWxsKGRlZmNtZCwgcGFyc2VyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGF3YWl0IGhlbHBDb21tYW5kLmFjdGlvbi5jYWxsKGhlbHBDb21tYW5kLCBwYXJzZXIpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH0uYmluZChjbWQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHNjaGVtYSBmb3IgdGhpcyBleHRlbnNpb24gYW5kIGFsbCBjaGlsZCBjb250ZXh0cy5cblx0ICpcblx0ICogQHJldHVybnMge09iamVjdH1cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICovXG5cdHNjaGVtYSgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Li4uc3VwZXIuc2NoZW1hLFxuXHRcdFx0cGF0aDogdGhpcy5wYXRoXG5cdFx0fTtcblx0fVxufVxuIl0sImZpbGUiOiJwYXJzZXIvZXh0ZW5zaW9uLmpzIn0=
