"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _argumentList = _interopRequireDefault(require("./argument-list"));

var _commandMap = _interopRequireDefault(require("./command-map"));

var _debug = _interopRequireDefault(require("../lib/debug"));

var _errors = _interopRequireDefault(require("../lib/errors"));

var _extensionMap = _interopRequireDefault(require("./extension-map"));

var _hookEmitter = _interopRequireDefault(require("hook-emitter"));

var _lookup = _interopRequireDefault(require("./lookup"));

var _optionMap = _interopRequireDefault(require("./option-map"));

var _path = _interopRequireDefault(require("path"));

var _util = require("../lib/util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const {
  error,
  log
} = (0, _debug.default)('cli-kit:context');
const {
  highlight,
  note
} = _debug.default.styles;
/**
 * Defines a context that contains commands, options, and args. Serves as the
 * base class for `CLI` and `Context` objects.
 *
 * @extends {HookEmitter}
 */

class Context extends _hookEmitter.default {
  /**
   * Constructs a context instance.
   *
   * @param {Object|Context} [params] - Various parameters.
   * @param {Object|String|Argument|ArgumentList|Array<Object|String|Argument>} [params.args] -
   * An object of argument names to argument descriptors, an argument name, an `Argument`
   * instance, an `ArgumentList` instance, or array of object descriptors, argument names, and
   * `Argument` instances.
   * @param {Boolean} [params.camelCase=true] - Camel case option names.
   * @param {Object|String|Command|CommandMap|Array.<Object|String|Command>} [params.commands] -
   * An object used for `Command` constructor params, a path to a directory or a `.js` file, a
   * `Command` instance, or an array of those types. May also be a `CommandMap` instance. If
   * `cmd` is a `String` and `params` is present, then it will treat `cmd` as the command name,
   * not a file path.
   * @param {String} [params.desc] - The description of the CLI or command displayed in the help
   * output. If context is a command with a help header defined, this description is not
   * displayed.
   * @param {Object|String|Extension|ExtensionMap|Array.<String|Extension>} [params.extensions] -
   * An object of extension names to extension paths or instances, an extension path, an
   * `Extension` instance, or an array of those types. An extension path may be a directory
   * containing a Node.js module, a path to a `.js` file, or the name of a executable. May also
   * be an `ExtensionMap` instance.
   * @param {String|Function|Object} [params.help] - Additional help content to display on the
   * help screen. When may be an object with the properties `header` and `footer` which values
   * that are either a string or an async function that resolves a string. When value is a string
   * or function, it is trasnformed into a object with the value being used as the header. Note
   * that the command description is not displayed when a header message has been defined.
   * @param {String} [params.name] - The name of the context such as the program or the command
   * name.
   * @param {Object|Option|OptionMap|Array<Object|Option|String>} [params.options] - An object of
   * format to `Option` constructor params, an `Option` instance, or an array of `Option`
   * constructor params and `Option` instances grouped by `String` labels.
   * @param {Context} [params.parent] - The parent context.
   * @param {String} [params.title] - The context title.
   * @param {Boolean} [params.treatUnknownOptionsAsArguments=false] - When `true`, any argument is
   * encountered during parsing that resembles a option that does not exist, it will add it
   * untouched to `_` as an argument as well as to `argv` as a boolean flag. When `false`, it will
   * only add the argument to `argv` as a boolean flag.
   * @access public
   */
  constructor(params = {}) {
    super();
    (0, _util.declareCLIKitClass)(this, 'Context');
    this.init(params);
  }
  /**
   * Adds an argument to this context.
   *
   * @param {Object|String|Argument|ArgumentList|Array<Object|String|Argument>} arg - An object
   * of argument names to argument descriptors, an argument name, an `Argument` instance, an
   * `ArgumentList` instance, or array of object descriptors, argument names, and `Argument`
   * instances.
   * @returns {Context}
   * @access public
   */


  argument(arg) {
    this.args.add(arg);
    this.rev++;
    return this;
  }
  /**
   * Adds a command to this context.
   *
   * @param {Object|String|Command|CommandMap|Array.<Object|String|Command>} cmd - An object
   * used for `Command` constructor params, a path to a directory or a `.js` file, a `Command`
   * instance, or an array of those types. May also be a `CommandMap` instance. If `cmd` is a
   * `String` and `params` is present, then it will treat `cmd` as the command name, not a file
   * path.
   * @param {Object} [params] - When `cmd` is the command name, then this is the options to pass
   * into the `Command` constructor.
   * @param {Boolean} [clone] - When `true` and `params` is a `Command` or `CommandMap`, it will
   * clone the `Command` instead of set by reference.
   * @returns {Context}
   * @access public
   */


  command(cmd, params, clone) {
    const cmds = this.commands.add(cmd, params, clone);

    for (const cmd of cmds) {
      log(`Adding command: ${highlight(cmd.name)} ${note(`(${this.name})`)}`);
      this.register(cmd);
    }

    this.rev++;
    return this;
  }
  /**
   * Finds the top most context, then emits the event on it and its extensions.
   *
   * @param {String} event - The event name.
   * @param {Object} [data] - Optional event data.
   * @returns {Promise}
   */


  async emitAction(event, data) {
    // find top-most context
    let ctx = this;

    while (ctx.parent) {
      await this.emit(event, data);
      ctx = ctx.parent;
    }

    log(`Emitting action: ${highlight(event)}`);
    await ctx.emit(event, data);

    for (const ext of ctx.extensions.values()) {
      for (const cmd of Object.values(ext.exports)) {
        var _cmd$pkg, _cmd$pkg$json;

        const actions = (_cmd$pkg = cmd.pkg) === null || _cmd$pkg === void 0 ? void 0 : (_cmd$pkg$json = _cmd$pkg.json) === null || _cmd$pkg$json === void 0 ? void 0 : _cmd$pkg$json.actions;
        let file = actions && typeof actions === 'object' && actions[event];

        if (!file) {
          continue;
        }

        if (!_path.default.isAbsolute(file)) {
          file = _path.default.resolve(ext.path, file);
        }

        log(`Loading extension action: ${highlight(file)}`);

        try {
          let fn = require(file);

          if (fn.__esModule) {
            fn = fn.default;
          }

          if (typeof fn === 'function') {
            await fn({
              ctx,
              console: ctx.terminal.console,
              data,
              event
            });
          }
        } catch (err) {
          error(`Error emitting action "${event}" to extension "${ext.name}:${cmd.name}":`);
          error(`Extension action: ${file}`);
          error(err.stack.split(/\r\n|\n/).filter(Boolean).join('\n'));
        }
      }
    }
  }
  /**
   * Registers an external package as a command context that invokes the package.
   *
   * @param {Object|String|Extension|ExtensionMap|Array.<String|Extension>} ext - An object of
   * extension names to extension paths or instances, an extension path, an `Extension` instance,
   * or an array of those types. An extension path may be a directory containing a Node.js
   * module, a path to a `.js` file, or the name of a executable. May also be an `ExtensionMap`
   * instance.
   * @param {String} [name] - The extension name used for the context name. If not set, it will
   * attempt to find a `package.json` with a `cli-kit.name` value.
   * @param {Boolean} [clone] - When `true` and `params` is an `Extension` or `ExtensionMap`, it
   * will clone the `Extension` instead of set by reference.
   * @returns {Context}
   * @access public
   */


  extension(ext, name, clone) {
    const exts = this.extensions.add(ext, name, clone);

    for (const ext of exts) {
      log(`Adding extension: ${highlight(ext.name)} ${note(`(${this.name})`)}`);
      this.register(ext);
    }

    this.rev++;
    return this;
  }
  /**
   * Renders the help screen for this context including the parent contexts.
   *
   * @param {Object} [opts] - Various parameters.
   * @returns {Promise<Object>}
   * @access private
   */


  generateHelp(opts = {}) {
    return this.hook('generateHelp', async (ctx, results) => {
      const scopes = [];

      while (ctx) {
        if (ctx instanceof Context) {
          scopes.push({
            title: `${ctx.title} options`,
            name: ctx.name,
            ...ctx.options.generateHelp()
          });
          results.contexts.unshift(ctx.name);
        }

        ctx = ctx.parent;
      } // remove duplicate options and determine required options


      const longs = new Set();
      const shorts = new Set();
      const reqOpts = [];
      let j = scopes.length;

      while (j--) {
        for (const options of Object.values(scopes[j].groups)) {
          for (let i = 0; i < options.length; i++) {
            const {
              hint,
              isFlag,
              long,
              required,
              short
            } = options[i];
            let nuke = false;

            if (long !== null) {
              if (longs.has(long)) {
                nuke = true;
              } else {
                longs.add(long);
              }
            }

            if (short !== null) {
              if (shorts.has(short)) {
                nuke = true;
              } else {
                shorts.add(short);
              }
            }

            if (nuke) {
              scopes[j].count--;
              options.splice(i--, 1);
            } else if (required && !isFlag) {
              if (long) {
                reqOpts.push(`--${long} <${hint}>`);
              } else if (short) {
                reqOpts.push(`-${short} <${hint}>`);
              }
            }
          }
        }
      } // set the description


      results.desc = this.desc ? String(this.desc).trim().replace(/^\w/, c => c.toLocaleUpperCase()) : null; // set the commands

      results.commands = {
        title: this.parent ? `${this.title} commands` : 'Commands',
        ...this.commands.generateHelp()
      };
      const ext = this.extensions.generateHelp();
      results.commands.count += ext.count;
      results.commands.entries.push(...ext.entries);
      results.commands.entries.sort((a, b) => a.name.localeCompare(b.name)); // update the default command

      if (this.defaultCommand) {
        for (const cmd of results.commands.entries) {
          if (cmd.name === this.defaultCommand) {
            cmd.default = true;
            break;
          }
        }
      } // set the arguments


      results.arguments = {
        title: this.parent ? `${this.title} arguments` : 'Arguments',
        ...this.args.generateHelp()
      }; // set the options

      results.options = {
        count: scopes.reduce((p, c) => p + c.count, 0),
        scopes
      }; // set the help

      const helpOpts = {
        style: Object.assign({}, _debug.default.styles, this.get('styles'))
      };
      results.header = typeof this.help.header === 'function' ? await this.help.header.call(this, helpOpts) : this.help.header;
      results.footer = typeof this.help.footer === 'function' ? await this.help.footer.call(this, helpOpts) : this.help.footer; // set the usage line

      const usage = []; // add parent context names

      if (Array.isArray(opts.parentContextNames)) {
        usage.push.apply(usage, opts.parentContextNames);
      } // add context names


      usage.push.apply(usage, results.contexts); // if there are subcommands, add command placeholder

      results.commands.count && usage.push('<command>'); // add required arguments

      for (const arg of results.arguments.entries) {
        if (arg.required) {
          usage.push(`<${arg.hint}${arg.multiple ? '...' : ''}>`);
        }
      } // add required options


      usage.push.apply(usage, reqOpts); // if there are options, add options placeholder

      if (results.options.count > reqOpts.length) {
        usage.push('[options]');
      } // add optional arguments


      for (const arg of results.arguments.entries) {
        if (!arg.required) {
          usage.push(`[<${arg.hint}${arg.multiple ? '...' : ''}>]`);
        }
      }

      results.usage = {
        title: 'Usage',
        text: usage.join(' ')
      };
      return results;
    })(this, {
      contexts: [],
      error: undefined,
      suggestions: [],
      warnings: undefined
    });
  }
  /**
   * Scan parent contexts to find the specified property in the top-most context.
   *
   * @param {String} name - The property name.
   * @param {*} defaultValue - A default value if no value is found.
   * @returns {*}
   * @access private
   */


  get(name, defaultValue) {
    let value = this[name];

    for (let p = this.parent; p; p = p.parent) {
      if (p instanceof Context) {
        value = p.get(name, value);
      }
    }

    return value !== undefined ? value : defaultValue;
  }
  /**
   * Initializes this context with params.
   *
   * @param {Object|Context} params - Various parameters
   * @param {Boolean} [clone] - When `true`, all `Command` and `Extension` objects will be cloned
   * instead of set by reference.
   * @returns {Context}
   * @access private
   */


  init(params, clone) {
    if (!params || typeof params !== 'object' || params.clikit instanceof Set && !params.clikit.has('Context')) {
      throw _errors.default.INVALID_ARGUMENT('Expected parameters to be an object or Context', {
        name: 'params',
        scope: 'Context.init',
        value: params
      });
    }

    if (params.clikit instanceof Set && !params.clikit.has('Context')) {
      throw _errors.default.INVALID_ARGUMENT('Expected parameters to be an object or Context', {
        name: 'params',
        scope: 'Context.init',
        value: params
      });
    }

    this.args = new _argumentList.default();
    this.autoHideBanner = params.autoHideBanner;
    this.banner = params.banner;
    this.commands = new _commandMap.default();
    this.defaultCommand = params.defaultCommand;
    this.desc = params.desc;
    this.errorIfUnknownCommand = params.errorIfUnknownCommand;
    this.extensions = new _extensionMap.default();
    this.helpExitCode = params.helpExitCode;
    this.helpTemplateFile = params.helpTemplateFile;
    this.hideNoBannerOption = params.hideNoBannerOption;
    this.hideNoColorOption = params.hideNoColorOption;
    this.lookup = new _lookup.default();
    this.name = params.name;
    this.nodeVersion = params.nodeVersion;
    this.options = new _optionMap.default();
    this.parent = params.parent;
    this.rev = 0;
    this.showBannerForExternalCLIs = params.showBannerForExternalCLIs;
    this.showHelpOnError = params.showHelpOnError;
    this.title = params.title || params.name;
    this.treatUnknownOptionsAsArguments = !!params.treatUnknownOptionsAsArguments;
    this.version = params.version;
    params.args && this.argument(params.args);
    params.commands && this.command(params.commands, null, clone);
    params.extensions && this.extension(params.extensions, null, clone);
    params.options && this.option(params.options);
    return this;
  }
  /**
   * Adds an option to this context.
   *
   * @param {String|Object|Option|OptionMap|Array<Object|Option|String>} format - An option
   * format, an object of format to option descriptions, `Option` constructor params or `Option`
   * instances, an `Option` instance, an `OptionMap` instance, or an array of `Option`
   * constructor params and `Option` instances grouped by `String` labels.
   * @param {Object|Option|String} [params] - When `format` is a format string, then this
   * argument is either `Option` constructor parameters, an `Option` instance, or an option
   * description.
   * @returns {Context}
   * @access public
   *
   * @example
   *   ctx.option('--foo'); // format flag
   *   ctx.option('--foo', 'enables foo mode'); // format with description
   *   ctx.option('--foo', { desc: 'enables foo mode' }); // format with Option ctor params
   *   ctx.option({ '--foo': null }); // object with format flag
   *   ctx.option({ '--foo': { desc: 'enables foo mode' } }); // object with Option ctor params
   *   ctx.option({ '--foo': new Option() }); // object of `Option` instance
   *   ctx.option(new Option('--foo')); // `Option` instance
   *   ctx.option(new OptionMap()); // `OptionMap` from another instance
   *   ctx.option([ 'Some Group', new Option('--foo'), 'Another Group', { '--bar': null } ]); // an array of grouped options
   */


  option(format, params) {
    const opts = this.options.add(format, params);

    for (const opt of opts) {
      opt.parent = this;

      if (opt.long) {
        this.lookup.long[opt.long] = opt;
      }

      if (opt.short) {
        this.lookup.short[opt.short] = opt;
      }

      for (const [alias, visible] of Object.entries(opt.aliases.long)) {
        if (visible) {
          this.lookup.long[alias] = opt;
        }
      }

      for (const [alias, visible] of Object.entries(opt.aliases.short)) {
        if (visible) {
          this.lookup.short[alias] = opt;
        }
      }
    }

    this.rev++;
    return this;
  }
  /**
   * Scan parent contexts to find the specified property in the bottom-most context.
   *
   * @param {String} name - The property name.
   * @param {*} defaultValue - A default value if no value is found.
   * @returns {*}
   * @access private
   */


  prop(name, defaultValue) {
    let value = this[name];

    for (let p = this.parent; value === undefined && p; p = p.parent) {
      if (p instanceof Context) {
        value = p.prop(name, value);
      }
    }

    return value !== undefined ? value : defaultValue;
  }
  /**
   * Registers a command or extension to add to the lookup.
   *
   * @param {Command|Extension} it - The command or extension instance.
   * @access private
   */


  register(it) {
    let cmds;
    let dest;

    if (it.clikit.has('Extension')) {
      cmds = Object.values(it.exports);
      dest = 'extensions';
    } else if (it.clikit.has('Command')) {
      cmds = [it];
      dest = 'commands';
    }

    if (!cmds) {
      return;
    }

    it.parent = this;

    for (const cmd of cmds) {
      this.lookup[dest][cmd.name] = cmd;

      if (cmd.aliases) {
        for (const alias of Object.keys(cmd.aliases)) {
          if (!this[dest].has(alias)) {
            this.lookup[dest][alias] = cmd;
          }
        }
      }
    }
  }

}

exports.default = Context;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcnNlci9jb250ZXh0LmpzIl0sIm5hbWVzIjpbImVycm9yIiwibG9nIiwiaGlnaGxpZ2h0Iiwibm90ZSIsImRlYnVnIiwic3R5bGVzIiwiQ29udGV4dCIsIkhvb2tFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJwYXJhbXMiLCJpbml0IiwiYXJndW1lbnQiLCJhcmciLCJhcmdzIiwiYWRkIiwicmV2IiwiY29tbWFuZCIsImNtZCIsImNsb25lIiwiY21kcyIsImNvbW1hbmRzIiwibmFtZSIsInJlZ2lzdGVyIiwiZW1pdEFjdGlvbiIsImV2ZW50IiwiZGF0YSIsImN0eCIsInBhcmVudCIsImVtaXQiLCJleHQiLCJleHRlbnNpb25zIiwidmFsdWVzIiwiT2JqZWN0IiwiZXhwb3J0cyIsImFjdGlvbnMiLCJwa2ciLCJqc29uIiwiZmlsZSIsInBhdGgiLCJpc0Fic29sdXRlIiwicmVzb2x2ZSIsImZuIiwicmVxdWlyZSIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiY29uc29sZSIsInRlcm1pbmFsIiwiZXJyIiwic3RhY2siLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJqb2luIiwiZXh0ZW5zaW9uIiwiZXh0cyIsImdlbmVyYXRlSGVscCIsIm9wdHMiLCJob29rIiwicmVzdWx0cyIsInNjb3BlcyIsInB1c2giLCJ0aXRsZSIsIm9wdGlvbnMiLCJjb250ZXh0cyIsInVuc2hpZnQiLCJsb25ncyIsIlNldCIsInNob3J0cyIsInJlcU9wdHMiLCJqIiwibGVuZ3RoIiwiZ3JvdXBzIiwiaSIsImhpbnQiLCJpc0ZsYWciLCJsb25nIiwicmVxdWlyZWQiLCJzaG9ydCIsIm51a2UiLCJoYXMiLCJjb3VudCIsInNwbGljZSIsImRlc2MiLCJTdHJpbmciLCJ0cmltIiwicmVwbGFjZSIsImMiLCJ0b0xvY2FsZVVwcGVyQ2FzZSIsImVudHJpZXMiLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwiZGVmYXVsdENvbW1hbmQiLCJhcmd1bWVudHMiLCJyZWR1Y2UiLCJwIiwiaGVscE9wdHMiLCJzdHlsZSIsImFzc2lnbiIsImdldCIsImhlYWRlciIsImhlbHAiLCJjYWxsIiwiZm9vdGVyIiwidXNhZ2UiLCJBcnJheSIsImlzQXJyYXkiLCJwYXJlbnRDb250ZXh0TmFtZXMiLCJhcHBseSIsIm11bHRpcGxlIiwidGV4dCIsInVuZGVmaW5lZCIsInN1Z2dlc3Rpb25zIiwid2FybmluZ3MiLCJkZWZhdWx0VmFsdWUiLCJ2YWx1ZSIsImNsaWtpdCIsIkUiLCJJTlZBTElEX0FSR1VNRU5UIiwic2NvcGUiLCJBcmd1bWVudExpc3QiLCJhdXRvSGlkZUJhbm5lciIsImJhbm5lciIsIkNvbW1hbmRNYXAiLCJlcnJvcklmVW5rbm93bkNvbW1hbmQiLCJFeHRlbnNpb25NYXAiLCJoZWxwRXhpdENvZGUiLCJoZWxwVGVtcGxhdGVGaWxlIiwiaGlkZU5vQmFubmVyT3B0aW9uIiwiaGlkZU5vQ29sb3JPcHRpb24iLCJsb29rdXAiLCJMb29rdXAiLCJub2RlVmVyc2lvbiIsIk9wdGlvbk1hcCIsInNob3dCYW5uZXJGb3JFeHRlcm5hbENMSXMiLCJzaG93SGVscE9uRXJyb3IiLCJ0cmVhdFVua25vd25PcHRpb25zQXNBcmd1bWVudHMiLCJ2ZXJzaW9uIiwib3B0aW9uIiwiZm9ybWF0Iiwib3B0IiwiYWxpYXMiLCJ2aXNpYmxlIiwiYWxpYXNlcyIsInByb3AiLCJpdCIsImRlc3QiLCJrZXlzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7QUFFQSxNQUFNO0FBQUVBLEVBQUFBLEtBQUY7QUFBU0MsRUFBQUE7QUFBVCxJQUFpQixvQkFBTSxpQkFBTixDQUF2QjtBQUNBLE1BQU07QUFBRUMsRUFBQUEsU0FBRjtBQUFhQyxFQUFBQTtBQUFiLElBQXNCQyxlQUFNQyxNQUFsQztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDZSxNQUFNQyxPQUFOLFNBQXNCQyxvQkFBdEIsQ0FBa0M7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QzNCLGlCQUFLWCxNQUFMLENBQVlnQixJQUFaLEVBQWtCTCxLQUFsQixJQUEyQjdILEdBQTNCO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7QUFDRDs7QUExZStDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEFyZ3VtZW50TGlzdCBmcm9tICcuL2FyZ3VtZW50LWxpc3QnO1xuaW1wb3J0IENvbW1hbmRNYXAgZnJvbSAnLi9jb21tYW5kLW1hcCc7XG5pbXBvcnQgZGVidWcgZnJvbSAnLi4vbGliL2RlYnVnJztcbmltcG9ydCBFIGZyb20gJy4uL2xpYi9lcnJvcnMnO1xuaW1wb3J0IEV4dGVuc2lvbk1hcCBmcm9tICcuL2V4dGVuc2lvbi1tYXAnO1xuaW1wb3J0IEhvb2tFbWl0dGVyIGZyb20gJ2hvb2stZW1pdHRlcic7XG5pbXBvcnQgTG9va3VwIGZyb20gJy4vbG9va3VwJztcbmltcG9ydCBPcHRpb25NYXAgZnJvbSAnLi9vcHRpb24tbWFwJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyBkZWNsYXJlQ0xJS2l0Q2xhc3MgfSBmcm9tICcuLi9saWIvdXRpbCc7XG5cbmNvbnN0IHsgZXJyb3IsIGxvZyB9ID0gZGVidWcoJ2NsaS1raXQ6Y29udGV4dCcpO1xuY29uc3QgeyBoaWdobGlnaHQsIG5vdGUgfSA9IGRlYnVnLnN0eWxlcztcblxuLyoqXG4gKiBEZWZpbmVzIGEgY29udGV4dCB0aGF0IGNvbnRhaW5zIGNvbW1hbmRzLCBvcHRpb25zLCBhbmQgYXJncy4gU2VydmVzIGFzIHRoZVxuICogYmFzZSBjbGFzcyBmb3IgYENMSWAgYW5kIGBDb250ZXh0YCBvYmplY3RzLlxuICpcbiAqIEBleHRlbmRzIHtIb29rRW1pdHRlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udGV4dCBleHRlbmRzIEhvb2tFbWl0dGVyIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBjb250ZXh0IGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdHxDb250ZXh0fSBbcGFyYW1zXSAtIFZhcmlvdXMgcGFyYW1ldGVycy5cblx0ICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfEFyZ3VtZW50fEFyZ3VtZW50TGlzdHxBcnJheTxPYmplY3R8U3RyaW5nfEFyZ3VtZW50Pn0gW3BhcmFtcy5hcmdzXSAtXG5cdCAqIEFuIG9iamVjdCBvZiBhcmd1bWVudCBuYW1lcyB0byBhcmd1bWVudCBkZXNjcmlwdG9ycywgYW4gYXJndW1lbnQgbmFtZSwgYW4gYEFyZ3VtZW50YFxuXHQgKiBpbnN0YW5jZSwgYW4gYEFyZ3VtZW50TGlzdGAgaW5zdGFuY2UsIG9yIGFycmF5IG9mIG9iamVjdCBkZXNjcmlwdG9ycywgYXJndW1lbnQgbmFtZXMsIGFuZFxuXHQgKiBgQXJndW1lbnRgIGluc3RhbmNlcy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmNhbWVsQ2FzZT10cnVlXSAtIENhbWVsIGNhc2Ugb3B0aW9uIG5hbWVzLlxuXHQgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8Q29tbWFuZHxDb21tYW5kTWFwfEFycmF5LjxPYmplY3R8U3RyaW5nfENvbW1hbmQ+fSBbcGFyYW1zLmNvbW1hbmRzXSAtXG5cdCAqIEFuIG9iamVjdCB1c2VkIGZvciBgQ29tbWFuZGAgY29uc3RydWN0b3IgcGFyYW1zLCBhIHBhdGggdG8gYSBkaXJlY3Rvcnkgb3IgYSBgLmpzYCBmaWxlLCBhXG5cdCAqIGBDb21tYW5kYCBpbnN0YW5jZSwgb3IgYW4gYXJyYXkgb2YgdGhvc2UgdHlwZXMuIE1heSBhbHNvIGJlIGEgYENvbW1hbmRNYXBgIGluc3RhbmNlLiBJZlxuXHQgKiBgY21kYCBpcyBhIGBTdHJpbmdgIGFuZCBgcGFyYW1zYCBpcyBwcmVzZW50LCB0aGVuIGl0IHdpbGwgdHJlYXQgYGNtZGAgYXMgdGhlIGNvbW1hbmQgbmFtZSxcblx0ICogbm90IGEgZmlsZSBwYXRoLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5kZXNjXSAtIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgQ0xJIG9yIGNvbW1hbmQgZGlzcGxheWVkIGluIHRoZSBoZWxwXG5cdCAqIG91dHB1dC4gSWYgY29udGV4dCBpcyBhIGNvbW1hbmQgd2l0aCBhIGhlbHAgaGVhZGVyIGRlZmluZWQsIHRoaXMgZGVzY3JpcHRpb24gaXMgbm90XG5cdCAqIGRpc3BsYXllZC5cblx0ICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfEV4dGVuc2lvbnxFeHRlbnNpb25NYXB8QXJyYXkuPFN0cmluZ3xFeHRlbnNpb24+fSBbcGFyYW1zLmV4dGVuc2lvbnNdIC1cblx0ICogQW4gb2JqZWN0IG9mIGV4dGVuc2lvbiBuYW1lcyB0byBleHRlbnNpb24gcGF0aHMgb3IgaW5zdGFuY2VzLCBhbiBleHRlbnNpb24gcGF0aCwgYW5cblx0ICogYEV4dGVuc2lvbmAgaW5zdGFuY2UsIG9yIGFuIGFycmF5IG9mIHRob3NlIHR5cGVzLiBBbiBleHRlbnNpb24gcGF0aCBtYXkgYmUgYSBkaXJlY3Rvcnlcblx0ICogY29udGFpbmluZyBhIE5vZGUuanMgbW9kdWxlLCBhIHBhdGggdG8gYSBgLmpzYCBmaWxlLCBvciB0aGUgbmFtZSBvZiBhIGV4ZWN1dGFibGUuIE1heSBhbHNvXG5cdCAqIGJlIGFuIGBFeHRlbnNpb25NYXBgIGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbnxPYmplY3R9IFtwYXJhbXMuaGVscF0gLSBBZGRpdGlvbmFsIGhlbHAgY29udGVudCB0byBkaXNwbGF5IG9uIHRoZVxuXHQgKiBoZWxwIHNjcmVlbi4gV2hlbiBtYXkgYmUgYW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgYGhlYWRlcmAgYW5kIGBmb290ZXJgIHdoaWNoIHZhbHVlc1xuXHQgKiB0aGF0IGFyZSBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gYXN5bmMgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyBhIHN0cmluZy4gV2hlbiB2YWx1ZSBpcyBhIHN0cmluZ1xuXHQgKiBvciBmdW5jdGlvbiwgaXQgaXMgdHJhc25mb3JtZWQgaW50byBhIG9iamVjdCB3aXRoIHRoZSB2YWx1ZSBiZWluZyB1c2VkIGFzIHRoZSBoZWFkZXIuIE5vdGVcblx0ICogdGhhdCB0aGUgY29tbWFuZCBkZXNjcmlwdGlvbiBpcyBub3QgZGlzcGxheWVkIHdoZW4gYSBoZWFkZXIgbWVzc2FnZSBoYXMgYmVlbiBkZWZpbmVkLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5uYW1lXSAtIFRoZSBuYW1lIG9mIHRoZSBjb250ZXh0IHN1Y2ggYXMgdGhlIHByb2dyYW0gb3IgdGhlIGNvbW1hbmRcblx0ICogbmFtZS5cblx0ICogQHBhcmFtIHtPYmplY3R8T3B0aW9ufE9wdGlvbk1hcHxBcnJheTxPYmplY3R8T3B0aW9ufFN0cmluZz59IFtwYXJhbXMub3B0aW9uc10gLSBBbiBvYmplY3Qgb2Zcblx0ICogZm9ybWF0IHRvIGBPcHRpb25gIGNvbnN0cnVjdG9yIHBhcmFtcywgYW4gYE9wdGlvbmAgaW5zdGFuY2UsIG9yIGFuIGFycmF5IG9mIGBPcHRpb25gXG5cdCAqIGNvbnN0cnVjdG9yIHBhcmFtcyBhbmQgYE9wdGlvbmAgaW5zdGFuY2VzIGdyb3VwZWQgYnkgYFN0cmluZ2AgbGFiZWxzLlxuXHQgKiBAcGFyYW0ge0NvbnRleHR9IFtwYXJhbXMucGFyZW50XSAtIFRoZSBwYXJlbnQgY29udGV4dC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMudGl0bGVdIC0gVGhlIGNvbnRleHQgdGl0bGUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy50cmVhdFVua25vd25PcHRpb25zQXNBcmd1bWVudHM9ZmFsc2VdIC0gV2hlbiBgdHJ1ZWAsIGFueSBhcmd1bWVudCBpc1xuXHQgKiBlbmNvdW50ZXJlZCBkdXJpbmcgcGFyc2luZyB0aGF0IHJlc2VtYmxlcyBhIG9wdGlvbiB0aGF0IGRvZXMgbm90IGV4aXN0LCBpdCB3aWxsIGFkZCBpdFxuXHQgKiB1bnRvdWNoZWQgdG8gYF9gIGFzIGFuIGFyZ3VtZW50IGFzIHdlbGwgYXMgdG8gYGFyZ3ZgIGFzIGEgYm9vbGVhbiBmbGFnLiBXaGVuIGBmYWxzZWAsIGl0IHdpbGxcblx0ICogb25seSBhZGQgdGhlIGFyZ3VtZW50IHRvIGBhcmd2YCBhcyBhIGJvb2xlYW4gZmxhZy5cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICovXG5cdGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG5cdFx0c3VwZXIoKTtcblx0XHRkZWNsYXJlQ0xJS2l0Q2xhc3ModGhpcywgJ0NvbnRleHQnKTtcblx0XHR0aGlzLmluaXQocGFyYW1zKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGFyZ3VtZW50IHRvIHRoaXMgY29udGV4dC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfEFyZ3VtZW50fEFyZ3VtZW50TGlzdHxBcnJheTxPYmplY3R8U3RyaW5nfEFyZ3VtZW50Pn0gYXJnIC0gQW4gb2JqZWN0XG5cdCAqIG9mIGFyZ3VtZW50IG5hbWVzIHRvIGFyZ3VtZW50IGRlc2NyaXB0b3JzLCBhbiBhcmd1bWVudCBuYW1lLCBhbiBgQXJndW1lbnRgIGluc3RhbmNlLCBhblxuXHQgKiBgQXJndW1lbnRMaXN0YCBpbnN0YW5jZSwgb3IgYXJyYXkgb2Ygb2JqZWN0IGRlc2NyaXB0b3JzLCBhcmd1bWVudCBuYW1lcywgYW5kIGBBcmd1bWVudGBcblx0ICogaW5zdGFuY2VzLlxuXHQgKiBAcmV0dXJucyB7Q29udGV4dH1cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICovXG5cdGFyZ3VtZW50KGFyZykge1xuXHRcdHRoaXMuYXJncy5hZGQoYXJnKTtcblx0XHR0aGlzLnJldisrO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBjb21tYW5kIHRvIHRoaXMgY29udGV4dC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfENvbW1hbmR8Q29tbWFuZE1hcHxBcnJheS48T2JqZWN0fFN0cmluZ3xDb21tYW5kPn0gY21kIC0gQW4gb2JqZWN0XG5cdCAqIHVzZWQgZm9yIGBDb21tYW5kYCBjb25zdHJ1Y3RvciBwYXJhbXMsIGEgcGF0aCB0byBhIGRpcmVjdG9yeSBvciBhIGAuanNgIGZpbGUsIGEgYENvbW1hbmRgXG5cdCAqIGluc3RhbmNlLCBvciBhbiBhcnJheSBvZiB0aG9zZSB0eXBlcy4gTWF5IGFsc28gYmUgYSBgQ29tbWFuZE1hcGAgaW5zdGFuY2UuIElmIGBjbWRgIGlzIGFcblx0ICogYFN0cmluZ2AgYW5kIGBwYXJhbXNgIGlzIHByZXNlbnQsIHRoZW4gaXQgd2lsbCB0cmVhdCBgY21kYCBhcyB0aGUgY29tbWFuZCBuYW1lLCBub3QgYSBmaWxlXG5cdCAqIHBhdGguXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIFdoZW4gYGNtZGAgaXMgdGhlIGNvbW1hbmQgbmFtZSwgdGhlbiB0aGlzIGlzIHRoZSBvcHRpb25zIHRvIHBhc3Ncblx0ICogaW50byB0aGUgYENvbW1hbmRgIGNvbnN0cnVjdG9yLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtjbG9uZV0gLSBXaGVuIGB0cnVlYCBhbmQgYHBhcmFtc2AgaXMgYSBgQ29tbWFuZGAgb3IgYENvbW1hbmRNYXBgLCBpdCB3aWxsXG5cdCAqIGNsb25lIHRoZSBgQ29tbWFuZGAgaW5zdGVhZCBvZiBzZXQgYnkgcmVmZXJlbmNlLlxuXHQgKiBAcmV0dXJucyB7Q29udGV4dH1cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICovXG5cdGNvbW1hbmQoY21kLCBwYXJhbXMsIGNsb25lKSB7XG5cdFx0Y29uc3QgY21kcyA9IHRoaXMuY29tbWFuZHMuYWRkKGNtZCwgcGFyYW1zLCBjbG9uZSk7XG5cdFx0Zm9yIChjb25zdCBjbWQgb2YgY21kcykge1xuXHRcdFx0bG9nKGBBZGRpbmcgY29tbWFuZDogJHtoaWdobGlnaHQoY21kLm5hbWUpfSAke25vdGUoYCgke3RoaXMubmFtZX0pYCl9YCk7XG5cdFx0XHR0aGlzLnJlZ2lzdGVyKGNtZCk7XG5cdFx0fVxuXHRcdHRoaXMucmV2Kys7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogRmluZHMgdGhlIHRvcCBtb3N0IGNvbnRleHQsIHRoZW4gZW1pdHMgdGhlIGV2ZW50IG9uIGl0IGFuZCBpdHMgZXh0ZW5zaW9ucy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50IG5hbWUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gLSBPcHRpb25hbCBldmVudCBkYXRhLlxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZX1cblx0ICovXG5cdGFzeW5jIGVtaXRBY3Rpb24oZXZlbnQsIGRhdGEpIHtcblx0XHQvLyBmaW5kIHRvcC1tb3N0IGNvbnRleHRcblx0XHRsZXQgY3R4ID0gdGhpcztcblx0XHR3aGlsZSAoY3R4LnBhcmVudCkge1xuXHRcdFx0YXdhaXQgdGhpcy5lbWl0KGV2ZW50LCBkYXRhKTtcblx0XHRcdGN0eCA9IGN0eC5wYXJlbnQ7XG5cdFx0fVxuXG5cdFx0bG9nKGBFbWl0dGluZyBhY3Rpb246ICR7aGlnaGxpZ2h0KGV2ZW50KX1gKTtcblx0XHRhd2FpdCBjdHguZW1pdChldmVudCwgZGF0YSk7XG5cblx0XHRmb3IgKGNvbnN0IGV4dCBvZiBjdHguZXh0ZW5zaW9ucy52YWx1ZXMoKSkge1xuXHRcdFx0Zm9yIChjb25zdCBjbWQgb2YgT2JqZWN0LnZhbHVlcyhleHQuZXhwb3J0cykpIHtcblx0XHRcdFx0Y29uc3QgYWN0aW9ucyA9IGNtZC5wa2c/Lmpzb24/LmFjdGlvbnM7XG5cdFx0XHRcdGxldCBmaWxlID0gYWN0aW9ucyAmJiB0eXBlb2YgYWN0aW9ucyA9PT0gJ29iamVjdCcgJiYgYWN0aW9uc1tldmVudF07XG5cdFx0XHRcdGlmICghZmlsZSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFwYXRoLmlzQWJzb2x1dGUoZmlsZSkpIHtcblx0XHRcdFx0XHRmaWxlID0gcGF0aC5yZXNvbHZlKGV4dC5wYXRoLCBmaWxlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxvZyhgTG9hZGluZyBleHRlbnNpb24gYWN0aW9uOiAke2hpZ2hsaWdodChmaWxlKX1gKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGxldCBmbiA9IHJlcXVpcmUoZmlsZSk7XG5cdFx0XHRcdFx0aWYgKGZuLl9fZXNNb2R1bGUpIHtcblx0XHRcdFx0XHRcdGZuID0gZm4uZGVmYXVsdDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRhd2FpdCBmbih7XG5cdFx0XHRcdFx0XHRcdGN0eCxcblx0XHRcdFx0XHRcdFx0Y29uc29sZTogY3R4LnRlcm1pbmFsLmNvbnNvbGUsXG5cdFx0XHRcdFx0XHRcdGRhdGEsXG5cdFx0XHRcdFx0XHRcdGV2ZW50XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdGVycm9yKGBFcnJvciBlbWl0dGluZyBhY3Rpb24gXCIke2V2ZW50fVwiIHRvIGV4dGVuc2lvbiBcIiR7ZXh0Lm5hbWV9OiR7Y21kLm5hbWV9XCI6YCk7XG5cdFx0XHRcdFx0ZXJyb3IoYEV4dGVuc2lvbiBhY3Rpb246ICR7ZmlsZX1gKTtcblx0XHRcdFx0XHRlcnJvcihlcnIuc3RhY2suc3BsaXQoL1xcclxcbnxcXG4vKS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBhbiBleHRlcm5hbCBwYWNrYWdlIGFzIGEgY29tbWFuZCBjb250ZXh0IHRoYXQgaW52b2tlcyB0aGUgcGFja2FnZS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfEV4dGVuc2lvbnxFeHRlbnNpb25NYXB8QXJyYXkuPFN0cmluZ3xFeHRlbnNpb24+fSBleHQgLSBBbiBvYmplY3Qgb2Zcblx0ICogZXh0ZW5zaW9uIG5hbWVzIHRvIGV4dGVuc2lvbiBwYXRocyBvciBpbnN0YW5jZXMsIGFuIGV4dGVuc2lvbiBwYXRoLCBhbiBgRXh0ZW5zaW9uYCBpbnN0YW5jZSxcblx0ICogb3IgYW4gYXJyYXkgb2YgdGhvc2UgdHlwZXMuIEFuIGV4dGVuc2lvbiBwYXRoIG1heSBiZSBhIGRpcmVjdG9yeSBjb250YWluaW5nIGEgTm9kZS5qc1xuXHQgKiBtb2R1bGUsIGEgcGF0aCB0byBhIGAuanNgIGZpbGUsIG9yIHRoZSBuYW1lIG9mIGEgZXhlY3V0YWJsZS4gTWF5IGFsc28gYmUgYW4gYEV4dGVuc2lvbk1hcGBcblx0ICogaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gLSBUaGUgZXh0ZW5zaW9uIG5hbWUgdXNlZCBmb3IgdGhlIGNvbnRleHQgbmFtZS4gSWYgbm90IHNldCwgaXQgd2lsbFxuXHQgKiBhdHRlbXB0IHRvIGZpbmQgYSBgcGFja2FnZS5qc29uYCB3aXRoIGEgYGNsaS1raXQubmFtZWAgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Nsb25lXSAtIFdoZW4gYHRydWVgIGFuZCBgcGFyYW1zYCBpcyBhbiBgRXh0ZW5zaW9uYCBvciBgRXh0ZW5zaW9uTWFwYCwgaXRcblx0ICogd2lsbCBjbG9uZSB0aGUgYEV4dGVuc2lvbmAgaW5zdGVhZCBvZiBzZXQgYnkgcmVmZXJlbmNlLlxuXHQgKiBAcmV0dXJucyB7Q29udGV4dH1cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICovXG5cdGV4dGVuc2lvbihleHQsIG5hbWUsIGNsb25lKSB7XG5cdFx0Y29uc3QgZXh0cyA9IHRoaXMuZXh0ZW5zaW9ucy5hZGQoZXh0LCBuYW1lLCBjbG9uZSk7XG5cdFx0Zm9yIChjb25zdCBleHQgb2YgZXh0cykge1xuXHRcdFx0bG9nKGBBZGRpbmcgZXh0ZW5zaW9uOiAke2hpZ2hsaWdodChleHQubmFtZSl9ICR7bm90ZShgKCR7dGhpcy5uYW1lfSlgKX1gKTtcblx0XHRcdHRoaXMucmVnaXN0ZXIoZXh0KTtcblx0XHR9XG5cdFx0dGhpcy5yZXYrKztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW5kZXJzIHRoZSBoZWxwIHNjcmVlbiBmb3IgdGhpcyBjb250ZXh0IGluY2x1ZGluZyB0aGUgcGFyZW50IGNvbnRleHRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gVmFyaW91cyBwYXJhbWV0ZXJzLlxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fVxuXHQgKiBAYWNjZXNzIHByaXZhdGVcblx0ICovXG5cdGdlbmVyYXRlSGVscChvcHRzID0ge30pIHtcblx0XHRyZXR1cm4gdGhpcy5ob29rKCdnZW5lcmF0ZUhlbHAnLCBhc3luYyAoY3R4LCByZXN1bHRzKSA9PiB7XG5cdFx0XHRjb25zdCBzY29wZXMgPSBbXTtcblxuXHRcdFx0d2hpbGUgKGN0eCkge1xuXHRcdFx0XHRpZiAoY3R4IGluc3RhbmNlb2YgQ29udGV4dCkge1xuXHRcdFx0XHRcdHNjb3Blcy5wdXNoKHtcblx0XHRcdFx0XHRcdHRpdGxlOiBgJHtjdHgudGl0bGV9IG9wdGlvbnNgLFxuXHRcdFx0XHRcdFx0bmFtZTogY3R4Lm5hbWUsXG5cdFx0XHRcdFx0XHQuLi5jdHgub3B0aW9ucy5nZW5lcmF0ZUhlbHAoKVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJlc3VsdHMuY29udGV4dHMudW5zaGlmdChjdHgubmFtZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3R4ID0gY3R4LnBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVtb3ZlIGR1cGxpY2F0ZSBvcHRpb25zIGFuZCBkZXRlcm1pbmUgcmVxdWlyZWQgb3B0aW9uc1xuXHRcdFx0Y29uc3QgbG9uZ3MgPSBuZXcgU2V0KCk7XG5cdFx0XHRjb25zdCBzaG9ydHMgPSBuZXcgU2V0KCk7XG5cdFx0XHRjb25zdCByZXFPcHRzID0gW107XG5cdFx0XHRsZXQgaiA9IHNjb3Blcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoai0tKSB7XG5cdFx0XHRcdGZvciAoY29uc3Qgb3B0aW9ucyBvZiBPYmplY3QudmFsdWVzKHNjb3Blc1tqXS5ncm91cHMpKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB7IGhpbnQsIGlzRmxhZywgbG9uZywgcmVxdWlyZWQsIHNob3J0IH0gPSBvcHRpb25zW2ldO1xuXHRcdFx0XHRcdFx0bGV0IG51a2UgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGlmIChsb25nICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChsb25ncy5oYXMobG9uZykpIHtcblx0XHRcdFx0XHRcdFx0XHRudWtlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRsb25ncy5hZGQobG9uZyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChzaG9ydCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoc2hvcnRzLmhhcyhzaG9ydCkpIHtcblx0XHRcdFx0XHRcdFx0XHRudWtlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRzaG9ydHMuYWRkKHNob3J0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKG51a2UpIHtcblx0XHRcdFx0XHRcdFx0c2NvcGVzW2pdLmNvdW50LS07XG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMuc3BsaWNlKGktLSwgMSk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHJlcXVpcmVkICYmICFpc0ZsYWcpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGxvbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXFPcHRzLnB1c2goYC0tJHtsb25nfSA8JHtoaW50fT5gKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChzaG9ydCkge1xuXHRcdFx0XHRcdFx0XHRcdHJlcU9wdHMucHVzaChgLSR7c2hvcnR9IDwke2hpbnR9PmApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNldCB0aGUgZGVzY3JpcHRpb25cblx0XHRcdHJlc3VsdHMuZGVzYyA9IHRoaXMuZGVzYyA/IFN0cmluZyh0aGlzLmRlc2MpLnRyaW0oKS5yZXBsYWNlKC9eXFx3LywgYyA9PiBjLnRvTG9jYWxlVXBwZXJDYXNlKCkpIDogbnVsbDtcblxuXHRcdFx0Ly8gc2V0IHRoZSBjb21tYW5kc1xuXHRcdFx0cmVzdWx0cy5jb21tYW5kcyA9IHtcblx0XHRcdFx0dGl0bGU6IHRoaXMucGFyZW50ID8gYCR7dGhpcy50aXRsZX0gY29tbWFuZHNgIDogJ0NvbW1hbmRzJyxcblx0XHRcdFx0Li4udGhpcy5jb21tYW5kcy5nZW5lcmF0ZUhlbHAoKVxuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3QgZXh0ID0gdGhpcy5leHRlbnNpb25zLmdlbmVyYXRlSGVscCgpO1xuXHRcdFx0cmVzdWx0cy5jb21tYW5kcy5jb3VudCArPSBleHQuY291bnQ7XG5cdFx0XHRyZXN1bHRzLmNvbW1hbmRzLmVudHJpZXMucHVzaCguLi5leHQuZW50cmllcyk7XG5cdFx0XHRyZXN1bHRzLmNvbW1hbmRzLmVudHJpZXMuc29ydCgoYSwgYikgPT4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKSk7XG5cblx0XHRcdC8vIHVwZGF0ZSB0aGUgZGVmYXVsdCBjb21tYW5kXG5cdFx0XHRpZiAodGhpcy5kZWZhdWx0Q29tbWFuZCkge1xuXHRcdFx0XHRmb3IgKGNvbnN0IGNtZCBvZiByZXN1bHRzLmNvbW1hbmRzLmVudHJpZXMpIHtcblx0XHRcdFx0XHRpZiAoY21kLm5hbWUgPT09IHRoaXMuZGVmYXVsdENvbW1hbmQpIHtcblx0XHRcdFx0XHRcdGNtZC5kZWZhdWx0ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzZXQgdGhlIGFyZ3VtZW50c1xuXHRcdFx0cmVzdWx0cy5hcmd1bWVudHMgPSB7XG5cdFx0XHRcdHRpdGxlOiB0aGlzLnBhcmVudCA/IGAke3RoaXMudGl0bGV9IGFyZ3VtZW50c2AgOiAnQXJndW1lbnRzJyxcblx0XHRcdFx0Li4udGhpcy5hcmdzLmdlbmVyYXRlSGVscCgpXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBzZXQgdGhlIG9wdGlvbnNcblx0XHRcdHJlc3VsdHMub3B0aW9ucyA9IHtcblx0XHRcdFx0Y291bnQ6IHNjb3Blcy5yZWR1Y2UoKHAsIGMpID0+IHAgKyBjLmNvdW50LCAwKSxcblx0XHRcdFx0c2NvcGVzXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBzZXQgdGhlIGhlbHBcblx0XHRcdGNvbnN0IGhlbHBPcHRzID0ge1xuXHRcdFx0XHRzdHlsZTogT2JqZWN0LmFzc2lnbih7fSwgZGVidWcuc3R5bGVzLCB0aGlzLmdldCgnc3R5bGVzJykpXG5cdFx0XHR9O1xuXHRcdFx0cmVzdWx0cy5oZWFkZXIgPSB0eXBlb2YgdGhpcy5oZWxwLmhlYWRlciA9PT0gJ2Z1bmN0aW9uJyA/IGF3YWl0IHRoaXMuaGVscC5oZWFkZXIuY2FsbCh0aGlzLCBoZWxwT3B0cykgOiB0aGlzLmhlbHAuaGVhZGVyO1xuXHRcdFx0cmVzdWx0cy5mb290ZXIgPSB0eXBlb2YgdGhpcy5oZWxwLmZvb3RlciA9PT0gJ2Z1bmN0aW9uJyA/IGF3YWl0IHRoaXMuaGVscC5mb290ZXIuY2FsbCh0aGlzLCBoZWxwT3B0cykgOiB0aGlzLmhlbHAuZm9vdGVyO1xuXG5cdFx0XHQvLyBzZXQgdGhlIHVzYWdlIGxpbmVcblx0XHRcdGNvbnN0IHVzYWdlID0gW107XG5cdFx0XHQvLyBhZGQgcGFyZW50IGNvbnRleHQgbmFtZXNcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KG9wdHMucGFyZW50Q29udGV4dE5hbWVzKSkge1xuXHRcdFx0XHR1c2FnZS5wdXNoLmFwcGx5KHVzYWdlLCBvcHRzLnBhcmVudENvbnRleHROYW1lcyk7XG5cdFx0XHR9XG5cdFx0XHQvLyBhZGQgY29udGV4dCBuYW1lc1xuXHRcdFx0dXNhZ2UucHVzaC5hcHBseSh1c2FnZSwgcmVzdWx0cy5jb250ZXh0cyk7XG5cdFx0XHQvLyBpZiB0aGVyZSBhcmUgc3ViY29tbWFuZHMsIGFkZCBjb21tYW5kIHBsYWNlaG9sZGVyXG5cdFx0XHRyZXN1bHRzLmNvbW1hbmRzLmNvdW50ICYmIHVzYWdlLnB1c2goJzxjb21tYW5kPicpO1xuXHRcdFx0Ly8gYWRkIHJlcXVpcmVkIGFyZ3VtZW50c1xuXHRcdFx0Zm9yIChjb25zdCBhcmcgb2YgcmVzdWx0cy5hcmd1bWVudHMuZW50cmllcykge1xuXHRcdFx0XHRpZiAoYXJnLnJlcXVpcmVkKSB7XG5cdFx0XHRcdFx0dXNhZ2UucHVzaChgPCR7YXJnLmhpbnR9JHthcmcubXVsdGlwbGUgPyAnLi4uJyA6ICcnfT5gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gYWRkIHJlcXVpcmVkIG9wdGlvbnNcblx0XHRcdHVzYWdlLnB1c2guYXBwbHkodXNhZ2UsIHJlcU9wdHMpO1xuXHRcdFx0Ly8gaWYgdGhlcmUgYXJlIG9wdGlvbnMsIGFkZCBvcHRpb25zIHBsYWNlaG9sZGVyXG5cdFx0XHRpZiAocmVzdWx0cy5vcHRpb25zLmNvdW50ID4gcmVxT3B0cy5sZW5ndGgpIHtcblx0XHRcdFx0dXNhZ2UucHVzaCgnW29wdGlvbnNdJyk7XG5cdFx0XHR9XG5cdFx0XHQvLyBhZGQgb3B0aW9uYWwgYXJndW1lbnRzXG5cdFx0XHRmb3IgKGNvbnN0IGFyZyBvZiByZXN1bHRzLmFyZ3VtZW50cy5lbnRyaWVzKSB7XG5cdFx0XHRcdGlmICghYXJnLnJlcXVpcmVkKSB7XG5cdFx0XHRcdFx0dXNhZ2UucHVzaChgWzwke2FyZy5oaW50fSR7YXJnLm11bHRpcGxlID8gJy4uLicgOiAnJ30+XWApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHRzLnVzYWdlID0ge1xuXHRcdFx0XHR0aXRsZTogJ1VzYWdlJyxcblx0XHRcdFx0dGV4dDogdXNhZ2Uuam9pbignICcpXG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9KSh0aGlzLCB7XG5cdFx0XHRjb250ZXh0czogICAgW10sXG5cdFx0XHRlcnJvcjogICAgICAgdW5kZWZpbmVkLFxuXHRcdFx0c3VnZ2VzdGlvbnM6IFtdLFxuXHRcdFx0d2FybmluZ3M6ICAgIHVuZGVmaW5lZFxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNjYW4gcGFyZW50IGNvbnRleHRzIHRvIGZpbmQgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBpbiB0aGUgdG9wLW1vc3QgY29udGV4dC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgcHJvcGVydHkgbmFtZS5cblx0ICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgLSBBIGRlZmF1bHQgdmFsdWUgaWYgbm8gdmFsdWUgaXMgZm91bmQuXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKiBAYWNjZXNzIHByaXZhdGVcblx0ICovXG5cdGdldChuYW1lLCBkZWZhdWx0VmFsdWUpIHtcblx0XHRsZXQgdmFsdWUgPSB0aGlzW25hbWVdO1xuXHRcdGZvciAobGV0IHAgPSB0aGlzLnBhcmVudDsgcDsgcCA9IHAucGFyZW50KSB7XG5cdFx0XHRpZiAocCBpbnN0YW5jZW9mIENvbnRleHQpIHtcblx0XHRcdFx0dmFsdWUgPSBwLmdldChuYW1lLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZXMgdGhpcyBjb250ZXh0IHdpdGggcGFyYW1zLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdHxDb250ZXh0fSBwYXJhbXMgLSBWYXJpb3VzIHBhcmFtZXRlcnNcblx0ICogQHBhcmFtIHtCb29sZWFufSBbY2xvbmVdIC0gV2hlbiBgdHJ1ZWAsIGFsbCBgQ29tbWFuZGAgYW5kIGBFeHRlbnNpb25gIG9iamVjdHMgd2lsbCBiZSBjbG9uZWRcblx0ICogaW5zdGVhZCBvZiBzZXQgYnkgcmVmZXJlbmNlLlxuXHQgKiBAcmV0dXJucyB7Q29udGV4dH1cblx0ICogQGFjY2VzcyBwcml2YXRlXG5cdCAqL1xuXHRpbml0KHBhcmFtcywgY2xvbmUpIHtcblx0XHRpZiAoIXBhcmFtcyB8fCB0eXBlb2YgcGFyYW1zICE9PSAnb2JqZWN0JyB8fCAocGFyYW1zLmNsaWtpdCBpbnN0YW5jZW9mIFNldCAmJiAhcGFyYW1zLmNsaWtpdC5oYXMoJ0NvbnRleHQnKSkpIHtcblx0XHRcdHRocm93IEUuSU5WQUxJRF9BUkdVTUVOVCgnRXhwZWN0ZWQgcGFyYW1ldGVycyB0byBiZSBhbiBvYmplY3Qgb3IgQ29udGV4dCcsIHsgbmFtZTogJ3BhcmFtcycsIHNjb3BlOiAnQ29udGV4dC5pbml0JywgdmFsdWU6IHBhcmFtcyB9KTtcblx0XHR9XG5cblx0XHRpZiAocGFyYW1zLmNsaWtpdCBpbnN0YW5jZW9mIFNldCAmJiAhcGFyYW1zLmNsaWtpdC5oYXMoJ0NvbnRleHQnKSkge1xuXHRcdFx0dGhyb3cgRS5JTlZBTElEX0FSR1VNRU5UKCdFeHBlY3RlZCBwYXJhbWV0ZXJzIHRvIGJlIGFuIG9iamVjdCBvciBDb250ZXh0JywgeyBuYW1lOiAncGFyYW1zJywgc2NvcGU6ICdDb250ZXh0LmluaXQnLCB2YWx1ZTogcGFyYW1zIH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuYXJncyAgICAgICAgICAgICAgICAgICAgICAgICAgID0gbmV3IEFyZ3VtZW50TGlzdCgpO1xuXHRcdHRoaXMuYXV0b0hpZGVCYW5uZXIgICAgICAgICAgICAgICAgID0gcGFyYW1zLmF1dG9IaWRlQmFubmVyO1xuXHRcdHRoaXMuYmFubmVyICAgICAgICAgICAgICAgICAgICAgICAgID0gcGFyYW1zLmJhbm5lcjtcblx0XHR0aGlzLmNvbW1hbmRzICAgICAgICAgICAgICAgICAgICAgICA9IG5ldyBDb21tYW5kTWFwKCk7XG5cdFx0dGhpcy5kZWZhdWx0Q29tbWFuZCAgICAgICAgICAgICAgICAgPSBwYXJhbXMuZGVmYXVsdENvbW1hbmQ7XG5cdFx0dGhpcy5kZXNjICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBwYXJhbXMuZGVzYztcblx0XHR0aGlzLmVycm9ySWZVbmtub3duQ29tbWFuZCAgICAgICAgICA9IHBhcmFtcy5lcnJvcklmVW5rbm93bkNvbW1hbmQ7XG5cdFx0dGhpcy5leHRlbnNpb25zICAgICAgICAgICAgICAgICAgICAgPSBuZXcgRXh0ZW5zaW9uTWFwKCk7XG5cdFx0dGhpcy5oZWxwRXhpdENvZGUgICAgICAgICAgICAgICAgICAgPSBwYXJhbXMuaGVscEV4aXRDb2RlO1xuXHRcdHRoaXMuaGVscFRlbXBsYXRlRmlsZSAgICAgICAgICAgICAgID0gcGFyYW1zLmhlbHBUZW1wbGF0ZUZpbGU7XG5cdFx0dGhpcy5oaWRlTm9CYW5uZXJPcHRpb24gICAgICAgICAgICAgPSBwYXJhbXMuaGlkZU5vQmFubmVyT3B0aW9uO1xuXHRcdHRoaXMuaGlkZU5vQ29sb3JPcHRpb24gICAgICAgICAgICAgID0gcGFyYW1zLmhpZGVOb0NvbG9yT3B0aW9uO1xuXHRcdHRoaXMubG9va3VwICAgICAgICAgICAgICAgICAgICAgICAgID0gbmV3IExvb2t1cCgpO1xuXHRcdHRoaXMubmFtZSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gcGFyYW1zLm5hbWU7XG5cdFx0dGhpcy5ub2RlVmVyc2lvbiAgICAgICAgICAgICAgICAgICAgPSBwYXJhbXMubm9kZVZlcnNpb247XG5cdFx0dGhpcy5vcHRpb25zICAgICAgICAgICAgICAgICAgICAgICAgPSBuZXcgT3B0aW9uTWFwKCk7XG5cdFx0dGhpcy5wYXJlbnQgICAgICAgICAgICAgICAgICAgICAgICAgPSBwYXJhbXMucGFyZW50O1xuXHRcdHRoaXMucmV2ICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMDtcblx0XHR0aGlzLnNob3dCYW5uZXJGb3JFeHRlcm5hbENMSXMgICAgICA9IHBhcmFtcy5zaG93QmFubmVyRm9yRXh0ZXJuYWxDTElzO1xuXHRcdHRoaXMuc2hvd0hlbHBPbkVycm9yICAgICAgICAgICAgICAgID0gcGFyYW1zLnNob3dIZWxwT25FcnJvcjtcblx0XHR0aGlzLnRpdGxlICAgICAgICAgICAgICAgICAgICAgICAgICA9IHBhcmFtcy50aXRsZSB8fCBwYXJhbXMubmFtZTtcblx0XHR0aGlzLnRyZWF0VW5rbm93bk9wdGlvbnNBc0FyZ3VtZW50cyA9ICEhcGFyYW1zLnRyZWF0VW5rbm93bk9wdGlvbnNBc0FyZ3VtZW50cztcblx0XHR0aGlzLnZlcnNpb24gICAgICAgICAgICAgICAgICAgICAgICA9IHBhcmFtcy52ZXJzaW9uO1xuXG5cdFx0cGFyYW1zLmFyZ3MgICAgICAgJiYgdGhpcy5hcmd1bWVudChwYXJhbXMuYXJncyk7XG5cdFx0cGFyYW1zLmNvbW1hbmRzICAgJiYgdGhpcy5jb21tYW5kKHBhcmFtcy5jb21tYW5kcywgbnVsbCwgY2xvbmUpO1xuXHRcdHBhcmFtcy5leHRlbnNpb25zICYmIHRoaXMuZXh0ZW5zaW9uKHBhcmFtcy5leHRlbnNpb25zLCBudWxsLCBjbG9uZSk7XG5cdFx0cGFyYW1zLm9wdGlvbnMgICAgJiYgdGhpcy5vcHRpb24ocGFyYW1zLm9wdGlvbnMpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhbiBvcHRpb24gdG8gdGhpcyBjb250ZXh0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8T3B0aW9ufE9wdGlvbk1hcHxBcnJheTxPYmplY3R8T3B0aW9ufFN0cmluZz59IGZvcm1hdCAtIEFuIG9wdGlvblxuXHQgKiBmb3JtYXQsIGFuIG9iamVjdCBvZiBmb3JtYXQgdG8gb3B0aW9uIGRlc2NyaXB0aW9ucywgYE9wdGlvbmAgY29uc3RydWN0b3IgcGFyYW1zIG9yIGBPcHRpb25gXG5cdCAqIGluc3RhbmNlcywgYW4gYE9wdGlvbmAgaW5zdGFuY2UsIGFuIGBPcHRpb25NYXBgIGluc3RhbmNlLCBvciBhbiBhcnJheSBvZiBgT3B0aW9uYFxuXHQgKiBjb25zdHJ1Y3RvciBwYXJhbXMgYW5kIGBPcHRpb25gIGluc3RhbmNlcyBncm91cGVkIGJ5IGBTdHJpbmdgIGxhYmVscy5cblx0ICogQHBhcmFtIHtPYmplY3R8T3B0aW9ufFN0cmluZ30gW3BhcmFtc10gLSBXaGVuIGBmb3JtYXRgIGlzIGEgZm9ybWF0IHN0cmluZywgdGhlbiB0aGlzXG5cdCAqIGFyZ3VtZW50IGlzIGVpdGhlciBgT3B0aW9uYCBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzLCBhbiBgT3B0aW9uYCBpbnN0YW5jZSwgb3IgYW4gb3B0aW9uXG5cdCAqIGRlc2NyaXB0aW9uLlxuXHQgKiBAcmV0dXJucyB7Q29udGV4dH1cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogICBjdHgub3B0aW9uKCctLWZvbycpOyAvLyBmb3JtYXQgZmxhZ1xuXHQgKiAgIGN0eC5vcHRpb24oJy0tZm9vJywgJ2VuYWJsZXMgZm9vIG1vZGUnKTsgLy8gZm9ybWF0IHdpdGggZGVzY3JpcHRpb25cblx0ICogICBjdHgub3B0aW9uKCctLWZvbycsIHsgZGVzYzogJ2VuYWJsZXMgZm9vIG1vZGUnIH0pOyAvLyBmb3JtYXQgd2l0aCBPcHRpb24gY3RvciBwYXJhbXNcblx0ICogICBjdHgub3B0aW9uKHsgJy0tZm9vJzogbnVsbCB9KTsgLy8gb2JqZWN0IHdpdGggZm9ybWF0IGZsYWdcblx0ICogICBjdHgub3B0aW9uKHsgJy0tZm9vJzogeyBkZXNjOiAnZW5hYmxlcyBmb28gbW9kZScgfSB9KTsgLy8gb2JqZWN0IHdpdGggT3B0aW9uIGN0b3IgcGFyYW1zXG5cdCAqICAgY3R4Lm9wdGlvbih7ICctLWZvbyc6IG5ldyBPcHRpb24oKSB9KTsgLy8gb2JqZWN0IG9mIGBPcHRpb25gIGluc3RhbmNlXG5cdCAqICAgY3R4Lm9wdGlvbihuZXcgT3B0aW9uKCctLWZvbycpKTsgLy8gYE9wdGlvbmAgaW5zdGFuY2Vcblx0ICogICBjdHgub3B0aW9uKG5ldyBPcHRpb25NYXAoKSk7IC8vIGBPcHRpb25NYXBgIGZyb20gYW5vdGhlciBpbnN0YW5jZVxuXHQgKiAgIGN0eC5vcHRpb24oWyAnU29tZSBHcm91cCcsIG5ldyBPcHRpb24oJy0tZm9vJyksICdBbm90aGVyIEdyb3VwJywgeyAnLS1iYXInOiBudWxsIH0gXSk7IC8vIGFuIGFycmF5IG9mIGdyb3VwZWQgb3B0aW9uc1xuXHQgKi9cblx0b3B0aW9uKGZvcm1hdCwgcGFyYW1zKSB7XG5cdFx0Y29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucy5hZGQoZm9ybWF0LCBwYXJhbXMpO1xuXG5cdFx0Zm9yIChjb25zdCBvcHQgb2Ygb3B0cykge1xuXHRcdFx0b3B0LnBhcmVudCA9IHRoaXM7XG5cblx0XHRcdGlmIChvcHQubG9uZykge1xuXHRcdFx0XHR0aGlzLmxvb2t1cC5sb25nW29wdC5sb25nXSA9IG9wdDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdC5zaG9ydCkge1xuXHRcdFx0XHR0aGlzLmxvb2t1cC5zaG9ydFtvcHQuc2hvcnRdID0gb3B0O1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGNvbnN0IFsgYWxpYXMsIHZpc2libGUgXSBvZiBPYmplY3QuZW50cmllcyhvcHQuYWxpYXNlcy5sb25nKSkge1xuXHRcdFx0XHRpZiAodmlzaWJsZSkge1xuXHRcdFx0XHRcdHRoaXMubG9va3VwLmxvbmdbYWxpYXNdID0gb3B0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoY29uc3QgWyBhbGlhcywgdmlzaWJsZSBdIG9mIE9iamVjdC5lbnRyaWVzKG9wdC5hbGlhc2VzLnNob3J0KSkge1xuXHRcdFx0XHRpZiAodmlzaWJsZSkge1xuXHRcdFx0XHRcdHRoaXMubG9va3VwLnNob3J0W2FsaWFzXSA9IG9wdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMucmV2Kys7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTY2FuIHBhcmVudCBjb250ZXh0cyB0byBmaW5kIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgaW4gdGhlIGJvdHRvbS1tb3N0IGNvbnRleHQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIHByb3BlcnR5IG5hbWUuXG5cdCAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIC0gQSBkZWZhdWx0IHZhbHVlIGlmIG5vIHZhbHVlIGlzIGZvdW5kLlxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICogQGFjY2VzcyBwcml2YXRlXG5cdCAqL1xuXHRwcm9wKG5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuXHRcdGxldCB2YWx1ZSA9IHRoaXNbbmFtZV07XG5cdFx0Zm9yIChsZXQgcCA9IHRoaXMucGFyZW50OyB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHA7IHAgPSBwLnBhcmVudCkge1xuXHRcdFx0aWYgKHAgaW5zdGFuY2VvZiBDb250ZXh0KSB7XG5cdFx0XHRcdHZhbHVlID0gcC5wcm9wKG5hbWUsIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYSBjb21tYW5kIG9yIGV4dGVuc2lvbiB0byBhZGQgdG8gdGhlIGxvb2t1cC5cblx0ICpcblx0ICogQHBhcmFtIHtDb21tYW5kfEV4dGVuc2lvbn0gaXQgLSBUaGUgY29tbWFuZCBvciBleHRlbnNpb24gaW5zdGFuY2UuXG5cdCAqIEBhY2Nlc3MgcHJpdmF0ZVxuXHQgKi9cblx0cmVnaXN0ZXIoaXQpIHtcblx0XHRsZXQgY21kcztcblx0XHRsZXQgZGVzdDtcblx0XHRpZiAoaXQuY2xpa2l0LmhhcygnRXh0ZW5zaW9uJykpIHtcblx0XHRcdGNtZHMgPSBPYmplY3QudmFsdWVzKGl0LmV4cG9ydHMpO1xuXHRcdFx0ZGVzdCA9ICdleHRlbnNpb25zJztcblx0XHR9IGVsc2UgaWYgKGl0LmNsaWtpdC5oYXMoJ0NvbW1hbmQnKSkge1xuXHRcdFx0Y21kcyA9IFsgaXQgXTtcblx0XHRcdGRlc3QgPSAnY29tbWFuZHMnO1xuXHRcdH1cblxuXHRcdGlmICghY21kcykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGl0LnBhcmVudCA9IHRoaXM7XG5cblx0XHRmb3IgKGNvbnN0IGNtZCBvZiBjbWRzKSB7XG5cdFx0XHR0aGlzLmxvb2t1cFtkZXN0XVtjbWQubmFtZV0gPSBjbWQ7XG5cblx0XHRcdGlmIChjbWQuYWxpYXNlcykge1xuXHRcdFx0XHRmb3IgKGNvbnN0IGFsaWFzIG9mIE9iamVjdC5rZXlzKGNtZC5hbGlhc2VzKSkge1xuXHRcdFx0XHRcdGlmICghdGhpc1tkZXN0XS5oYXMoYWxpYXMpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmxvb2t1cFtkZXN0XVthbGlhc10gPSBjbWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG4iXSwiZmlsZSI6InBhcnNlci9jb250ZXh0LmpzIn0=
