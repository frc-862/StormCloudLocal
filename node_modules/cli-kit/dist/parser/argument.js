"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _errors = _interopRequireDefault(require("../lib/errors"));

var _types = require("./types");

var _util = require("../lib/util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Tests if the name contains the required sequence (`<` and `>`).
 * @type {RegExp}
 */
const requiredRegExp = /^\s*(?:<(.+)>|\[(.+)\])\s*(\.\.\.\s*)?$/;
/**
 * Tests if the name contains the multiple sequence.
 * @type {RegExp}
 */

const multipleRegExp = /^(.*)\.\.\.\s*$/;
/**
 * Defines a argument.
 */

class Argument {
  /**
   * Creates an argument descriptor.
   *
   * @param {Object|String|Argument} [params] - Various parameters. If value is a `String`, then
   * see `params.name` below for usage.
   * @param {Function} [params.callback] - A function to call when the argument has been
   * processed. This happens parsing is complete.
   * @param {Boolean} [params.camelCase=true] - If option has a name or can derive a name from the
   * long option format, then it the name be camel cased.
   * @param {String} [params.desc] - The description of the argument used in the help output.
   * @param {String} [params.env] - The environment variable name to get a value from. If the
   * environment variable is set, it overrides the value parsed from the arguments.
   * @param {Boolean} [params.hidden=false] - When `true`, the argument is not displayed on the
   * help screen or auto-suggest.
   * @param {String} [params.hint] - The hint label if the argument expects a value.
   * @param {Number} [params.max] - When `type` is `int`, `number`, or `positiveInt`, the
   * validator will assert the value is less than or equal to the specified value.
   * @param {Number} [params.min] - When `type` is `int`, `number`, or `positiveInt`, the
   * validator will assert the value is greater than or equal to the specified value.
   * @param {Boolean} [params.multiple=false] - When `true`, the value becomes an array with all
   * remaining parsed arguments. Any subsequent argument definitions after a `multiple` argument
   * are ignored.
   * @param {String} [params.name] - The name of the argument. If the name is wrapped in angle
   * brackets (`<`, `>`), then the brackets are trimmed off and the argument is flagged as
   * required (unless `params.required` is explicitly set to `false`). If the name is wrapped in
   * square brackets (`[`, `]`), then the brackets are trimmed off. If the name ends with `...`
   * and `params.multiple` is not specified, then it will set `params.multiple` to `true`.
   * @param {Boolean} [params.required=false] - Marks the option value as required.
   * @param {String} [params.type] - The argument type to coerce the data type into.
   * @access public
   */
  constructor(params) {
    /*
    { name: 'path', required: true, regex: /^\//, desc: 'the path to request' },
    { name: 'json', type: 'json', desc: 'an option JSON payload to send' }
    */
    if (!params || typeof params !== 'string' && typeof params !== 'object' || Array.isArray(params)) {
      throw _errors.default.INVALID_ARGUMENT('Expected argument params to be a non-empty string or an object', {
        name: 'params',
        scope: 'Argument.constructor',
        value: params
      });
    }

    if (typeof params === 'string') {
      params = {
        name: params
      };
    }

    let {
      name
    } = params;

    if (typeof name !== 'string' || !(name = name.trim())) {
      throw _errors.default.INVALID_ARGUMENT('Expected argument name to be a non-empty string', {
        name: 'name',
        scope: 'Argument.constructor',
        value: name
      });
    }

    let {
      multiple,
      required
    } = params; // check if the name contains a required sequence

    let m = name.match(requiredRegExp);

    if (m) {
      if (required === undefined && m[1]) {
        required = true;
      }

      name = (m[1] || m[2]).trim() + (m[3] || '');
    }

    let redact = true;

    if (name.startsWith('~')) {
      name = name.substring(1);
      redact = false;
    } // check if the name contains a multiple sequence


    m = name.match(multipleRegExp);

    if (m) {
      if (multiple === undefined) {
        multiple = true;
      }

      name = m[1].trim();
    }

    this.callback = params.callback;
    this.camelCase = name ? params.camelCase !== false : false;
    this.datatype = (0, _types.checkType)(params.type, 'string');
    this.desc = params.desc;
    this.hidden = !!params.hidden;
    this.hint = params.hint || name;
    this.name = name;
    this.max = typeof params.max === 'number' ? params.max : null;
    this.min = typeof params.min === 'number' ? params.max : null;
    this.multiple = !!multiple;
    this.redact = redact;
    this.required = !!required;
    this.regex = params.type instanceof RegExp ? params.type : null;
    (0, _util.declareCLIKitClass)(this, 'Argument'); // mix in any other custom props

    for (const [key, value] of Object.entries(params)) {
      if (!Object.prototype.hasOwnProperty.call(this, key)) {
        this[key] = value;
      }
    }
  }
  /**
   * Returns this argument's schema.
   *
   * @type {Object}
   */


  get schema() {
    return {
      desc: this.desc,
      multiple: this.multiple,
      name: this.name,
      required: this.required,
      type: this.type
    };
  }
  /**
   * Transforms the given argument value based on its type.
   *
   * @param {*} value - The value to transform.
   * @returns {*}
   * @access public
   */


  transform(value) {
    value = (0, _types.transformValue)(value, this.datatype);

    switch (this.datatype) {
      case 'positiveInt':
      case 'int':
      case 'number':
        if (this.min !== null && value < this.min) {
          throw _errors.default.RANGE_ERROR(`Value must be greater than or equal to ${this.min}`, {
            max: this.max,
            min: this.min,
            name: `transform.${this.type}`,
            scope: 'Argument.transform',
            value
          });
        }

        if (this.max !== null && value > this.max) {
          throw _errors.default.RANGE_ERROR(`Value must be less than or equal to ${this.max}`, {
            max: this.max,
            min: this.min,
            name: `transform.${this.type}`,
            scope: 'Argument.transform',
            value
          });
        }

        break;

      case 'regex':
        if (!this.regex.test(value)) {
          throw _errors.default.INVALID_VALUE(this.errorMsg || 'Invalid value', {
            name: 'regex',
            regex: this.regex,
            scope: 'Option.transform',
            value
          });
        }

        break;
    }

    return value;
  }

}

exports.default = Argument;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcnNlci9hcmd1bWVudC5qcyJdLCJuYW1lcyI6WyJyZXF1aXJlZFJlZ0V4cCIsIm11bHRpcGxlUmVnRXhwIiwiQXJndW1lbnQiLCJjb25zdHJ1Y3RvciIsInBhcmFtcyIsIkFycmF5IiwiaXNBcnJheSIsIkUiLCJJTlZBTElEX0FSR1VNRU5UIiwibmFtZSIsInNjb3BlIiwidmFsdWUiLCJ0cmltIiwibXVsdGlwbGUiLCJyZXF1aXJlZCIsIm0iLCJtYXRjaCIsInVuZGVmaW5lZCIsInJlZGFjdCIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJjYWxsYmFjayIsImNhbWVsQ2FzZSIsImRhdGF0eXBlIiwidHlwZSIsImRlc2MiLCJoaWRkZW4iLCJoaW50IiwibWF4IiwibWluIiwicmVnZXgiLCJSZWdFeHAiLCJrZXkiLCJPYmplY3QiLCJlbnRyaWVzIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwic2NoZW1hIiwidHJhbnNmb3JtIiwiUkFOR0VfRVJST1IiLCJ0ZXN0IiwiSU5WQUxJRF9WQUxVRSIsImVycm9yTXNnIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBRUE7O0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1BLGNBQWMsR0FBRyx5Q0FBdkI7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxNQUFNQyxjQUFjLEdBQUcsaUJBQXZCO0FBRUE7QUFDQTtBQUNBOztBQUNlLE1BQU1DLFFBQU4sQ0FBZTtBQUM3QjtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNDQyxFQUFBQSxXQUFXLENBQUNDLE1BQUQsRUFBUztBQUNuQjtBQUNGO0FBQ0E7QUFDQTtBQUVFLFFBQUksQ0FBQ0EsTUFBRCxJQUFZLE9BQU9BLE1BQVAsS0FBa0IsUUFBbEIsSUFBOEIsT0FBT0EsTUFBUCxLQUFrQixRQUE1RCxJQUF5RUMsS0FBSyxDQUFDQyxPQUFOLENBQWNGLE1BQWQsQ0FBN0UsRUFBb0c7QUFDbkcsWUFBTUcsZ0JBQUVDLGdCQUFGLENBQW1CLGdFQUFuQixFQUFxRjtBQUFFQyxRQUFBQSxJQUFJLEVBQUUsUUFBUjtBQUFrQkMsUUFBQUEsS0FBSyxFQUFFLHNCQUF6QjtBQUFpREMsUUFBQUEsS0FBSyxFQUFFUDtBQUF4RCxPQUFyRixDQUFOO0FBQ0E7O0FBRUQsUUFBSSxPQUFPQSxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO0FBQy9CQSxNQUFBQSxNQUFNLEdBQUc7QUFDUkssUUFBQUEsSUFBSSxFQUFFTDtBQURFLE9BQVQ7QUFHQTs7QUFFRCxRQUFJO0FBQUVLLE1BQUFBO0FBQUYsUUFBV0wsTUFBZjs7QUFDQSxRQUFJLE9BQU9LLElBQVAsS0FBZ0IsUUFBaEIsSUFBNEIsRUFBRUEsSUFBSSxHQUFHQSxJQUFJLENBQUNHLElBQUwsRUFBVCxDQUFoQyxFQUF1RDtBQUN0RCxZQUFNTCxnQkFBRUMsZ0JBQUYsQ0FBbUIsaURBQW5CLEVBQXNFO0FBQUVDLFFBQUFBLElBQUksRUFBRSxNQUFSO0FBQWdCQyxRQUFBQSxLQUFLLEVBQUUsc0JBQXZCO0FBQStDQyxRQUFBQSxLQUFLLEVBQUVGO0FBQXRELE9BQXRFLENBQU47QUFDQTs7QUFFRCxRQUFJO0FBQUVJLE1BQUFBLFFBQUY7QUFBWUMsTUFBQUE7QUFBWixRQUF5QlYsTUFBN0IsQ0FyQm1CLENBdUJuQjs7QUFDQSxRQUFJVyxDQUFDLEdBQUdOLElBQUksQ0FBQ08sS0FBTCxDQUFXaEIsY0FBWCxDQUFSOztBQUNBLFFBQUllLENBQUosRUFBTztBQUNOLFVBQUlELFFBQVEsS0FBS0csU0FBYixJQUEwQkYsQ0FBQyxDQUFDLENBQUQsQ0FBL0IsRUFBb0M7QUFDbkNELFFBQUFBLFFBQVEsR0FBRyxJQUFYO0FBQ0E7O0FBQ0RMLE1BQUFBLElBQUksR0FBRyxDQUFDTSxDQUFDLENBQUMsQ0FBRCxDQUFELElBQVFBLENBQUMsQ0FBQyxDQUFELENBQVYsRUFBZUgsSUFBZixNQUF5QkcsQ0FBQyxDQUFDLENBQUQsQ0FBRCxJQUFRLEVBQWpDLENBQVA7QUFDQTs7QUFFRCxRQUFJRyxNQUFNLEdBQUcsSUFBYjs7QUFDQSxRQUFJVCxJQUFJLENBQUNVLFVBQUwsQ0FBZ0IsR0FBaEIsQ0FBSixFQUEwQjtBQUN6QlYsTUFBQUEsSUFBSSxHQUFHQSxJQUFJLENBQUNXLFNBQUwsQ0FBZSxDQUFmLENBQVA7QUFDQUYsTUFBQUEsTUFBTSxHQUFHLEtBQVQ7QUFDQSxLQXBDa0IsQ0FzQ25COzs7QUFDQUgsSUFBQUEsQ0FBQyxHQUFHTixJQUFJLENBQUNPLEtBQUwsQ0FBV2YsY0FBWCxDQUFKOztBQUNBLFFBQUljLENBQUosRUFBTztBQUNOLFVBQUlGLFFBQVEsS0FBS0ksU0FBakIsRUFBNEI7QUFDM0JKLFFBQUFBLFFBQVEsR0FBRyxJQUFYO0FBQ0E7O0FBQ0RKLE1BQUFBLElBQUksR0FBR00sQ0FBQyxDQUFDLENBQUQsQ0FBRCxDQUFLSCxJQUFMLEVBQVA7QUFDQTs7QUFFRCxTQUFLUyxRQUFMLEdBQWlCakIsTUFBTSxDQUFDaUIsUUFBeEI7QUFDQSxTQUFLQyxTQUFMLEdBQWlCYixJQUFJLEdBQUdMLE1BQU0sQ0FBQ2tCLFNBQVAsS0FBcUIsS0FBeEIsR0FBZ0MsS0FBckQ7QUFDQSxTQUFLQyxRQUFMLEdBQWlCLHNCQUFVbkIsTUFBTSxDQUFDb0IsSUFBakIsRUFBdUIsUUFBdkIsQ0FBakI7QUFDQSxTQUFLQyxJQUFMLEdBQWlCckIsTUFBTSxDQUFDcUIsSUFBeEI7QUFDQSxTQUFLQyxNQUFMLEdBQWlCLENBQUMsQ0FBQ3RCLE1BQU0sQ0FBQ3NCLE1BQTFCO0FBQ0EsU0FBS0MsSUFBTCxHQUFpQnZCLE1BQU0sQ0FBQ3VCLElBQVAsSUFBZWxCLElBQWhDO0FBQ0EsU0FBS0EsSUFBTCxHQUFpQkEsSUFBakI7QUFDQSxTQUFLbUIsR0FBTCxHQUFpQixPQUFPeEIsTUFBTSxDQUFDd0IsR0FBZCxLQUFzQixRQUF0QixHQUFpQ3hCLE1BQU0sQ0FBQ3dCLEdBQXhDLEdBQThDLElBQS9EO0FBQ0EsU0FBS0MsR0FBTCxHQUFpQixPQUFPekIsTUFBTSxDQUFDeUIsR0FBZCxLQUFzQixRQUF0QixHQUFpQ3pCLE1BQU0sQ0FBQ3dCLEdBQXhDLEdBQThDLElBQS9EO0FBQ0EsU0FBS2YsUUFBTCxHQUFpQixDQUFDLENBQUNBLFFBQW5CO0FBQ0EsU0FBS0ssTUFBTCxHQUFpQkEsTUFBakI7QUFDQSxTQUFLSixRQUFMLEdBQWlCLENBQUMsQ0FBQ0EsUUFBbkI7QUFDQSxTQUFLZ0IsS0FBTCxHQUFpQjFCLE1BQU0sQ0FBQ29CLElBQVAsWUFBdUJPLE1BQXZCLEdBQWdDM0IsTUFBTSxDQUFDb0IsSUFBdkMsR0FBOEMsSUFBL0Q7QUFFQSxrQ0FBbUIsSUFBbkIsRUFBeUIsVUFBekIsRUE3RG1CLENBK0RuQjs7QUFDQSxTQUFLLE1BQU0sQ0FBRVEsR0FBRixFQUFPckIsS0FBUCxDQUFYLElBQTZCc0IsTUFBTSxDQUFDQyxPQUFQLENBQWU5QixNQUFmLENBQTdCLEVBQXFEO0FBQ3BELFVBQUksQ0FBQzZCLE1BQU0sQ0FBQ0UsU0FBUCxDQUFpQkMsY0FBakIsQ0FBZ0NDLElBQWhDLENBQXFDLElBQXJDLEVBQTJDTCxHQUEzQyxDQUFMLEVBQXNEO0FBQ3JELGFBQUtBLEdBQUwsSUFBWXJCLEtBQVo7QUFDQTtBQUNEO0FBQ0Q7QUFFRDtBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDVyxNQUFOMkIsTUFBTSxHQUFHO0FBQ1osV0FBTztBQUNOYixNQUFBQSxJQUFJLEVBQU0sS0FBS0EsSUFEVDtBQUVOWixNQUFBQSxRQUFRLEVBQUUsS0FBS0EsUUFGVDtBQUdOSixNQUFBQSxJQUFJLEVBQU0sS0FBS0EsSUFIVDtBQUlOSyxNQUFBQSxRQUFRLEVBQUUsS0FBS0EsUUFKVDtBQUtOVSxNQUFBQSxJQUFJLEVBQU0sS0FBS0E7QUFMVCxLQUFQO0FBT0E7QUFFRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0NlLEVBQUFBLFNBQVMsQ0FBQzVCLEtBQUQsRUFBUTtBQUNoQkEsSUFBQUEsS0FBSyxHQUFHLDJCQUFlQSxLQUFmLEVBQXNCLEtBQUtZLFFBQTNCLENBQVI7O0FBRUEsWUFBUSxLQUFLQSxRQUFiO0FBQ0MsV0FBSyxhQUFMO0FBQ0EsV0FBSyxLQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0MsWUFBSSxLQUFLTSxHQUFMLEtBQWEsSUFBYixJQUFxQmxCLEtBQUssR0FBRyxLQUFLa0IsR0FBdEMsRUFBMkM7QUFDMUMsZ0JBQU10QixnQkFBRWlDLFdBQUYsQ0FBZSwwQ0FBeUMsS0FBS1gsR0FBSSxFQUFqRSxFQUFvRTtBQUFFRCxZQUFBQSxHQUFHLEVBQUUsS0FBS0EsR0FBWjtBQUFpQkMsWUFBQUEsR0FBRyxFQUFFLEtBQUtBLEdBQTNCO0FBQWdDcEIsWUFBQUEsSUFBSSxFQUFHLGFBQVksS0FBS2UsSUFBSyxFQUE3RDtBQUFnRWQsWUFBQUEsS0FBSyxFQUFFLG9CQUF2RTtBQUE2RkMsWUFBQUE7QUFBN0YsV0FBcEUsQ0FBTjtBQUNBOztBQUNELFlBQUksS0FBS2lCLEdBQUwsS0FBYSxJQUFiLElBQXFCakIsS0FBSyxHQUFHLEtBQUtpQixHQUF0QyxFQUEyQztBQUMxQyxnQkFBTXJCLGdCQUFFaUMsV0FBRixDQUFlLHVDQUFzQyxLQUFLWixHQUFJLEVBQTlELEVBQWlFO0FBQUVBLFlBQUFBLEdBQUcsRUFBRSxLQUFLQSxHQUFaO0FBQWlCQyxZQUFBQSxHQUFHLEVBQUUsS0FBS0EsR0FBM0I7QUFBZ0NwQixZQUFBQSxJQUFJLEVBQUcsYUFBWSxLQUFLZSxJQUFLLEVBQTdEO0FBQWdFZCxZQUFBQSxLQUFLLEVBQUUsb0JBQXZFO0FBQTZGQyxZQUFBQTtBQUE3RixXQUFqRSxDQUFOO0FBQ0E7O0FBQ0Q7O0FBRUQsV0FBSyxPQUFMO0FBQ0MsWUFBSSxDQUFDLEtBQUttQixLQUFMLENBQVdXLElBQVgsQ0FBZ0I5QixLQUFoQixDQUFMLEVBQTZCO0FBQzVCLGdCQUFNSixnQkFBRW1DLGFBQUYsQ0FBZ0IsS0FBS0MsUUFBTCxJQUFpQixlQUFqQyxFQUFrRDtBQUFFbEMsWUFBQUEsSUFBSSxFQUFFLE9BQVI7QUFBaUJxQixZQUFBQSxLQUFLLEVBQUUsS0FBS0EsS0FBN0I7QUFBb0NwQixZQUFBQSxLQUFLLEVBQUUsa0JBQTNDO0FBQStEQyxZQUFBQTtBQUEvRCxXQUFsRCxDQUFOO0FBQ0E7O0FBQ0Q7QUFoQkY7O0FBbUJBLFdBQU9BLEtBQVA7QUFDQTs7QUFwSjRCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEUgZnJvbSAnLi4vbGliL2Vycm9ycyc7XG5cbmltcG9ydCB7IGNoZWNrVHlwZSwgdHJhbnNmb3JtVmFsdWUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGRlY2xhcmVDTElLaXRDbGFzcyB9IGZyb20gJy4uL2xpYi91dGlsJztcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgbmFtZSBjb250YWlucyB0aGUgcmVxdWlyZWQgc2VxdWVuY2UgKGA8YCBhbmQgYD5gKS5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbmNvbnN0IHJlcXVpcmVkUmVnRXhwID0gL15cXHMqKD86PCguKyk+fFxcWyguKylcXF0pXFxzKihcXC5cXC5cXC5cXHMqKT8kLztcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgbmFtZSBjb250YWlucyB0aGUgbXVsdGlwbGUgc2VxdWVuY2UuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5jb25zdCBtdWx0aXBsZVJlZ0V4cCA9IC9eKC4qKVxcLlxcLlxcLlxccyokLztcblxuLyoqXG4gKiBEZWZpbmVzIGEgYXJndW1lbnQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFyZ3VtZW50IHtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJndW1lbnQgZGVzY3JpcHRvci5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfEFyZ3VtZW50fSBbcGFyYW1zXSAtIFZhcmlvdXMgcGFyYW1ldGVycy4gSWYgdmFsdWUgaXMgYSBgU3RyaW5nYCwgdGhlblxuXHQgKiBzZWUgYHBhcmFtcy5uYW1lYCBiZWxvdyBmb3IgdXNhZ2UuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJhbXMuY2FsbGJhY2tdIC0gQSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGFyZ3VtZW50IGhhcyBiZWVuXG5cdCAqIHByb2Nlc3NlZC4gVGhpcyBoYXBwZW5zIHBhcnNpbmcgaXMgY29tcGxldGUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5jYW1lbENhc2U9dHJ1ZV0gLSBJZiBvcHRpb24gaGFzIGEgbmFtZSBvciBjYW4gZGVyaXZlIGEgbmFtZSBmcm9tIHRoZVxuXHQgKiBsb25nIG9wdGlvbiBmb3JtYXQsIHRoZW4gaXQgdGhlIG5hbWUgYmUgY2FtZWwgY2FzZWQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLmRlc2NdIC0gVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBhcmd1bWVudCB1c2VkIGluIHRoZSBoZWxwIG91dHB1dC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMuZW52XSAtIFRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBuYW1lIHRvIGdldCBhIHZhbHVlIGZyb20uIElmIHRoZVxuXHQgKiBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBzZXQsIGl0IG92ZXJyaWRlcyB0aGUgdmFsdWUgcGFyc2VkIGZyb20gdGhlIGFyZ3VtZW50cy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmhpZGRlbj1mYWxzZV0gLSBXaGVuIGB0cnVlYCwgdGhlIGFyZ3VtZW50IGlzIG5vdCBkaXNwbGF5ZWQgb24gdGhlXG5cdCAqIGhlbHAgc2NyZWVuIG9yIGF1dG8tc3VnZ2VzdC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMuaGludF0gLSBUaGUgaGludCBsYWJlbCBpZiB0aGUgYXJndW1lbnQgZXhwZWN0cyBhIHZhbHVlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5tYXhdIC0gV2hlbiBgdHlwZWAgaXMgYGludGAsIGBudW1iZXJgLCBvciBgcG9zaXRpdmVJbnRgLCB0aGVcblx0ICogdmFsaWRhdG9yIHdpbGwgYXNzZXJ0IHRoZSB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMubWluXSAtIFdoZW4gYHR5cGVgIGlzIGBpbnRgLCBgbnVtYmVyYCwgb3IgYHBvc2l0aXZlSW50YCwgdGhlXG5cdCAqIHZhbGlkYXRvciB3aWxsIGFzc2VydCB0aGUgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5tdWx0aXBsZT1mYWxzZV0gLSBXaGVuIGB0cnVlYCwgdGhlIHZhbHVlIGJlY29tZXMgYW4gYXJyYXkgd2l0aCBhbGxcblx0ICogcmVtYWluaW5nIHBhcnNlZCBhcmd1bWVudHMuIEFueSBzdWJzZXF1ZW50IGFyZ3VtZW50IGRlZmluaXRpb25zIGFmdGVyIGEgYG11bHRpcGxlYCBhcmd1bWVudFxuXHQgKiBhcmUgaWdub3JlZC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMubmFtZV0gLSBUaGUgbmFtZSBvZiB0aGUgYXJndW1lbnQuIElmIHRoZSBuYW1lIGlzIHdyYXBwZWQgaW4gYW5nbGVcblx0ICogYnJhY2tldHMgKGA8YCwgYD5gKSwgdGhlbiB0aGUgYnJhY2tldHMgYXJlIHRyaW1tZWQgb2ZmIGFuZCB0aGUgYXJndW1lbnQgaXMgZmxhZ2dlZCBhc1xuXHQgKiByZXF1aXJlZCAodW5sZXNzIGBwYXJhbXMucmVxdWlyZWRgIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGBmYWxzZWApLiBJZiB0aGUgbmFtZSBpcyB3cmFwcGVkIGluXG5cdCAqIHNxdWFyZSBicmFja2V0cyAoYFtgLCBgXWApLCB0aGVuIHRoZSBicmFja2V0cyBhcmUgdHJpbW1lZCBvZmYuIElmIHRoZSBuYW1lIGVuZHMgd2l0aCBgLi4uYFxuXHQgKiBhbmQgYHBhcmFtcy5tdWx0aXBsZWAgaXMgbm90IHNwZWNpZmllZCwgdGhlbiBpdCB3aWxsIHNldCBgcGFyYW1zLm11bHRpcGxlYCB0byBgdHJ1ZWAuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5yZXF1aXJlZD1mYWxzZV0gLSBNYXJrcyB0aGUgb3B0aW9uIHZhbHVlIGFzIHJlcXVpcmVkLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy50eXBlXSAtIFRoZSBhcmd1bWVudCB0eXBlIHRvIGNvZXJjZSB0aGUgZGF0YSB0eXBlIGludG8uXG5cdCAqIEBhY2Nlc3MgcHVibGljXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihwYXJhbXMpIHtcblx0XHQvKlxuXHRcdHsgbmFtZTogJ3BhdGgnLCByZXF1aXJlZDogdHJ1ZSwgcmVnZXg6IC9eXFwvLywgZGVzYzogJ3RoZSBwYXRoIHRvIHJlcXVlc3QnIH0sXG5cdFx0eyBuYW1lOiAnanNvbicsIHR5cGU6ICdqc29uJywgZGVzYzogJ2FuIG9wdGlvbiBKU09OIHBheWxvYWQgdG8gc2VuZCcgfVxuXHRcdCovXG5cblx0XHRpZiAoIXBhcmFtcyB8fCAodHlwZW9mIHBhcmFtcyAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHBhcmFtcyAhPT0gJ29iamVjdCcpIHx8IEFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuXHRcdFx0dGhyb3cgRS5JTlZBTElEX0FSR1VNRU5UKCdFeHBlY3RlZCBhcmd1bWVudCBwYXJhbXMgdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nIG9yIGFuIG9iamVjdCcsIHsgbmFtZTogJ3BhcmFtcycsIHNjb3BlOiAnQXJndW1lbnQuY29uc3RydWN0b3InLCB2YWx1ZTogcGFyYW1zIH0pO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJykge1xuXHRcdFx0cGFyYW1zID0ge1xuXHRcdFx0XHRuYW1lOiBwYXJhbXNcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0bGV0IHsgbmFtZSB9ID0gcGFyYW1zO1xuXHRcdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgIShuYW1lID0gbmFtZS50cmltKCkpKSB7XG5cdFx0XHR0aHJvdyBFLklOVkFMSURfQVJHVU1FTlQoJ0V4cGVjdGVkIGFyZ3VtZW50IG5hbWUgdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nJywgeyBuYW1lOiAnbmFtZScsIHNjb3BlOiAnQXJndW1lbnQuY29uc3RydWN0b3InLCB2YWx1ZTogbmFtZSB9KTtcblx0XHR9XG5cblx0XHRsZXQgeyBtdWx0aXBsZSwgcmVxdWlyZWQgfSA9IHBhcmFtcztcblxuXHRcdC8vIGNoZWNrIGlmIHRoZSBuYW1lIGNvbnRhaW5zIGEgcmVxdWlyZWQgc2VxdWVuY2Vcblx0XHRsZXQgbSA9IG5hbWUubWF0Y2gocmVxdWlyZWRSZWdFeHApO1xuXHRcdGlmIChtKSB7XG5cdFx0XHRpZiAocmVxdWlyZWQgPT09IHVuZGVmaW5lZCAmJiBtWzFdKSB7XG5cdFx0XHRcdHJlcXVpcmVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG5hbWUgPSAobVsxXSB8fCBtWzJdKS50cmltKCkgKyAobVszXSB8fCAnJyk7XG5cdFx0fVxuXG5cdFx0bGV0IHJlZGFjdCA9IHRydWU7XG5cdFx0aWYgKG5hbWUuc3RhcnRzV2l0aCgnficpKSB7XG5cdFx0XHRuYW1lID0gbmFtZS5zdWJzdHJpbmcoMSk7XG5cdFx0XHRyZWRhY3QgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBjaGVjayBpZiB0aGUgbmFtZSBjb250YWlucyBhIG11bHRpcGxlIHNlcXVlbmNlXG5cdFx0bSA9IG5hbWUubWF0Y2gobXVsdGlwbGVSZWdFeHApO1xuXHRcdGlmIChtKSB7XG5cdFx0XHRpZiAobXVsdGlwbGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRtdWx0aXBsZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRuYW1lID0gbVsxXS50cmltKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jYWxsYmFjayAgPSBwYXJhbXMuY2FsbGJhY2s7XG5cdFx0dGhpcy5jYW1lbENhc2UgPSBuYW1lID8gcGFyYW1zLmNhbWVsQ2FzZSAhPT0gZmFsc2UgOiBmYWxzZTtcblx0XHR0aGlzLmRhdGF0eXBlICA9IGNoZWNrVHlwZShwYXJhbXMudHlwZSwgJ3N0cmluZycpO1xuXHRcdHRoaXMuZGVzYyAgICAgID0gcGFyYW1zLmRlc2M7XG5cdFx0dGhpcy5oaWRkZW4gICAgPSAhIXBhcmFtcy5oaWRkZW47XG5cdFx0dGhpcy5oaW50ICAgICAgPSBwYXJhbXMuaGludCB8fCBuYW1lO1xuXHRcdHRoaXMubmFtZSAgICAgID0gbmFtZTtcblx0XHR0aGlzLm1heCAgICAgICA9IHR5cGVvZiBwYXJhbXMubWF4ID09PSAnbnVtYmVyJyA/IHBhcmFtcy5tYXggOiBudWxsO1xuXHRcdHRoaXMubWluICAgICAgID0gdHlwZW9mIHBhcmFtcy5taW4gPT09ICdudW1iZXInID8gcGFyYW1zLm1heCA6IG51bGw7XG5cdFx0dGhpcy5tdWx0aXBsZSAgPSAhIW11bHRpcGxlO1xuXHRcdHRoaXMucmVkYWN0ICAgID0gcmVkYWN0O1xuXHRcdHRoaXMucmVxdWlyZWQgID0gISFyZXF1aXJlZDtcblx0XHR0aGlzLnJlZ2V4ICAgICA9IHBhcmFtcy50eXBlIGluc3RhbmNlb2YgUmVnRXhwID8gcGFyYW1zLnR5cGUgOiBudWxsO1xuXG5cdFx0ZGVjbGFyZUNMSUtpdENsYXNzKHRoaXMsICdBcmd1bWVudCcpO1xuXG5cdFx0Ly8gbWl4IGluIGFueSBvdGhlciBjdXN0b20gcHJvcHNcblx0XHRmb3IgKGNvbnN0IFsga2V5LCB2YWx1ZSBdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpIHtcblx0XHRcdGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIGtleSkpIHtcblx0XHRcdFx0dGhpc1trZXldID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhpcyBhcmd1bWVudCdzIHNjaGVtYS5cblx0ICpcblx0ICogQHR5cGUge09iamVjdH1cblx0ICovXG5cdGdldCBzY2hlbWEoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGRlc2M6ICAgICB0aGlzLmRlc2MsXG5cdFx0XHRtdWx0aXBsZTogdGhpcy5tdWx0aXBsZSxcblx0XHRcdG5hbWU6ICAgICB0aGlzLm5hbWUsXG5cdFx0XHRyZXF1aXJlZDogdGhpcy5yZXF1aXJlZCxcblx0XHRcdHR5cGU6ICAgICB0aGlzLnR5cGVcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyYW5zZm9ybXMgdGhlIGdpdmVuIGFyZ3VtZW50IHZhbHVlIGJhc2VkIG9uIGl0cyB0eXBlLlxuXHQgKlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRyYW5zZm9ybS5cblx0ICogQHJldHVybnMgeyp9XG5cdCAqIEBhY2Nlc3MgcHVibGljXG5cdCAqL1xuXHR0cmFuc2Zvcm0odmFsdWUpIHtcblx0XHR2YWx1ZSA9IHRyYW5zZm9ybVZhbHVlKHZhbHVlLCB0aGlzLmRhdGF0eXBlKTtcblxuXHRcdHN3aXRjaCAodGhpcy5kYXRhdHlwZSkge1xuXHRcdFx0Y2FzZSAncG9zaXRpdmVJbnQnOlxuXHRcdFx0Y2FzZSAnaW50Jzpcblx0XHRcdGNhc2UgJ251bWJlcic6XG5cdFx0XHRcdGlmICh0aGlzLm1pbiAhPT0gbnVsbCAmJiB2YWx1ZSA8IHRoaXMubWluKSB7XG5cdFx0XHRcdFx0dGhyb3cgRS5SQU5HRV9FUlJPUihgVmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHt0aGlzLm1pbn1gLCB7IG1heDogdGhpcy5tYXgsIG1pbjogdGhpcy5taW4sIG5hbWU6IGB0cmFuc2Zvcm0uJHt0aGlzLnR5cGV9YCwgc2NvcGU6ICdBcmd1bWVudC50cmFuc2Zvcm0nLCB2YWx1ZSB9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5tYXggIT09IG51bGwgJiYgdmFsdWUgPiB0aGlzLm1heCkge1xuXHRcdFx0XHRcdHRocm93IEUuUkFOR0VfRVJST1IoYFZhbHVlIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7dGhpcy5tYXh9YCwgeyBtYXg6IHRoaXMubWF4LCBtaW46IHRoaXMubWluLCBuYW1lOiBgdHJhbnNmb3JtLiR7dGhpcy50eXBlfWAsIHNjb3BlOiAnQXJndW1lbnQudHJhbnNmb3JtJywgdmFsdWUgfSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ3JlZ2V4Jzpcblx0XHRcdFx0aWYgKCF0aGlzLnJlZ2V4LnRlc3QodmFsdWUpKSB7XG5cdFx0XHRcdFx0dGhyb3cgRS5JTlZBTElEX1ZBTFVFKHRoaXMuZXJyb3JNc2cgfHwgJ0ludmFsaWQgdmFsdWUnLCB7IG5hbWU6ICdyZWdleCcsIHJlZ2V4OiB0aGlzLnJlZ2V4LCBzY29wZTogJ09wdGlvbi50cmFuc2Zvcm0nLCB2YWx1ZSB9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cbn1cbiJdLCJmaWxlIjoicGFyc2VyL2FyZ3VtZW50LmpzIn0=
