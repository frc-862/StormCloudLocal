"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Type = void 0;
exports.checkType = checkType;
exports.registerType = registerType;
exports.transformValue = transformValue;
exports.types = void 0;

var _errors = _interopRequireDefault(require("../lib/errors"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const dateRegExp = /^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\.\d+)?Z?)?$/i;
const hexRegExp = /^0x[A-Fa-f0-9]+$/;
const intRegExp = /^-?\d+$/;
const noRegExp = /^no?$/i;
const yesRegExp = /^y(es)?$/i;
/**
 * Options/args have a type. Generally they are either a `bool` (flag) or
 * `string` (option/arg). However, for non-bool options, you can specify a type
 * that will validate and format the value.
 *
 * Below is the list of supported types and their transformers.
 */

const types = {};
/**
 * Ensures that the specified list of types is indeed an array and each value is a supported type,
 * then returns the cleaned up list of types or a default value if no types were found.
 *
 * @param {String|RegExp} type - A list of types to validate.
 * @param {Array.<String>} [otherTypes] - An optional list of types to default to if no
 * types were originally specified.
 * @returns {String}
 */

exports.types = types;

function checkType(type, ...otherTypes) {
  if (!type) {
    for (const other of otherTypes) {
      if (typeof other !== 'undefined' && other !== null && types[other]) {
        return other;
      }
    }
  } else if (type instanceof RegExp) {
    return 'regex';
  } else if (!types[type]) {
    throw _errors.default.INVALID_DATA_TYPE(`Unsupported type "${type}"`, {
      name: 'type',
      scope: 'types.checkType',
      types: Object.keys(types),
      value: type
    });
  }

  return type;
}
/**
 * Transforms a value to the first successfully transformed data type.
 *
 * @param {*} value - The value to transform.
 * @param {String} [type] - A specific data type to try to coerce the value into.
 * @returns {*}
 */


function transformValue(value, type) {
  if (!type && typeof value === 'string') {
    const lvalue = value.toLowerCase(); // try as a boolean

    if (lvalue === 'true') {
      return true;
    }

    if (lvalue === 'false') {
      return false;
    } // try as a number


    const num = Number(value);

    if (!isNaN(num)) {
      return num;
    } // try as a date


    if (dateRegExp.test(value)) {
      return new Date(value);
    } // try as json


    try {
      return JSON.parse(value);
    } catch (e) {// nope
    }
  } else if (types[type] && typeof types[type].transform === 'function') {
    value = types[type].transform(value);
  } // return the original value


  return value;
}
/**
 * Defines a option/argument data type and its transform function.
 */


class Type {
  /**
   * Creates the data type instance.
   *
   * @param {Object} params - Various options.
   * @param {String} params.name - The name of the data type.
   * @param {Function} [params.transform] - A function that transforms the parsed option/argument
   * string value to the correct data type. By default, no transform is applied and values will
   * remain as strings.
   * @access public
   */
  constructor(params) {
    if (!params || typeof params !== 'object' || Array.isArray(params)) {
      throw _errors.default.TYPE_ERROR('Expected params to be an object', {
        name: 'params',
        scope: 'Type.constructor',
        value: params
      });
    }

    if (!params.name || typeof params.name !== 'string') {
      throw _errors.default.TYPE_ERROR('Missing type name', {
        name: 'name',
        scope: 'Type.constructor',
        value: params.name
      });
    }

    if (params.transform && typeof params.transform !== 'function') {
      throw _errors.default.TYPE_ERROR('Expected transform to be a function', {
        name: 'transform',
        scope: 'Type.constructor',
        value: params.transform
      });
    }

    this.name = params.name;
    this.transform = params.transform;
  }

}
/**
 * Registers a type.
 *
 * @param {Type|Object} params - A `Type` instance or params for constructing a new `Type` instance.
 */


exports.Type = Type;

function registerType(params) {
  if (!(params instanceof Type)) {
    params = new Type(params);
  }

  types[params.name] = params;
}

registerType({
  name: 'bool',

  transform(value) {
    return value && value !== 'false';
  }

});
registerType({
  name: 'count'
});
registerType({
  name: 'date',

  transform(value) {
    let date;

    if (intRegExp.test(value)) {
      const num = Number(value);

      if (!isNaN(num) && num > 0) {
        date = new Date(num * 1000);
      }
    } else if (dateRegExp.test(value)) {
      date = new Date(value);
    }

    if (!date || date.toString() === 'Invalid date') {
      throw _errors.default.INVALID_DATE('Invalid date', {
        name: 'date',
        scope: 'types.date.transform',
        value: date
      });
    }

    return date;
  }

});
registerType({
  name: 'file',

  transform(value) {
    if (!value) {
      throw _errors.default.EMPTY_STRING('Invalid file', {
        name: 'file',
        scope: 'types.file.transform',
        value
      });
    }

    return value;
  }

});
registerType({
  name: 'int',

  transform(value) {
    let num;

    if (!hexRegExp.test(value) && !intRegExp.test(value) || isNaN(num = Number(value))) {
      throw _errors.default.INVALID_NUMBER('Value is not an integer', {
        name: 'int',
        scope: 'types.int.transform',
        value
      });
    }

    return num;
  }

});
registerType({
  name: 'json',

  transform(value) {
    try {
      return JSON.parse(value);
    } catch (e) {
      throw _errors.default.INVALID_JSON(`Invalid json: ${e.message}`, {
        name: 'json',
        scope: 'types.json.transform',
        value
      });
    }
  }

});
registerType({
  name: 'number',

  transform(value) {
    let num = Number(value);

    if (isNaN(num)) {
      throw _errors.default.INVALID_NUMBER('Value is not an number', {
        name: 'number',
        scope: 'types.number.transform',
        value
      });
    }

    return num;
  }

});
registerType({
  name: 'positiveInt',

  transform(value) {
    let num;

    if (!hexRegExp.test(value) && !intRegExp.test(value) || isNaN(num = Number(value)) || num < 0) {
      throw _errors.default.INVALID_NUMBER('Value is not a positive integer', {
        name: 'positiveInt',
        scope: 'types.positiveInt.transform',
        value
      });
    }

    return num;
  }

});
registerType({
  name: 'string'
});
registerType({
  name: 'yesno',

  transform(value) {
    if (yesRegExp.test(value)) {
      return true;
    }

    if (noRegExp.test(value)) {
      return false;
    }

    throw _errors.default.NOT_YES_NO('Value must be "yes" or "no"', 'ERR_INVALID_YES_NO', {
      name: 'yesno',
      scope: 'types.yesno.transform',
      value
    });
  }

});
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcnNlci90eXBlcy5qcyJdLCJuYW1lcyI6WyJkYXRlUmVnRXhwIiwiaGV4UmVnRXhwIiwiaW50UmVnRXhwIiwibm9SZWdFeHAiLCJ5ZXNSZWdFeHAiLCJ0eXBlcyIsImNoZWNrVHlwZSIsInR5cGUiLCJvdGhlclR5cGVzIiwib3RoZXIiLCJSZWdFeHAiLCJFIiwiSU5WQUxJRF9EQVRBX1RZUEUiLCJuYW1lIiwic2NvcGUiLCJPYmplY3QiLCJrZXlzIiwidmFsdWUiLCJ0cmFuc2Zvcm1WYWx1ZSIsImx2YWx1ZSIsInRvTG93ZXJDYXNlIiwibnVtIiwiTnVtYmVyIiwiaXNOYU4iLCJ0ZXN0IiwiRGF0ZSIsIkpTT04iLCJwYXJzZSIsImUiLCJ0cmFuc2Zvcm0iLCJUeXBlIiwiY29uc3RydWN0b3IiLCJwYXJhbXMiLCJBcnJheSIsImlzQXJyYXkiLCJUWVBFX0VSUk9SIiwicmVnaXN0ZXJUeXBlIiwiZGF0ZSIsInRvU3RyaW5nIiwiSU5WQUxJRF9EQVRFIiwiRU1QVFlfU1RSSU5HIiwiSU5WQUxJRF9OVU1CRVIiLCJJTlZBTElEX0pTT04iLCJtZXNzYWdlIiwiTk9UX1lFU19OTyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUVBLE1BQU1BLFVBQVUsR0FBRyxxREFBbkI7QUFDQSxNQUFNQyxTQUFTLEdBQUcsa0JBQWxCO0FBQ0EsTUFBTUMsU0FBUyxHQUFHLFNBQWxCO0FBQ0EsTUFBTUMsUUFBUSxHQUFHLFFBQWpCO0FBQ0EsTUFBTUMsU0FBUyxHQUFHLFdBQWxCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ08sTUFBTUMsS0FBSyxHQUFHLEVBQWQ7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDTyxTQUFTQyxTQUFULENBQW1CQyxJQUFuQixFQUF5QixHQUFHQyxVQUE1QixFQUF3QztBQUM5QyxNQUFJLENBQUNELElBQUwsRUFBVztBQUNWLFNBQUssTUFBTUUsS0FBWCxJ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QUNoQixRQUFJYixTQUFTLENBQUNvQixJQUFWLENBQWVQLEtBQWYsQ0FBSixFQUEyQjtBQUMxQixhQUFPLElBQVA7QUFDQTs7QUFDRCxRQUFJZCxRQUFRLENBQUNxQixJQUFULENBQWNQLEtBQWQsQ0FBSixFQUEwQjtBQUN6QixhQUFPLEtBQVA7QUFDQTs7QUFDRCxVQUFNTixnQkFBRWlDLFVBQUYsQ0FBYSw2QkFBYixFQUE0QyxvQkFBNUMsRUFBa0U7QUFBRS9CLE1BQUFBLElBQUksRUFBRSxPQUFSO0FBQWlCQyxNQUFBQSxLQUFLLEVBQUUsdUJBQXhCO0FBQWlERyxNQUFBQTtBQUFqRCxLQUFsRSxDQUFOO0FBQ0E7O0FBVlcsQ0FBRCxDQUFaIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEUgZnJvbSAnLi4vbGliL2Vycm9ycyc7XG5cbmNvbnN0IGRhdGVSZWdFeHAgPSAvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9KFRcXGR7Mn06XFxkezJ9OlxcZHsyfShcXC5cXGQrKT9aPyk/JC9pO1xuY29uc3QgaGV4UmVnRXhwID0gL14weFtBLUZhLWYwLTldKyQvO1xuY29uc3QgaW50UmVnRXhwID0gL14tP1xcZCskLztcbmNvbnN0IG5vUmVnRXhwID0gL15ubz8kL2k7XG5jb25zdCB5ZXNSZWdFeHAgPSAvXnkoZXMpPyQvaTtcblxuLyoqXG4gKiBPcHRpb25zL2FyZ3MgaGF2ZSBhIHR5cGUuIEdlbmVyYWxseSB0aGV5IGFyZSBlaXRoZXIgYSBgYm9vbGAgKGZsYWcpIG9yXG4gKiBgc3RyaW5nYCAob3B0aW9uL2FyZykuIEhvd2V2ZXIsIGZvciBub24tYm9vbCBvcHRpb25zLCB5b3UgY2FuIHNwZWNpZnkgYSB0eXBlXG4gKiB0aGF0IHdpbGwgdmFsaWRhdGUgYW5kIGZvcm1hdCB0aGUgdmFsdWUuXG4gKlxuICogQmVsb3cgaXMgdGhlIGxpc3Qgb2Ygc3VwcG9ydGVkIHR5cGVzIGFuZCB0aGVpciB0cmFuc2Zvcm1lcnMuXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlcyA9IHt9O1xuXG4vKipcbiAqIEVuc3VyZXMgdGhhdCB0aGUgc3BlY2lmaWVkIGxpc3Qgb2YgdHlwZXMgaXMgaW5kZWVkIGFuIGFycmF5IGFuZCBlYWNoIHZhbHVlIGlzIGEgc3VwcG9ydGVkIHR5cGUsXG4gKiB0aGVuIHJldHVybnMgdGhlIGNsZWFuZWQgdXAgbGlzdCBvZiB0eXBlcyBvciBhIGRlZmF1bHQgdmFsdWUgaWYgbm8gdHlwZXMgd2VyZSBmb3VuZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IHR5cGUgLSBBIGxpc3Qgb2YgdHlwZXMgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBbb3RoZXJUeXBlc10gLSBBbiBvcHRpb25hbCBsaXN0IG9mIHR5cGVzIHRvIGRlZmF1bHQgdG8gaWYgbm9cbiAqIHR5cGVzIHdlcmUgb3JpZ2luYWxseSBzcGVjaWZpZWQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tUeXBlKHR5cGUsIC4uLm90aGVyVHlwZXMpIHtcblx0aWYgKCF0eXBlKSB7XG5cdFx0Zm9yIChjb25zdCBvdGhlciBvZiBvdGhlclR5cGVzKSB7XG5cdFx0XHRpZiAodHlwZW9mIG90aGVyICE9PSAndW5kZWZpbmVkJyAmJiBvdGhlciAhPT0gbnVsbCAmJiB0eXBlc1tvdGhlcl0pIHtcblx0XHRcdFx0cmV0dXJuIG90aGVyO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdFx0cmV0dXJuICdyZWdleCc7XG5cdH0gZWxzZSBpZiAoIXR5cGVzW3R5cGVdKSB7XG5cdFx0dGhyb3cgRS5JTlZBTElEX0RBVEFfVFlQRShgVW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cImAsIHsgbmFtZTogJ3R5cGUnLCBzY29wZTogJ3R5cGVzLmNoZWNrVHlwZScsIHR5cGVzOiBPYmplY3Qua2V5cyh0eXBlcyksIHZhbHVlOiB0eXBlIH0pO1xuXHR9XG5cblx0cmV0dXJuIHR5cGU7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIHZhbHVlIHRvIHRoZSBmaXJzdCBzdWNjZXNzZnVsbHkgdHJhbnNmb3JtZWQgZGF0YSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdHJhbnNmb3JtLlxuICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSAtIEEgc3BlY2lmaWMgZGF0YSB0eXBlIHRvIHRyeSB0byBjb2VyY2UgdGhlIHZhbHVlIGludG8uXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVZhbHVlKHZhbHVlLCB0eXBlKSB7XG5cdGlmICghdHlwZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0Y29uc3QgbHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdC8vIHRyeSBhcyBhIGJvb2xlYW5cblx0XHRpZiAobHZhbHVlID09PSAndHJ1ZScpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRpZiAobHZhbHVlID09PSAnZmFsc2UnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gdHJ5IGFzIGEgbnVtYmVyXG5cdFx0Y29uc3QgbnVtID0gTnVtYmVyKHZhbHVlKTtcblx0XHRpZiAoIWlzTmFOKG51bSkpIHtcblx0XHRcdHJldHVybiBudW07XG5cdFx0fVxuXG5cdFx0Ly8gdHJ5IGFzIGEgZGF0ZVxuXHRcdGlmIChkYXRlUmVnRXhwLnRlc3QodmFsdWUpKSB7XG5cdFx0XHRyZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuXHRcdH1cblxuXHRcdC8vIHRyeSBhcyBqc29uXG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHQvLyBub3BlXG5cdFx0fVxuXHR9IGVsc2UgaWYgKHR5cGVzW3R5cGVdICYmIHR5cGVvZiB0eXBlc1t0eXBlXS50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YWx1ZSA9IHR5cGVzW3R5cGVdLnRyYW5zZm9ybSh2YWx1ZSk7XG5cdH1cblxuXHQvLyByZXR1cm4gdGhlIG9yaWdpbmFsIHZhbHVlXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBEZWZpbmVzIGEgb3B0aW9uL2FyZ3VtZW50IGRhdGEgdHlwZSBhbmQgaXRzIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFR5cGUge1xuXHQvKipcblx0ICogQ3JlYXRlcyB0aGUgZGF0YSB0eXBlIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVmFyaW91cyBvcHRpb25zLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZGF0YSB0eXBlLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGFyYW1zLnRyYW5zZm9ybV0gLSBBIGZ1bmN0aW9uIHRoYXQgdHJhbnNmb3JtcyB0aGUgcGFyc2VkIG9wdGlvbi9hcmd1bWVudFxuXHQgKiBzdHJpbmcgdmFsdWUgdG8gdGhlIGNvcnJlY3QgZGF0YSB0eXBlLiBCeSBkZWZhdWx0LCBubyB0cmFuc2Zvcm0gaXMgYXBwbGllZCBhbmQgdmFsdWVzIHdpbGxcblx0ICogcmVtYWluIGFzIHN0cmluZ3MuXG5cdCAqIEBhY2Nlc3MgcHVibGljXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihwYXJhbXMpIHtcblx0XHRpZiAoIXBhcmFtcyB8fCB0eXBlb2YgcGFyYW1zICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcblx0XHRcdHRocm93IEUuVFlQRV9FUlJPUignRXhwZWN0ZWQgcGFyYW1zIHRvIGJlIGFuIG9iamVjdCcsIHsgbmFtZTogJ3BhcmFtcycsIHNjb3BlOiAnVHlwZS5jb25zdHJ1Y3RvcicsIHZhbHVlOiBwYXJhbXMgfSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFwYXJhbXMubmFtZSB8fCB0eXBlb2YgcGFyYW1zLm5hbWUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHR0aHJvdyBFLlRZUEVfRVJST1IoJ01pc3NpbmcgdHlwZSBuYW1lJywgeyBuYW1lOiAnbmFtZScsIHNjb3BlOiAnVHlwZS5jb25zdHJ1Y3RvcicsIHZhbHVlOiBwYXJhbXMubmFtZSB9KTtcblx0XHR9XG5cblx0XHRpZiAocGFyYW1zLnRyYW5zZm9ybSAmJiB0eXBlb2YgcGFyYW1zLnRyYW5zZm9ybSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dGhyb3cgRS5UWVBFX0VSUk9SKCdFeHBlY3RlZCB0cmFuc2Zvcm0gdG8gYmUgYSBmdW5jdGlvbicsIHsgbmFtZTogJ3RyYW5zZm9ybScsIHNjb3BlOiAnVHlwZS5jb25zdHJ1Y3RvcicsIHZhbHVlOiBwYXJhbXMudHJhbnNmb3JtIH0pO1xuXHRcdH1cblxuXHRcdHRoaXMubmFtZSA9IHBhcmFtcy5uYW1lO1xuXHRcdHRoaXMudHJhbnNmb3JtID0gcGFyYW1zLnRyYW5zZm9ybTtcblx0fVxufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBhIHR5cGUuXG4gKlxuICogQHBhcmFtIHtUeXBlfE9iamVjdH0gcGFyYW1zIC0gQSBgVHlwZWAgaW5zdGFuY2Ugb3IgcGFyYW1zIGZvciBjb25zdHJ1Y3RpbmcgYSBuZXcgYFR5cGVgIGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJUeXBlKHBhcmFtcykge1xuXHRpZiAoIShwYXJhbXMgaW5zdGFuY2VvZiBUeXBlKSkge1xuXHRcdHBhcmFtcyA9IG5ldyBUeXBlKHBhcmFtcyk7XG5cdH1cblx0dHlwZXNbcGFyYW1zLm5hbWVdID0gcGFyYW1zO1xufVxuXG5yZWdpc3RlclR5cGUoe1xuXHRuYW1lOiAnYm9vbCcsXG5cdHRyYW5zZm9ybSh2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZSAmJiB2YWx1ZSAhPT0gJ2ZhbHNlJztcblx0fVxufSk7XG5cbnJlZ2lzdGVyVHlwZSh7XG5cdG5hbWU6ICdjb3VudCdcbn0pO1xuXG5yZWdpc3RlclR5cGUoe1xuXHRuYW1lOiAnZGF0ZScsXG5cdHRyYW5zZm9ybSh2YWx1ZSkge1xuXHRcdGxldCBkYXRlO1xuXG5cdFx0aWYgKGludFJlZ0V4cC50ZXN0KHZhbHVlKSkge1xuXHRcdFx0Y29uc3QgbnVtID0gTnVtYmVyKHZhbHVlKTtcblx0XHRcdGlmICghaXNOYU4obnVtKSAmJiBudW0gPiAwKSB7XG5cdFx0XHRcdGRhdGUgPSBuZXcgRGF0ZShudW0gKiAxMDAwKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGRhdGVSZWdFeHAudGVzdCh2YWx1ZSkpIHtcblx0XHRcdGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFkYXRlIHx8IGRhdGUudG9TdHJpbmcoKSA9PT0gJ0ludmFsaWQgZGF0ZScpIHtcblx0XHRcdHRocm93IEUuSU5WQUxJRF9EQVRFKCdJbnZhbGlkIGRhdGUnLCB7IG5hbWU6ICdkYXRlJywgc2NvcGU6ICd0eXBlcy5kYXRlLnRyYW5zZm9ybScsIHZhbHVlOiBkYXRlIH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRlO1xuXHR9XG59KTtcblxucmVnaXN0ZXJUeXBlKHtcblx0bmFtZTogJ2ZpbGUnLFxuXHR0cmFuc2Zvcm0odmFsdWUpIHtcblx0XHRpZiAoIXZhbHVlKSB7XG5cdFx0XHR0aHJvdyBFLkVNUFRZX1NUUklORygnSW52YWxpZCBmaWxlJywgeyBuYW1lOiAnZmlsZScsIHNjb3BlOiAndHlwZXMuZmlsZS50cmFuc2Zvcm0nLCB2YWx1ZSB9KTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG59KTtcblxucmVnaXN0ZXJUeXBlKHtcblx0bmFtZTogJ2ludCcsXG5cdHRyYW5zZm9ybSh2YWx1ZSkge1xuXHRcdGxldCBudW07XG5cdFx0aWYgKCghaGV4UmVnRXhwLnRlc3QodmFsdWUpICYmICFpbnRSZWdFeHAudGVzdCh2YWx1ZSkpIHx8IGlzTmFOKG51bSA9IE51bWJlcih2YWx1ZSkpKSB7XG5cdFx0XHR0aHJvdyBFLklOVkFMSURfTlVNQkVSKCdWYWx1ZSBpcyBub3QgYW4gaW50ZWdlcicsIHsgbmFtZTogJ2ludCcsIHNjb3BlOiAndHlwZXMuaW50LnRyYW5zZm9ybScsIHZhbHVlIH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVtO1xuXHR9XG59KTtcblxucmVnaXN0ZXJUeXBlKHtcblx0bmFtZTogJ2pzb24nLFxuXHR0cmFuc2Zvcm0odmFsdWUpIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHRocm93IEUuSU5WQUxJRF9KU09OKGBJbnZhbGlkIGpzb246ICR7ZS5tZXNzYWdlfWAsIHsgbmFtZTogJ2pzb24nLCBzY29wZTogJ3R5cGVzLmpzb24udHJhbnNmb3JtJywgdmFsdWUgfSk7XG5cdFx0fVxuXHR9XG59KTtcblxucmVnaXN0ZXJUeXBlKHtcblx0bmFtZTogJ251bWJlcicsXG5cdHRyYW5zZm9ybSh2YWx1ZSkge1xuXHRcdGxldCBudW0gPSBOdW1iZXIodmFsdWUpO1xuXHRcdGlmIChpc05hTihudW0pKSB7XG5cdFx0XHR0aHJvdyBFLklOVkFMSURfTlVNQkVSKCdWYWx1ZSBpcyBub3QgYW4gbnVtYmVyJywgeyBuYW1lOiAnbnVtYmVyJywgc2NvcGU6ICd0eXBlcy5udW1iZXIudHJhbnNmb3JtJywgdmFsdWUgfSk7XG5cdFx0fVxuXHRcdHJldHVybiBudW07XG5cdH1cbn0pO1xuXG5yZWdpc3RlclR5cGUoe1xuXHRuYW1lOiAncG9zaXRpdmVJbnQnLFxuXHR0cmFuc2Zvcm0odmFsdWUpIHtcblx0XHRsZXQgbnVtO1xuXHRcdGlmICgoIWhleFJlZ0V4cC50ZXN0KHZhbHVlKSAmJiAhaW50UmVnRXhwLnRlc3QodmFsdWUpKSB8fCBpc05hTihudW0gPSBOdW1iZXIodmFsdWUpKSB8fCBudW0gPCAwKSB7XG5cdFx0XHR0aHJvdyBFLklOVkFMSURfTlVNQkVSKCdWYWx1ZSBpcyBub3QgYSBwb3NpdGl2ZSBpbnRlZ2VyJywgeyBuYW1lOiAncG9zaXRpdmVJbnQnLCBzY29wZTogJ3R5cGVzLnBvc2l0aXZlSW50LnRyYW5zZm9ybScsIHZhbHVlIH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVtO1xuXHR9XG59KTtcblxucmVnaXN0ZXJUeXBlKHtcblx0bmFtZTogJ3N0cmluZydcbn0pO1xuXG5yZWdpc3RlclR5cGUoe1xuXHRuYW1lOiAneWVzbm8nLFxuXHR0cmFuc2Zvcm0odmFsdWUpIHtcblx0XHRpZiAoeWVzUmVnRXhwLnRlc3QodmFsdWUpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKG5vUmVnRXhwLnRlc3QodmFsdWUpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHRocm93IEUuTk9UX1lFU19OTygnVmFsdWUgbXVzdCBiZSBcInllc1wiIG9yIFwibm9cIicsICdFUlJfSU5WQUxJRF9ZRVNfTk8nLCB7IG5hbWU6ICd5ZXNubycsIHNjb3BlOiAndHlwZXMueWVzbm8udHJhbnNmb3JtJywgdmFsdWUgfSk7XG5cdH1cbn0pO1xuIl0sImZpbGUiOiJwYXJzZXIvdHlwZXMuanMifQ==
