"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _command = _interopRequireDefault(require("./parser/command"));

var _context = _interopRequireDefault(require("./parser/context"));

var _debug = _interopRequireDefault(require("./lib/debug"));

var _errors = _interopRequireDefault(require("./lib/errors"));

var _extension = _interopRequireDefault(require("./parser/extension"));

var _help = _interopRequireWildcard(require("./commands/help"));

var _parser = _interopRequireDefault(require("./parser/parser"));

var _pluralize = _interopRequireDefault(require("pluralize"));

var _terminal = _interopRequireDefault(require("./terminal"));

var _ws = _interopRequireWildcard(require("ws"));

var ansi = _interopRequireWildcard(require("./lib/ansi"));

var _util = require("./lib/util");

var _events = require("events");

var _keys = require("./lib/keys");

var _tty = require("tty");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const {
  error,
  log,
  warn
} = (0, _debug.default)('cli-kit:cli');
const {
  highlight,
  note
} = _debug.default.styles;
/**
 * Writes data to a websocket.
 */

class OutputSocket extends _tty.WriteStream {
  constructor(fd, ws) {
    super(fd);
    this.ws = ws;
  }

  write(chunk) {
    this.ws.send(chunk.replace(/(?<!\r)\n/g, '\r\n'));
  }

}
/**
 * Defines a CLI context and is responsible for parsing the command line arguments.
 *
 * @extends {Context}
 */


class CLI extends _context.default {
  /**
   * Created a CLI instance.
   *
   * @param {Object} [params] - Various options.
   * @param {Boolean} [params.autoHideBanner=true] - When `true` and a `banner` is set, it will
   * detect if the first characters written to `stdout` or `stderr` match a JSON object/array or
   * XML document, then suppresses the banner.
   * @param {String|Function} [params.banner] - A banner or a function that returns the banner
   * to be displayed before each command.
   * @param {Boolean} [params.colors=true] - Enables colors, specifically on the help screen.
   * @param {String|Function} [params.defaultCommand="help"] - The default command to execute.
   * When value is a `String`, it looks up the command and calls it. If value is a `Function`, it
   * simply invokes it.
   * @param {Boolean} [params.errorIfUnknownCommand=true] - When `true`, `help` is enabled, and
   * the parser didn't find a command, but it did find an unknown argument, it will show the help
   * screen with an unknown command error.
   * @param {String|Function|Object} [params.help] - Additional help content to display on the
   * help screen. When may be an object with the properties `header` and `footer` which values
   * that are either a string or an async function that resolves a string. When value is a string
   * or function, it is trasnformed into a object with the value being used as the header. Note
   * that the command description is not displayed when a header message has been defined.
   * @param {Number} [params.helpExitCode] - The exit code to return when the help command is
   * finished.
   * @param {String} [params.helpTemplateFile] - Path to a template to render for the help
   * command.
   * @param {Boolean} [params.hideNoBannerOption] - When `true` and a `banner` is specified, it
   * does not add the `--no-banner` option.
   * @param {Boolean} [params.hideNoColorOption] - When `true` and `colors` is enabled, it does
   * not add the `--no-color` option.
   * @param {String} [params.name] - The name of the program. If not set, defaults to `"program"`
   * in the help outut and `"This application"` in the Node version assertion.
   * @param {String} [params.nodeVersion] - The required Node.js version to run the app.
   * @param {Boolean} [opts.serverMode=false] - When `true`, makes things such that `exec()`
   * doesn't change any global state by deep cloning the entire context tree every time the
   * arguments are parsed and changing the process state. Enabling this only makes sense if the
   * `CLI` instance is going to be reused to parse arguments multiple times and if the state of
   * the context tree is going to be modified during parsing (i.e. via a callback). It also
   * prevents ctrl-c (SIGINT) and does not set an exit code.
   * @param {Boolean} [params.showBannerForExternalCLIs=false] - If `true`, shows the `CLI`
   * banner, assuming banner is enabled, for non-cli-kit enabled CLIs.
   * @param {Boolean} [params.showHelpOnError=true] - If an error occurs and `help` is enabled,
   * then display the error before the help information.
   * @param {Object} [params.styles] - Custom defined style functions.
   * @param {Terminal} [params.terminal] - A custom terminal instance, otherwise uses the default
   * global terminal instance.
   * @param {String} [params.title='Global'] - The title for the global context.
   * @param {String|Function} [params.version] - The program version or a function that resolves
   * a version.
   * @access public
   */
  constructor(params = {}) {
    if (!params || typeof params !== 'object' || Array.isArray(params)) {
      throw _errors.default.INVALID_ARGUMENT('Expected CLI parameters to be an object or Context', {
        name: 'params',
        scope: 'CLI.constructor',
        value: params
      });
    }

    if (params.banner !== undefined && typeof params.banner !== 'string' && typeof params.banner !== 'function') {
      throw _errors.default.INVALID_ARGUMENT('Expected banner to be a string or function', {
        name: 'banner',
        scope: 'CLI.constructor',
        value: params.banner
      });
    }

    if (params.extensions && typeof params.extensions !== 'object') {
      throw _errors.default.INVALID_ARGUMENT('Expected extensions to be an array of extension paths or an object of names to extension paths', {
        name: 'extensions',
        scope: 'CLI.constructor',
        value: params.extensions
      });
    }

    if (params.helpExitCode !== undefined && typeof params.helpExitCode !== 'number') {
      throw _errors.default.INVALID_ARGUMENT('Expected help exit code to be a number', {
        name: 'helpExitCode',
        scope: 'CLI.constructor',
        value: params.helpExitCode
      });
    }

    if (params.terminal && !(params.terminal instanceof _terminal.default)) {
      throw _errors.default.INVALID_ARGUMENT('Expected terminal to be a Terminal instance', {
        name: 'terminal',
        scope: 'CLI.constructor',
        value: params.terminal
      });
    }

    if (params.defaultCommand !== undefined && (!params.defaultCommand || typeof params.defaultCommand !== 'string' && typeof params.defaultCommand !== 'function')) {
      throw _errors.default.INVALID_ARGUMENT('Expected default command to be a string or function', {
        name: 'defaultCommand',
        scope: 'CLI.constructor',
        value: params.defaultCommand
      });
    } // make sure we have a `name` and `title` for the context


    if (!params.name) {
      params.name = 'program';
    }

    if (!params.title) {
      params.title = 'Global';
    } // extract the extensions... we initialize them ourselves


    const {
      extensions
    } = params;
    delete params.extensions;
    super(params);
    (0, _util.declareCLIKitClass)(this, 'CLI');
    this.appName = params.appName || params.name;
    this.autoHideBanner = params.autoHideBanner !== false;
    this.colors = params.colors !== false;
    this.defaultCommand = params.defaultCommand;
    this.errorIfUnknownCommand = params.errorIfUnknownCommand !== false;
    this.help = params.help;
    this.helpExitCode = params.helpExitCode;
    this.helpTemplateFile = params.helpTemplateFile;
    this.hideNoBannerOption = params.hideNoBannerOption;
    this.hideNoColorOption = params.hideNoColorOption;
    this.nodeVersion = params.nodeVersion;
    this.serverMode = params.serverMode;
    this.showBannerForExternalCLIs = params.showBannerForExternalCLIs;
    this.showHelpOnError = params.showHelpOnError;
    this.styles = Object.assign({}, _debug.default.styles, params.styles);
    this.terminal = params.terminal || new _terminal.default();
    this.version = params.version;
    this.warnings = []; // if we're not in server mode, wire up the SIGINT handler

    if (!this.serverMode) {
      this.terminal.on('SIGINT', () => process.kill(process.pid, 'SIGINT'));
    } // add the built-in help


    if (this.help) {
      if (this.defaultCommand === undefined) {
        this.defaultCommand = 'help';
      } // note: we must clone the help command params since the object gets modified


      this.command('help', { ..._help.default
      });
      this.option('-h, --help', 'Displays the help screen');
    } // add the --no-banner flag


    if (this.banner && !this.hideNoBannerOption) {
      this.option('--no-banner', 'Suppress the banner');
    } // add the --no-colors flag


    if (this.colors && !this.hideNoColorOption) {
      this.option('--no-color', {
        aliases: ['--no-colors'],
        desc: 'Disable colors'
      });
    } // add the --version flag


    if (this.version && !this.lookup.short.v && !this.lookup.long.version) {
      this.option('-v, --version', {
        callback: async ({
          exitCode,
          opts,
          next
        }) => {
          if ((await next()) === true) {
            let version = this.version;

            if (typeof version === 'function') {
              version = await version(opts);
            }

            (opts.terminal || this.terminal).stdout.write(`${version}\n`);
            exitCode(0);
            return false;
          }
        },
        desc: 'Outputs the version'
      });
    } // add the extensions now that the auto-generated options exist


    if (extensions) {
      const exts = Array.isArray(extensions) ? extensions : Object.entries(extensions);

      for (const ext of exts) {
        try {
          this.extension.apply(this, Array.isArray(ext) ? [ext[1], ext[0]] : [ext]);
        } catch (e) {
          this.warnings.push(`Error loading extension "${ext}"`);
          warn(e);
        }
      }
    }
  }
  /**
   * Connects to a cli-kit WebSocket server and initializes a terminal session.
   *
   * @param {String} url - The URL to connect to.
   * @param {Object} [opts] - Various options.
   * @param {Object} [opts.headers] - HTTP headers to send when creating the WebSocket.
   * @param {Termianl} [opts.terminal] - A terminal instance to override the default CLI terminal
   * instance.
   * @param {Number} [opts.timeout=5000] - The number of milliseconds to wait to connect to the
   * server and complete the initialization handshake.
   * @returns {Promise<Object>} Resolves an `EventEmitter` based handle containing a `send()`
   * function to send data as if from `stdin`.
   * @access public
   */


  static async connect(url, opts = {}) {
    if (!url || typeof url !== 'string') {
      throw _errors.default.INVALID_ARGUMENT('Expected URL to be a string', {
        name: 'url',
        scope: 'CLI.connect',
        value: url
      });
    }

    if (!opts || typeof opts !== 'object') {
      throw _errors.default.INVALID_ARGUMENT('Expected options to be an object', {
        name: 'opts',
        scope: 'CLI.connect',
        value: opts
      });
    }

    let term = opts.terminal;
    delete opts.terminal;

    if (!term) {
      term = new _terminal.default();
    } else if (!(term instanceof _terminal.default)) {
      throw _errors.default.INVALID_ARGUMENT('Expected terminal to be a Terminal instance', {
        name: 'opts.terminal',
        scope: 'CLI.connect',
        value: term
      });
    }

    return await new Promise((resolve, reject) => {
      log(`Connecting to ${highlight(url)}`);
      const ws = new _ws.default(url, opts);
      ws.binaryType = 'arraybuffer';
      const handle = new _events.EventEmitter();

      handle.send = chunk => {
        if (ws.readyState === 1) {
          ws.send(chunk);
        }
      };

      const initTimer = setTimeout(() => {
        const err = new Error(ws.readyState === 1 ? 'Failed to initialize terminal session' : 'Failed to connect to server');
        err.code = 'ETIMEOUT';
        reject(err);
      }, opts.timeout || 5000);
      ws.on('close', (code, reason) => handle.emit('close', code, reason));
      ws.on('error', err => handle.emit('error', err));
      ws.on('message', msg => {
        if (msg === ansi.cursor.get && ws.readyState === 1) {
          clearTimeout(initTimer);
          ws.send(`${ansi.esc}${term.rows};${term.columns}R`);
          resolve(handle);
          return;
        }

        const code = msg.match(ansi.custom.exit.re);

        if (code) {
          handle.emit('exit', code[1]);
          return;
        }

        term.stdout.write(msg);
      });
      term.on('keypress', (chunk, key) => {
        // console.log('KEYPRESS', chunk === undefined ? chunk : Buffer.from(chunk), key, Buffer.from(key.sequence));
        handle.send(ansi.custom.keypress(key));
      });
      term.on('resize', ({
        rows,
        columns
      }) => {
        handle.send(`${ansi.esc}${rows};${columns}R`);
      });
      term.on('SIGINT', () => {
        ws.close();
        process.exit();
      });
    });
  }
  /**
   * Parses the command line arguments and runs the command.
   *
   * @param {Array.<String>} [_argv] - An array of arguments to parse. If not specified, it
   * defaults to the `process.argv` starting with the 3rd argument.
   * @param {Object} [opts] - Various options.
   * @param {Object} [opts.data] - User-defined data to pass into the selected command.
   * @param {Function} [opts.exitCode] - A function that sets the exit code.
   * @param {Array.<String>} [params.parentContextNames] - An array of parent context names.
   * @param {Boolean} [opts.remoteHelp=false] - When `true`, don't execute the built-in help
   * command. This is set when a request comes from a remote connection.
   * @param {Termianl} [opts.terminal] - A terminal instance to override the default CLI terminal
   * instance.
   * @returns {Promise.<Arguments>}
   * @access public
   */


  async exec(_argv, opts = {}) {
    (0, _util.assertNodeJSVersion)(this);

    if (!_argv) {
      _argv = process.argv.slice(2);
    } else if (!Array.isArray(_argv)) {
      throw _errors.default.INVALID_ARGUMENT('Expected arguments to be an array', {
        name: 'args',
        scope: 'CLI.exec',
        value: _argv
      });
    }

    if (!opts || typeof opts !== 'object') {
      throw _errors.default.INVALID_ARGUMENT('Expected opts to be an object', {
        name: 'opts',
        scope: 'CLI.exec',
        value: opts
      });
    }

    if (!opts.data) {
      opts.data = {};
    } else if (typeof opts.data !== 'object') {
      throw _errors.default.INVALID_ARGUMENT('Expected data to be an object', {
        name: 'opts.data',
        scope: 'CLI.exec',
        value: opts.data
      });
    }

    if (!opts.terminal) {
      opts.terminal = this.terminal;
    } else if (!(opts.terminal instanceof _terminal.default)) {
      throw _errors.default.INVALID_ARGUMENT('Expected terminal to be a Terminal instance', {
        name: 'opts.terminal',
        scope: 'CLI.exec',
        value: opts.terminal
      });
    }

    let exitCode = undefined;
    let showHelpOnError = this.prop('showHelpOnError');
    const parser = new _parser.default(opts).link(this);

    const __argv = _argv.slice(0);

    opts.exitCode = code => code === undefined ? exitCode : exitCode = code || 0;

    opts.styles = Object.assign({}, this.styles, opts.styles);
    let results = {
      _: undefined,
      _argv,
      // the original unparsed arguments
      __argv,
      // the parsed arguments
      argv: undefined,
      bannerFired: false,
      bannerRendered: false,
      cli: this,
      cmd: undefined,
      console: opts.terminal.console,
      contexts: undefined,
      data: opts.data,
      exitCode: opts.exitCode,
      help: () => (0, _help.renderHelp)(results.cmd, opts),
      result: undefined,
      setExitCode: opts.exitCode,
      styles: opts.styles,
      terminal: opts.terminal,
      unknown: undefined,
      warnings: this.warnings
    };

    const renderBanner = async state => {
      const {
        argv,
        cli,
        cmd = cli,
        terminal
      } = state; // if --no-banner, then return
      // or if we're running an extension that is not a cli-kit extension, then return and
      // let the extension CLI render its own banner

      if (state.bannerRendered || argv && !argv.banner || cmd instanceof _extension.default && !cmd.isCLIKitExtension && !cmd.get('showBannerForExternalCLIs')) {
        return;
      }

      state.bannerRendered = true; // copy the banner to the state
      // if the banner is a function, run it now

      if (cmd.banner !== undefined) {
        state.banner = cmd.banner;
        cmd._origBanner = cmd.banner;
        Object.defineProperty(cmd, 'banner', {
          get() {
            return cmd._origBanner;
          },

          set(value) {
            state.banner = value;
          }

        });
      }

      for (let p = cmd.parent; p; p = p.parent) {
        if (state.banner === undefined && (!(state.bannerFired instanceof Error) || p.banner !== undefined)) {
          state.banner = p.banner;
        }

        p._origBanner = p.banner;
        Object.defineProperty(p, 'banner', {
          get() {
            return p._origBanner;
          },

          set(value) {
            state.banner = value;
          }

        });
      }

      if (typeof state.banner === 'function') {
        state.banner = await state.banner(state);
      }

      const printBanner = () => {
        if (typeof state.banner === 'function') {
          throw new Error('Banner function not supported here');
        }

        if (state.banner) {
          state.banner = String(state.banner).trim();
        }

        if (state.banner) {
          terminal.stdout.write(`${state.banner}\n\n`);
        }
      };

      if (cmd.prop('autoHideBanner')) {
        // wait to show banner
        terminal.onOutput(() => printBanner());
      } else {
        // show banner now
        printBanner();
      }
    };

    const bannerHook = async state => {
      if (!state.bannerFired) {
        state.bannerFired = true;

        try {
          await this.hook('banner', renderBanner)(state);
        } catch (err) {
          state.bannerFired = err;
          throw err;
        }
      }
    };

    try {
      const cli = this.serverMode ? new _context.default().init(this, true) : this;
      log(`Parsing ${__argv.length} argument${__argv.length !== 1 ? 's' : ''} ${note(`(server mode: ${!!this.serverMode})`)}`); // parse the command line arguments

      const {
        _,
        argv,
        contexts,
        required,
        unknown
      } = await parser.parse({
        args: __argv,
        ctx: cli,
        data: results.data
      });
      log('Parsing complete: ' + `${(0, _pluralize.default)('option', Object.keys(argv).length, true)}, ` + `${(0, _pluralize.default)('unknown option', Object.keys(unknown).length, true)}, ` + `${(0, _pluralize.default)('arg', _.length, true)}, ` + `${(0, _pluralize.default)('context', contexts.length, true)} ` + note(`(exit: ${results.exitCode()})`));
      const cmd = contexts[0]; // check for missing arguments and options if help is disabled or is not set

      if (!this.help || !argv.help) {
        // `_` already contains all known parsed arguments, but may not contain all required
        // arguments, thus we must loop over the remaining arguments and check if there are
        // any missing required arguments.
        //
        // note that we stop looping if we find an argument with multiple arguments since
        // we've already gobbled up all the values
        let i = _.length;
        const len = cmd.args.length;

        if (i === 0 || i < len && !cmd.args[i - 1].multiple) {
          for (; i < len; i++) {
            if (cmd.args[i].required && (!cmd.args[i].multiple || !argv[cmd.args[i].name].length)) {
              throw _errors.default.MISSING_REQUIRED_ARGUMENT(`Missing required argument "${cmd.args[i].name}"`, {
                name: 'args',
                scope: 'Parser.parse',
                value: cmd.args[i]
              });
            }
          }
        }

        if (required.size) {
          throw _errors.default.MISSING_REQUIRED_OPTION(`Missing ${required.size} required option${required.size === 1 ? '' : 's'}:`, {
            name: 'options',
            scope: 'Parser.parse',
            required: required.values()
          });
        }
      }

      results._ = _;
      results.argv = argv;
      results.cmd = cmd;
      results.cli = cli;
      results.contexts = contexts;
      results.parentContextNames = opts.parentContextNames;
      results.unknown = unknown; // check if we haven't already errored

      if (results.exitCode() === undefined) {
        // determine the command to run
        if (this.help && argv.help && (!cmd.isExtension || cmd.isCLIKitExtension)) {
          // disable the built-in help if the help is to be rendered remotely
          // note: the current `cmd` could be a command under an extension, so we call
          // `cmd.prop()` to scan the command's parents to see if this command is
          // actually remote
          if (!cmd.prop('remoteHelp')) {
            log(`Selected help command, was "${cmd.name}"`);
            results.cmd = this.commands.get('help');
            contexts.unshift(results.cmd);
          }
        } else if (typeof this.defaultCommand === 'string' && ( // if we don't have an action or command, then do the default command
        !(cmd instanceof _command.default) || // if we have a command, but the command does not have an action, then do
        // the default command
        typeof cmd.action !== 'function' && (!(cmd.action instanceof _command.default) || typeof cmd.action.action !== 'function')) && (!cmd.prop('remoteHelp') || this.defaultCommand !== 'help')) {
          log(`Selected default command: ${highlight(this.defaultCommand)}`);
          results.cmd = this.commands.get(this.defaultCommand);

          if (!(results.cmd instanceof _command.default)) {
            throw _errors.default.DEFAULT_COMMAND_NOT_FOUND(`The default command "${this.defaultCommand}" was not found!`);
          }

          contexts.unshift(results.cmd);
        } // now that we've made it past the parsing and validation, we are going to execute
        // the command and thus we want to turn off show help on error unless the error
        // explicitly requests help to be shown


        showHelpOnError = false; // handle the banner

        await bannerHook(results);
        results = await this.hook('exec', async results => {
          // execute the command
          if (results.cmd && typeof results.cmd.action === 'function') {
            log(`Executing command: ${highlight(results.cmd.name)}`);
            results.result = await results.cmd.action.call(results.cmd, results);
          } else if (results.cmd && results.cmd.action instanceof _command.default && typeof results.cmd.action.action === 'function') {
            // I think this is related to the legacy extension stuff...
            log(`Executing command: ${highlight(results.cmd.action.name)} (via ${highlight(results.cmd.name)})`);
            results.result = await results.cmd.action.action.call(results.cmd.action, results);
          } else if (typeof this.defaultCommand === 'function') {
            log(`Executing default command: ${highlight(this.defaultCommand.name || 'anonymous')}`);
            results.result = await this.defaultCommand.call(this.defaultCommand, results);
          } else {
            log('No command to execute, returning parsed arguments');
          }

          return results;
        })(results);
      }

      if (!this.serverMode) {
        process.exitCode = results.exitCode();
      }

      return results;
    } catch (err) {
      var _results$cmd;

      if (!this.serverMode) {
        error(err.stack || err.message || err.toString() || 'Unknown error');
      }

      if (err.json === undefined && (_results$cmd = results.cmd) !== null && _results$cmd !== void 0 && _results$cmd.prop('jsonMode')) {
        err.json = true;
      } else {
        // the banner rendered during an error does not fire the hook
        await renderBanner(results);
      }

      const help = this.help && (showHelpOnError !== false || err.showHelp) && this.commands.get('help');

      if (help) {
        results.contexts = err.contexts || parser.contexts || [this];
        results.err = err;
        results.result = await help.action(results);
        process.exitCode = results.exitCode();
        return results;
      }

      throw err;
    }
  }
  /**
   * Starts a WebSocket server.
   *
   * @param {Object} [opts] - WebSocket server options. Visit
   * https://github.com/websockets/ws/blob/HEAD/doc/ws.md#new-websocketserveroptions-callback for
   * more information.
   * @returns {Promise<WebSocketServer>}
   * @access public
   */


  async listen(opts = {}) {
    if (!opts || typeof opts !== 'object') {
      throw _errors.default.INVALID_ARGUMENT('Expected options to be an object', {
        name: 'opts',
        scope: 'CLI.listen',
        value: opts
      });
    }

    if (opts.port !== undefined && (typeof opts.port !== 'number' || opts.port < 1 || opts.port > 65535)) {
      throw _errors.default.INVALID_ARGUMENT('Expected port to be a number between 1 and 65535', {
        name: 'opts.port',
        scope: 'CLI.listen',
        value: opts.port
      });
    }

    log(`Starting WebSocketServer${opts.port ? ` on port ${highlight(opts.port)}` : ''}...`);

    if (!this.serverMode) {
      log('Enabling server mode');
      this.serverMode = true;
    }

    return new Promise((resolve, reject) => {
      this.server = new _ws.Server(opts, () => resolve(this.server));
      this.server.on('connection', (ws, req) => {
        const {
          remoteAddress,
          remotePort
        } = req.socket;
        const key = remoteAddress + ':' + remotePort;

        try {
          const {
            headers
          } = req;
          const terminal = new _terminal.default({
            stdout: new OutputSocket(1, ws),
            stderr: new OutputSocket(2, ws)
          });
          let buffer = '';
          let current = null;
          let echo = false;
          log(`${highlight(key)} upgraded to WebSocket`);
          log(headers);
          ws.on('close', () => log(`${highlight(key)} closed WebSocket`));
          ws.on('error', err => {
            if (err.code !== 'ECONNRESET') {
              error(err);
            }
          });

          const exec = async (args, post) => {
            const command = (0, _util.split)(args);
            log(`Running: ${highlight(command)}`);
            current = this.exec(command, {
              data: {
                cwd: (0, _util.decode)(headers['clikit-cwd']),
                env: (0, _util.decode)(headers['clikit-env']),
                userAgent: headers['user-agent'] || undefined
              },
              parentContextNames: (0, _util.decode)(headers['clikit-parents']),
              terminal
            });

            if (typeof post === 'function') {
              post();
            }

            let ec = 1;

            try {
              const {
                exitCode
              } = await current;
              ec = exitCode() || 0;
            } catch (err) {
              error(err.stack || err.message || err.toString());
              terminal.stderr.write(`${this.styles.error(err.toString())}\n`);
            } finally {
              current = null;
              log(`Command finished (code ${ec})`);
              ws.send(ansi.custom.exit(ec));
            }
          };

          ws.on('message', async msg => {
            if (Buffer.isBuffer(msg)) {
              msg = msg.toString();
            }

            let m;

            try {
              // check if we received a cursor message
              m = msg.match(ansi.cursor.position);

              if (m) {
                const rows = terminal.stdout.rows = terminal.stderr.rows = ~~m[1];
                const cols = terminal.stdout.columns = terminal.stderr.columns = ~~m[2];
                log(`Terminal set to ${highlight(cols)} x ${highlight(rows)}`);
                return;
              } // check if we received an echo message


              m = msg.match(ansi.custom.echo.re);

              if (m) {
                echo = m[1] !== 'off';
                log(`Setting echo ${highlight(echo ? 'on' : 'off')}`);
                return;
              } // check if we received an execute message


              m = msg.match(ansi.custom.exec.re);

              if (m) {
                return await exec((0, _util.decode)(m[1]));
              } // check if we received a keypress message


              m = msg.match(ansi.custom.keypress.re);

              if (m) {
                const key = (0, _util.decode)(m[1]);

                if (current) {
                  terminal.stdin.emit('keypress', key.sequence, key);
                  return;
                }

                msg = key.sequence;
                m = null;
              } // message is a raw message, so we have to clean it up, buffer, and manually dispatch


              msg = msg.replace(/\r\n|\n|\r/g, '\r\n'); // normalize new lines

              msg = msg.replace(/\x7f/g, '\b'); // normalize backspaces
              // TODO: support cursor position
              // repeat back to the client what they just passed us

              if (echo) {
                ws.send(msg.replace(/[\b]/g, '\b \b'));
              } // if there's already an active command, treat message as an incoming key from stdin


              if (current) {
                terminal.stdin.emit('keypress', msg, (0, _keys.generateKey)(msg));
                return;
              } // no pending command, so we need to buffer and as soon as we see a line return,
              // then we execute it and any remaining characters are treated as keypresses


              buffer += msg; // replace backspaces

              for (let p = 0; (p = buffer.indexOf('\b', p)) !== -1;) {
                buffer = buffer.substring(0, p - 1) + buffer.substring(p + 1);
              }

              let p = buffer.indexOf('\r');

              if (p !== -1) {
                const command = buffer.substring(0, p);
                const str = buffer.substring(p + 2);
                buffer = '';
                await exec(command, () => {
                  if (str.length) {
                    try {
                      terminal.stdin.write(str);
                    } catch (err) {
                      warn('Failed to write to stdin');
                      warn(err);
                    }
                  }
                });
              }
            } finally {
              if (m) {
                buffer = '';
              }
            }
          }); // get the remote terminal size

          ws.send(ansi.cursor.save);
          ws.send(ansi.cursor.move(999, 999));
          ws.send(ansi.cursor.get);
          ws.send(ansi.cursor.restore);
        } catch (err) {
          warn(err);
          warn(`Hanging up ${highlight(key)}`);
        }
      });
      this.server.on('error', reject);
    });
  }
  /**
   * Returns the schema for the CLI and all child contexts.
   *
   * @param {Object} [opts] - Various options.
   * @param {Object} [opts.data] - User-defined data to pass into the selected command.
   * @returns {Object}
   * @access public
   */


  async schema(opts = {}) {
    const obj = {
      args: [],
      banner: String(typeof this.banner === 'function' ? await this.banner(opts) : this.banner).trim(),
      commands: {},
      desc: this.desc,
      extensions: {},
      name: this.name,
      options: {},
      title: this.title,
      version: String(typeof this.version === 'function' ? await this.version(opts) : this.version).trim()
    };

    for (const arg of this.args) {
      if (!arg.hidden) {
        obj.args.push(arg.schema);
      }
    }

    for (const [name, cmd] of this.commands.entries()) {
      obj.commands[name] = await cmd.schema(opts);
    }

    for (const [name, ext] of this.extensions.entries()) {
      obj.extensions[name] = await ext.schema(opts);
    }

    for (const options of this.options.values()) {
      for (const opt of options) {
        if (!opt.hidden) {
          obj.options[opt.format] = await opt.schema(opts);
        }
      }
    }

    return obj;
  }

}

exports.default = CLI;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNsaS5qcyJdLCJuYW1lcyI6WyJlcnJvciIsImxvZyIsIndhcm4iLCJoaWdobGlnaHQiLCJub3RlIiwiZGVidWciLCJzdHlsZXMiLCJPdXRwdXRTb2NrZXQiLCJXcml0ZVN0cmVhbSIsImNvbnN0cnVjdG9yIiwiZmQiLCJ3cyIsIndyaXRlIiwiY2h1bmsiLCJzZW5kIiwicmVwbGFjZSIsIkNMSSIsIkNvbnRleHQiLCJwYXJhbXMiLCJBcnJheSIsImlzQXJyYXkiLCJFIiwiSU5WQUxJRF9BUkdVTUVOVCIsIm5hbWUiLCJzY29wZSIsInZhbHVlIiwiYmFubmVyIiwidW5kZWZpbmVkIiwiZXh0ZW5zaW9ucyIsImhlbHBFeGl0Q29kZSIsInRlcm1pbmFsIiwiVGVybWluYWwiLCJkZWZhdWx0Q29tbWFuZCIsInRpdGxlIiwiYXBwTmFtZSIsImF1dG9IaWRlQmFubmVyIiwiY29sb3JzIiwiZXJyb3JJZlVua25vd25Db21tYW5kIiwiaGVscCIsImhlbHBUZW1wbGF0ZUZpbGUiLCJoaWRlTm9CYW5uZXJPcHRpb24iLCJoaWRlTm9Db2xvck9wdGlvbiIsIm5vZGVWZXJzaW9uIiwic2VydmVyTW9kZSIsInNob3dCYW5uZXJGb3JFeHRlcm5hbENMSXMiLCJzaG93SGVscE9uRXJyb3IiLCJPYmplY3QiLCJhc3NpZ24iLCJ2ZXJzaW9uIiwid2FybmluZ3MiLCJvbiIsInByb2Nlc3MiLCJraWxsIiwicGlkIiwiY29tbWFuZCIsImhlbHBDb21tYW5kIiwib3B0aW9uIiwiYWxpYXNlcyIsImRlc2MiLCJsb29rdXAiLCJzaG9ydCIsInYiLCJsb25nIiwiY2FsbGJhY2siLCJleGl0Q29kZSIsIm9wdHMiLCJuZXh0Iiwic3Rkb3V0IiwiZXh0cyIsImVudHJpZXMiLCJleHQiLCJleHRlbnNpb24iLCJhcHBseSIsImUiLCJwdXNoIiwiY29ubmVjdCIsInVybCIsInRlcm0iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIldlYlNvY2tldCIsImJpbmFyeVR5cGUiLCJoYW5kbGUiLCJFdmVudEVtaXR0ZXIiLCJyZWFkeVN0YXRlIiwiaW5pdFRpbWVyIiwic2V0VGltZW91dCIsImVyciIsIkVycm9yIiwiY29kZSIsInRpbWVvdXQiLCJyZWFzb24iLCJlbWl0IiwibXNnIiwiYW5zaSIsImN1cnNvciIsImdldCIsImNsZWFyVGltZW91dCIsImVzYyIsInJvd3MiLCJjb2x1bW5zIiwibWF0Y2giLCJjdXN0b20iLCJleGl0IiwicmUiLCJrZXkiLCJrZXlwcmVzcyIsImNsb3NlIiwiZXhlYyIsIl9hcmd2IiwiYXJndiIsInNsaWNlIiwiZGF0YSIsInByb3AiLCJwYXJzZXIiLCJQYXJzZXIiLCJsaW5rIiwiX19hcmd2IiwicmVzdWx0cyIsIl8iLCJiYW5uZXJGaXJlZCIsImJhbm5lclJlbmRlcmVkIiwiY2xpIiwiY21kIiwiY29uc29sZSIsImNvbnRleHRzIiwicmVzdWx0Iiwic2V0RXhpdENvZGUiLCJ1bmtub3duIiwicmVuZGVyQmFubmVyIiwic3RhdGUiLCJFeHRlbnNpb24iLCJpc0NMSUtpdEV4dGVuc2lvbiIsIl9vcmlnQmFubmVyIiwiZGVmaW5lUHJvcGVydHkiLCJzZXQiLCJwIiwicGFyZW50IiwicHJpbnRCYW5uZXIiLCJTdHJpbmciLCJ0cmltIiwib25PdXRwdXQiLCJiYW5uZXJIb29rIiwiaG9vayIsImluaXQiLCJsZW5ndGgiLCJyZXF1aXJlZCIsInBhcnNlIiwiYXJncyIsImN0eCIsImtleXMiLCJpIiwibGVuIiwibXVsdGlwbGUiLCJNSVNTSU5HX1JFUVVJUkVEX0FSR1VNRU5UIiwic2l6ZSIsIk1JU1NJTkdfUkVRVUlSRURfT1BUSU9OIiwidmFsdWVzIiwicGFyZW50Q29udGV4dE5hbWVzIiwiaXNFeHRlbnNpb24iLCJjb21tYW5kcyIsInVuc2hpZnQiLCJDb21tYW5kIiwiYWN0aW9uIiwiREVGQVVMVF9DT01NQU5EX05PVF9GT1VORCIsImNhbGwiLCJzdGFjayIsIm1lc3NhZ2UiLCJ0b1N0cmluZyIsImpzb24iLCJzaG93SGVscCIsImxpc3RlbiIsInBvcnQiLCJzZXJ2ZXIiLCJXZWJTb2NrZXRTZXJ2ZXIiLCJyZXEiLCJyZW1vdGVBZGRyZXNzIiwicmVtb3RlUG9ydCIsInNvY2tldCIsImhlYWRlcnMiLCJzdGRlcnIiLCJidWZmZXIiLCJjdXJyZW50IiwiZWNobyIsInBvc3QiLCJjd2QiLCJlbnYiLCJ1c2VyQWdlbnQiLCJlYyIsIkJ1ZmZlciIsImlzQnVmZmVyIiwibSIsInBvc2l0aW9uIiwiY29scyIsInN0ZGluIiwic2VxdWVuY2UiLCJpbmRleE9mIiwic3Vic3RyaW5nIiwic3RyIiwic2F2ZSIsIm1vdmUiLCJyZXN0b3JlIiwic2NoZW1hIiwib2JqIiwib3B0aW9ucyIsImFyZyIsImhpZGRlbiIsIm9wdCIsImZvcm1hdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7OztBQUVBLE1BQU07QUFBRUEsRUFBQUEsS0FBRjtBQUFTQyxFQUFBQSxHQUFUO0FBQWNDLEVBQUFBO0FBQWQsSUFBdUIsb0JBQU0sYUFBTixDQUE3QjtBQUNBLE1BQU07QUFBRUMsRUFBQUEsU0FBRjtBQUFhQyxFQUFBQTtBQUFiLElBQXVCQyxlQUFNQyxNQUFuQztBQUVBO0FBQ0E7QUFDQTs7QUFDQSxNQUFNQyxZQUFOLFNBQTJCQyxnQkFBM0IsQ0FBdUM7QUFDdENDLEVBQUFBLFdBQVcsQ0FBQ0MsRUFBRCxFQUFLQyxFQUFMLEVBQVM7QUFDbkIsVUFBTUQsRUFBTjtBQUNBLFNBQUtDLEVBQUwsR0FBVUEsRUFBVjtBQUNBOztBQUVEQyxFQUFBQSxLQUFLLENBQUNDLEtBQUQsRUFBUTtBQUNaLFNBQUtGLEVBQUwsQ0FBUUcsSUFBUixDQUFhRCxLQUFLLENBQUNFLE9BQU4sQ0FBYyxZQUFkLEVBQTRCLE1BQTVCLENBQWI7QUFDQTs7QUFScUM7QUFXdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ2UsTUFBTUMsR0FBTixTQUFrQkMsZ0JB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YS9DLE1BQWIsRUFBdEIsRUFBNkM7QUFDNUMsV0FBSyxNQUFNa0QsR0FBWCxJQUFrQkgsT0FBbEIsRUFBMkI7QUFDMUIsWUFBSSxDQUFDRyxHQUFHLENBQUNELE1BQVQsRUFBaUI7QUFDaEJILFVBQUFBLEdBQUcsQ0FBQ0MsT0FBSixDQUFZRyxHQUFHLENBQUNDLE1BQWhCLElBQTBCLE1BQU1ELEdBQUcsQ0FBQ0wsTUFBSixDQUFXMUksSUFBWCxDQUFoQztBQUNBO0FBQ0Q7QUFDRDs7QUFFRCxXQUFPMkksR0FBUDtBQUNBOztBQTN5QnVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbW1hbmQgZnJvbSAnLi9wYXJzZXIvY29tbWFuZCc7XG5pbXBvcnQgQ29udGV4dCBmcm9tICcuL3BhcnNlci9jb250ZXh0JztcbmltcG9ydCBkZWJ1ZyBmcm9tICcuL2xpYi9kZWJ1Zyc7XG5pbXBvcnQgRSBmcm9tICcuL2xpYi9lcnJvcnMnO1xuaW1wb3J0IEV4dGVuc2lvbiBmcm9tICcuL3BhcnNlci9leHRlbnNpb24nO1xuaW1wb3J0IGhlbHBDb21tYW5kLCB7IHJlbmRlckhlbHAgfSBmcm9tICcuL2NvbW1hbmRzL2hlbHAnO1xuaW1wb3J0IFBhcnNlciBmcm9tICcuL3BhcnNlci9wYXJzZXInO1xuaW1wb3J0IHBsdXJhbGl6ZSBmcm9tICdwbHVyYWxpemUnO1xuaW1wb3J0IFRlcm1pbmFsIGZyb20gJy4vdGVybWluYWwnO1xuaW1wb3J0IFdlYlNvY2tldCwgeyBTZXJ2ZXIgYXMgV2ViU29ja2V0U2VydmVyIH0gZnJvbSAnd3MnO1xuXG5pbXBvcnQgKiBhcyBhbnNpIGZyb20gJy4vbGliL2Fuc2knO1xuXG5pbXBvcnQgeyBkZWNsYXJlQ0xJS2l0Q2xhc3MsIGRlY29kZSwgc3BsaXQsIGFzc2VydE5vZGVKU1ZlcnNpb24gfSBmcm9tICcuL2xpYi91dGlsJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUtleSB9IGZyb20gJy4vbGliL2tleXMnO1xuaW1wb3J0IHsgV3JpdGVTdHJlYW0gfSBmcm9tICd0dHknO1xuXG5jb25zdCB7IGVycm9yLCBsb2csIHdhcm4gfSA9IGRlYnVnKCdjbGkta2l0OmNsaScpO1xuY29uc3QgeyBoaWdobGlnaHQsIG5vdGUgfSAgPSBkZWJ1Zy5zdHlsZXM7XG5cbi8qKlxuICogV3JpdGVzIGRhdGEgdG8gYSB3ZWJzb2NrZXQuXG4gKi9cbmNsYXNzIE91dHB1dFNvY2tldCBleHRlbmRzIFdyaXRlU3RyZWFtIHtcblx0Y29uc3RydWN0b3IoZmQsIHdzKSB7XG5cdFx0c3VwZXIoZmQpO1xuXHRcdHRoaXMud3MgPSB3cztcblx0fVxuXG5cdHdyaXRlKGNodW5rKSB7XG5cdFx0dGhpcy53cy5zZW5kKGNodW5rLnJlcGxhY2UoLyg/PCFcXHIpXFxuL2csICdcXHJcXG4nKSk7XG5cdH1cbn1cblxuLyoqXG4gKiBEZWZpbmVzIGEgQ0xJIGNvbnRleHQgYW5kIGlzIHJlc3BvbnNpYmxlIGZvciBwYXJzaW5nIHRoZSBjb21tYW5kIGxpbmUgYXJndW1lbnRzLlxuICpcbiAqIEBleHRlbmRzIHtDb250ZXh0fVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDTEkgZXh0ZW5kcyBDb250ZXh0IHtcblx0LyoqXG5cdCAqIENyZWF0ZWQgYSBDTEkgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIFZhcmlvdXMgb3B0aW9ucy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmF1dG9IaWRlQmFubmVyPXRydWVdIC0gV2hlbiBgdHJ1ZWAgYW5kIGEgYGJhbm5lcmAgaXMgc2V0LCBpdCB3aWxsXG5cdCAqIGRldGVjdCBpZiB0aGUgZmlyc3QgY2hhcmFjdGVycyB3cml0dGVuIHRvIGBzdGRvdXRgIG9yIGBzdGRlcnJgIG1hdGNoIGEgSlNPTiBvYmplY3QvYXJyYXkgb3Jcblx0ICogWE1MIGRvY3VtZW50LCB0aGVuIHN1cHByZXNzZXMgdGhlIGJhbm5lci5cblx0ICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IFtwYXJhbXMuYmFubmVyXSAtIEEgYmFubmVyIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBiYW5uZXJcblx0ICogdG8gYmUgZGlzcGxheWVkIGJlZm9yZSBlYWNoIGNvbW1hbmQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5jb2xvcnM9dHJ1ZV0gLSBFbmFibGVzIGNvbG9ycywgc3BlY2lmaWNhbGx5IG9uIHRoZSBoZWxwIHNjcmVlbi5cblx0ICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IFtwYXJhbXMuZGVmYXVsdENvbW1hbmQ9XCJoZWxwXCJdIC0gVGhlIGRlZmF1bHQgY29tbWFuZCB0byBleGVjdXRlLlxuXHQgKiBXaGVuIHZhbHVlIGlzIGEgYFN0cmluZ2AsIGl0IGxvb2tzIHVwIHRoZSBjb21tYW5kIGFuZCBjYWxscyBpdC4gSWYgdmFsdWUgaXMgYSBgRnVuY3Rpb25gLCBpdFxuXHQgKiBzaW1wbHkgaW52b2tlcyBpdC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmVycm9ySWZVbmtub3duQ29tbWFuZD10cnVlXSAtIFdoZW4gYHRydWVgLCBgaGVscGAgaXMgZW5hYmxlZCwgYW5kXG5cdCAqIHRoZSBwYXJzZXIgZGlkbid0IGZpbmQgYSBjb21tYW5kLCBidXQgaXQgZGlkIGZpbmQgYW4gdW5rbm93biBhcmd1bWVudCwgaXQgd2lsbCBzaG93IHRoZSBoZWxwXG5cdCAqIHNjcmVlbiB3aXRoIGFuIHVua25vd24gY29tbWFuZCBlcnJvci5cblx0ICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb258T2JqZWN0fSBbcGFyYW1zLmhlbHBdIC0gQWRkaXRpb25hbCBoZWxwIGNvbnRlbnQgdG8gZGlzcGxheSBvbiB0aGVcblx0ICogaGVscCBzY3JlZW4uIFdoZW4gbWF5IGJlIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGBoZWFkZXJgIGFuZCBgZm9vdGVyYCB3aGljaCB2YWx1ZXNcblx0ICogdGhhdCBhcmUgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIGFzeW5jIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgYSBzdHJpbmcuIFdoZW4gdmFsdWUgaXMgYSBzdHJpbmdcblx0ICogb3IgZnVuY3Rpb24sIGl0IGlzIHRyYXNuZm9ybWVkIGludG8gYSBvYmplY3Qgd2l0aCB0aGUgdmFsdWUgYmVpbmcgdXNlZCBhcyB0aGUgaGVhZGVyLiBOb3RlXG5cdCAqIHRoYXQgdGhlIGNvbW1hbmQgZGVzY3JpcHRpb24gaXMgbm90IGRpc3BsYXllZCB3aGVuIGEgaGVhZGVyIG1lc3NhZ2UgaGFzIGJlZW4gZGVmaW5lZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMuaGVscEV4aXRDb2RlXSAtIFRoZSBleGl0IGNvZGUgdG8gcmV0dXJuIHdoZW4gdGhlIGhlbHAgY29tbWFuZCBpc1xuXHQgKiBmaW5pc2hlZC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMuaGVscFRlbXBsYXRlRmlsZV0gLSBQYXRoIHRvIGEgdGVtcGxhdGUgdG8gcmVuZGVyIGZvciB0aGUgaGVscFxuXHQgKiBjb21tYW5kLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuaGlkZU5vQmFubmVyT3B0aW9uXSAtIFdoZW4gYHRydWVgIGFuZCBhIGBiYW5uZXJgIGlzIHNwZWNpZmllZCwgaXRcblx0ICogZG9lcyBub3QgYWRkIHRoZSBgLS1uby1iYW5uZXJgIG9wdGlvbi5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmhpZGVOb0NvbG9yT3B0aW9uXSAtIFdoZW4gYHRydWVgIGFuZCBgY29sb3JzYCBpcyBlbmFibGVkLCBpdCBkb2VzXG5cdCAqIG5vdCBhZGQgdGhlIGAtLW5vLWNvbG9yYCBvcHRpb24uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLm5hbWVdIC0gVGhlIG5hbWUgb2YgdGhlIHByb2dyYW0uIElmIG5vdCBzZXQsIGRlZmF1bHRzIHRvIGBcInByb2dyYW1cImBcblx0ICogaW4gdGhlIGhlbHAgb3V0dXQgYW5kIGBcIlRoaXMgYXBwbGljYXRpb25cImAgaW4gdGhlIE5vZGUgdmVyc2lvbiBhc3NlcnRpb24uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLm5vZGVWZXJzaW9uXSAtIFRoZSByZXF1aXJlZCBOb2RlLmpzIHZlcnNpb24gdG8gcnVuIHRoZSBhcHAuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdHMuc2VydmVyTW9kZT1mYWxzZV0gLSBXaGVuIGB0cnVlYCwgbWFrZXMgdGhpbmdzIHN1Y2ggdGhhdCBgZXhlYygpYFxuXHQgKiBkb2Vzbid0IGNoYW5nZSBhbnkgZ2xvYmFsIHN0YXRlIGJ5IGRlZXAgY2xvbmluZyB0aGUgZW50aXJlIGNvbnRleHQgdHJlZSBldmVyeSB0aW1lIHRoZVxuXHQgKiBhcmd1bWVudHMgYXJlIHBhcnNlZCBhbmQgY2hhbmdpbmcgdGhlIHByb2Nlc3Mgc3RhdGUuIEVuYWJsaW5nIHRoaXMgb25seSBtYWtlcyBzZW5zZSBpZiB0aGVcblx0ICogYENMSWAgaW5zdGFuY2UgaXMgZ29pbmcgdG8gYmUgcmV1c2VkIHRvIHBhcnNlIGFyZ3VtZW50cyBtdWx0aXBsZSB0aW1lcyBhbmQgaWYgdGhlIHN0YXRlIG9mXG5cdCAqIHRoZSBjb250ZXh0IHRyZWUgaXMgZ29pbmcgdG8gYmUgbW9kaWZpZWQgZHVyaW5nIHBhcnNpbmcgKGkuZS4gdmlhIGEgY2FsbGJhY2spLiBJdCBhbHNvXG5cdCAqIHByZXZlbnRzIGN0cmwtYyAoU0lHSU5UKSBhbmQgZG9lcyBub3Qgc2V0IGFuIGV4aXQgY29kZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLnNob3dCYW5uZXJGb3JFeHRlcm5hbENMSXM9ZmFsc2VdIC0gSWYgYHRydWVgLCBzaG93cyB0aGUgYENMSWBcblx0ICogYmFubmVyLCBhc3N1bWluZyBiYW5uZXIgaXMgZW5hYmxlZCwgZm9yIG5vbi1jbGkta2l0IGVuYWJsZWQgQ0xJcy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLnNob3dIZWxwT25FcnJvcj10cnVlXSAtIElmIGFuIGVycm9yIG9jY3VycyBhbmQgYGhlbHBgIGlzIGVuYWJsZWQsXG5cdCAqIHRoZW4gZGlzcGxheSB0aGUgZXJyb3IgYmVmb3JlIHRoZSBoZWxwIGluZm9ybWF0aW9uLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtcy5zdHlsZXNdIC0gQ3VzdG9tIGRlZmluZWQgc3R5bGUgZnVuY3Rpb25zLlxuXHQgKiBAcGFyYW0ge1Rlcm1pbmFsfSBbcGFyYW1zLnRlcm1pbmFsXSAtIEEgY3VzdG9tIHRlcm1pbmFsIGluc3RhbmNlLCBvdGhlcndpc2UgdXNlcyB0aGUgZGVmYXVsdFxuXHQgKiBnbG9iYWwgdGVybWluYWwgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLnRpdGxlPSdHbG9iYWwnXSAtIFRoZSB0aXRsZSBmb3IgdGhlIGdsb2JhbCBjb250ZXh0LlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gW3BhcmFtcy52ZXJzaW9uXSAtIFRoZSBwcm9ncmFtIHZlcnNpb24gb3IgYSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzXG5cdCAqIGEgdmVyc2lvbi5cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICovXG5cdGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG5cdFx0aWYgKCFwYXJhbXMgfHwgdHlwZW9mIHBhcmFtcyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG5cdFx0XHR0aHJvdyBFLklOVkFMSURfQVJHVU1FTlQoJ0V4cGVjdGVkIENMSSBwYXJhbWV0ZXJzIHRvIGJlIGFuIG9iamVjdCBvciBDb250ZXh0JywgeyBuYW1lOiAncGFyYW1zJywgc2NvcGU6ICdDTEkuY29uc3RydWN0b3InLCB2YWx1ZTogcGFyYW1zIH0pO1xuXHRcdH1cblxuXHRcdGlmIChwYXJhbXMuYmFubmVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHBhcmFtcy5iYW5uZXIgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwYXJhbXMuYmFubmVyICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aHJvdyBFLklOVkFMSURfQVJHVU1FTlQoJ0V4cGVjdGVkIGJhbm5lciB0byBiZSBhIHN0cmluZyBvciBmdW5jdGlvbicsIHsgbmFtZTogJ2Jhbm5lcicsIHNjb3BlOiAnQ0xJLmNvbnN0cnVjdG9yJywgdmFsdWU6IHBhcmFtcy5iYW5uZXIgfSk7XG5cdFx0fVxuXG5cdFx0aWYgKHBhcmFtcy5leHRlbnNpb25zICYmIHR5cGVvZiBwYXJhbXMuZXh0ZW5zaW9ucyAhPT0gJ29iamVjdCcpIHtcblx0XHRcdHRocm93IEUuSU5WQUxJRF9BUkdVTUVOVChcblx0XHRcdFx0J0V4cGVjdGVkIGV4dGVuc2lvbnMgdG8gYmUgYW4gYXJyYXkgb2YgZXh0ZW5zaW9uIHBhdGhzIG9yIGFuIG9iamVjdCBvZiBuYW1lcyB0byBleHRlbnNpb24gcGF0aHMnLFxuXHRcdFx0XHR7IG5hbWU6ICdleHRlbnNpb25zJywgc2NvcGU6ICdDTEkuY29uc3RydWN0b3InLCB2YWx1ZTogcGFyYW1zLmV4dGVuc2lvbnMgfVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAocGFyYW1zLmhlbHBFeGl0Q29kZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBwYXJhbXMuaGVscEV4aXRDb2RlICE9PSAnbnVtYmVyJykge1xuXHRcdFx0dGhyb3cgRS5JTlZBTElEX0FSR1VNRU5UKCdFeHBlY3RlZCBoZWxwIGV4aXQgY29kZSB0byBiZSBhIG51bWJlcicsIHsgbmFtZTogJ2hlbHBFeGl0Q29kZScsIHNjb3BlOiAnQ0xJLmNvbnN0cnVjdG9yJywgdmFsdWU6IHBhcmFtcy5oZWxwRXhpdENvZGUgfSk7XG5cdFx0fVxuXG5cdFx0aWYgKHBhcmFtcy50ZXJtaW5hbCAmJiAhKHBhcmFtcy50ZXJtaW5hbCBpbnN0YW5jZW9mIFRlcm1pbmFsKSkge1xuXHRcdFx0dGhyb3cgRS5JTlZBTElEX0FSR1VNRU5UKCdFeHBlY3RlZCB0ZXJtaW5hbCB0byBiZSBhIFRlcm1pbmFsIGluc3RhbmNlJywgeyBuYW1lOiAndGVybWluYWwnLCBzY29wZTogJ0NMSS5jb25zdHJ1Y3RvcicsIHZhbHVlOiBwYXJhbXMudGVybWluYWwgfSk7XG5cdFx0fVxuXG5cdFx0aWYgKHBhcmFtcy5kZWZhdWx0Q29tbWFuZCAhPT0gdW5kZWZpbmVkICYmICghcGFyYW1zLmRlZmF1bHRDb21tYW5kIHx8ICh0eXBlb2YgcGFyYW1zLmRlZmF1bHRDb21tYW5kICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcGFyYW1zLmRlZmF1bHRDb21tYW5kICE9PSAnZnVuY3Rpb24nKSkpIHtcblx0XHRcdHRocm93IEUuSU5WQUxJRF9BUkdVTUVOVCgnRXhwZWN0ZWQgZGVmYXVsdCBjb21tYW5kIHRvIGJlIGEgc3RyaW5nIG9yIGZ1bmN0aW9uJywgeyBuYW1lOiAnZGVmYXVsdENvbW1hbmQnLCBzY29wZTogJ0NMSS5jb25zdHJ1Y3RvcicsIHZhbHVlOiBwYXJhbXMuZGVmYXVsdENvbW1hbmQgfSk7XG5cdFx0fVxuXG5cdFx0Ly8gbWFrZSBzdXJlIHdlIGhhdmUgYSBgbmFtZWAgYW5kIGB0aXRsZWAgZm9yIHRoZSBjb250ZXh0XG5cdFx0aWYgKCFwYXJhbXMubmFtZSkge1xuXHRcdFx0cGFyYW1zLm5hbWUgPSAncHJvZ3JhbSc7XG5cdFx0fVxuXHRcdGlmICghcGFyYW1zLnRpdGxlKSB7XG5cdFx0XHRwYXJhbXMudGl0bGUgPSAnR2xvYmFsJztcblx0XHR9XG5cblx0XHQvLyBleHRyYWN0IHRoZSBleHRlbnNpb25zLi4uIHdlIGluaXRpYWxpemUgdGhlbSBvdXJzZWx2ZXNcblx0XHRjb25zdCB7IGV4dGVuc2lvbnMgfSA9IHBhcmFtcztcblx0XHRkZWxldGUgcGFyYW1zLmV4dGVuc2lvbnM7XG5cblx0XHRzdXBlcihwYXJhbXMpO1xuXHRcdGRlY2xhcmVDTElLaXRDbGFzcyh0aGlzLCAnQ0xJJyk7XG5cblx0XHR0aGlzLmFwcE5hbWUgICAgICAgICAgICAgICAgICAgPSBwYXJhbXMuYXBwTmFtZSB8fCBwYXJhbXMubmFtZTtcblx0XHR0aGlzLmF1dG9IaWRlQmFubmVyICAgICAgICAgICAgPSBwYXJhbXMuYXV0b0hpZGVCYW5uZXIgIT09IGZhbHNlO1xuXHRcdHRoaXMuY29sb3JzICAgICAgICAgICAgICAgICAgICA9IHBhcmFtcy5jb2xvcnMgIT09IGZhbHNlO1xuXHRcdHRoaXMuZGVmYXVsdENvbW1hbmQgICAgICAgICAgICA9IHBhcmFtcy5kZWZhdWx0Q29tbWFuZDtcblx0XHR0aGlzLmVycm9ySWZVbmtub3duQ29tbWFuZCAgICAgPSBwYXJhbXMuZXJyb3JJZlVua25vd25Db21tYW5kICE9PSBmYWxzZTtcblx0XHR0aGlzLmhlbHAgICAgICAgICAgICAgICAgICAgICAgPSBwYXJhbXMuaGVscDtcblx0XHR0aGlzLmhlbHBFeGl0Q29kZSAgICAgICAgICAgICAgPSBwYXJhbXMuaGVscEV4aXRDb2RlO1xuXHRcdHRoaXMuaGVscFRlbXBsYXRlRmlsZSAgICAgICAgICA9IHBhcmFtcy5oZWxwVGVtcGxhdGVGaWxlO1xuXHRcdHRoaXMuaGlkZU5vQmFubmVyT3B0aW9uICAgICAgICA9IHBhcmFtcy5oaWRlTm9CYW5uZXJPcHRpb247XG5cdFx0dGhpcy5oaWRlTm9Db2xvck9wdGlvbiAgICAgICAgID0gcGFyYW1zLmhpZGVOb0NvbG9yT3B0aW9uO1xuXHRcdHRoaXMubm9kZVZlcnNpb24gICAgICAgICAgICAgICA9IHBhcmFtcy5ub2RlVmVyc2lvbjtcblx0XHR0aGlzLnNlcnZlck1vZGUgICAgICAgICAgICAgICAgPSBwYXJhbXMuc2VydmVyTW9kZTtcblx0XHR0aGlzLnNob3dCYW5uZXJGb3JFeHRlcm5hbENMSXMgPSBwYXJhbXMuc2hvd0Jhbm5lckZvckV4dGVybmFsQ0xJcztcblx0XHR0aGlzLnNob3dIZWxwT25FcnJvciAgICAgICAgICAgPSBwYXJhbXMuc2hvd0hlbHBPbkVycm9yO1xuXHRcdHRoaXMuc3R5bGVzICAgICAgICAgICAgICAgICAgICA9IE9iamVjdC5hc3NpZ24oe30sIGRlYnVnLnN0eWxlcywgcGFyYW1zLnN0eWxlcyk7XG5cdFx0dGhpcy50ZXJtaW5hbCAgICAgICAgICAgICAgICAgID0gcGFyYW1zLnRlcm1pbmFsIHx8IG5ldyBUZXJtaW5hbCgpO1xuXHRcdHRoaXMudmVyc2lvbiAgICAgICAgICAgICAgICAgICA9IHBhcmFtcy52ZXJzaW9uO1xuXHRcdHRoaXMud2FybmluZ3MgICAgICAgICAgICAgICAgICA9IFtdO1xuXG5cdFx0Ly8gaWYgd2UncmUgbm90IGluIHNlcnZlciBtb2RlLCB3aXJlIHVwIHRoZSBTSUdJTlQgaGFuZGxlclxuXHRcdGlmICghdGhpcy5zZXJ2ZXJNb2RlKSB7XG5cdFx0XHR0aGlzLnRlcm1pbmFsLm9uKCdTSUdJTlQnLCAoKSA9PiBwcm9jZXNzLmtpbGwocHJvY2Vzcy5waWQsICdTSUdJTlQnKSk7XG5cdFx0fVxuXG5cdFx0Ly8gYWRkIHRoZSBidWlsdC1pbiBoZWxwXG5cdFx0aWYgKHRoaXMuaGVscCkge1xuXHRcdFx0aWYgKHRoaXMuZGVmYXVsdENvbW1hbmQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLmRlZmF1bHRDb21tYW5kID0gJ2hlbHAnO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBub3RlOiB3ZSBtdXN0IGNsb25lIHRoZSBoZWxwIGNvbW1hbmQgcGFyYW1zIHNpbmNlIHRoZSBvYmplY3QgZ2V0cyBtb2RpZmllZFxuXHRcdFx0dGhpcy5jb21tYW5kKCdoZWxwJywgeyAuLi5oZWxwQ29tbWFuZCB9KTtcblxuXHRcdFx0dGhpcy5vcHRpb24oJy1oLCAtLWhlbHAnLCAnRGlzcGxheXMgdGhlIGhlbHAgc2NyZWVuJyk7XG5cdFx0fVxuXG5cdFx0Ly8gYWRkIHRoZSAtLW5vLWJhbm5lciBmbGFnXG5cdFx0aWYgKHRoaXMuYmFubmVyICYmICF0aGlzLmhpZGVOb0Jhbm5lck9wdGlvbikge1xuXHRcdFx0dGhpcy5vcHRpb24oJy0tbm8tYmFubmVyJywgJ1N1cHByZXNzIHRoZSBiYW5uZXInKTtcblx0XHR9XG5cblx0XHQvLyBhZGQgdGhlIC0tbm8tY29sb3JzIGZsYWdcblx0XHRpZiAodGhpcy5jb2xvcnMgJiYgIXRoaXMuaGlkZU5vQ29sb3JPcHRpb24pIHtcblx0XHRcdHRoaXMub3B0aW9uKCctLW5vLWNvbG9yJywge1xuXHRcdFx0XHRhbGlhc2VzOiBbICctLW5vLWNvbG9ycycgXSxcblx0XHRcdFx0ZGVzYzogJ0Rpc2FibGUgY29sb3JzJ1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gYWRkIHRoZSAtLXZlcnNpb24gZmxhZ1xuXHRcdGlmICh0aGlzLnZlcnNpb24gJiYgIXRoaXMubG9va3VwLnNob3J0LnYgJiYgIXRoaXMubG9va3VwLmxvbmcudmVyc2lvbikge1xuXHRcdFx0dGhpcy5vcHRpb24oJy12LCAtLXZlcnNpb24nLCB7XG5cdFx0XHRcdGNhbGxiYWNrOiBhc3luYyAoeyBleGl0Q29kZSwgb3B0cywgbmV4dCB9KSA9PiB7XG5cdFx0XHRcdFx0aWYgKGF3YWl0IG5leHQoKSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0bGV0IHZlcnNpb24gPSB0aGlzLnZlcnNpb247XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHZlcnNpb24gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdFx0dmVyc2lvbiA9IGF3YWl0IHZlcnNpb24ob3B0cyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQob3B0cy50ZXJtaW5hbCB8fCB0aGlzLnRlcm1pbmFsKS5zdGRvdXQud3JpdGUoYCR7dmVyc2lvbn1cXG5gKTtcblx0XHRcdFx0XHRcdGV4aXRDb2RlKDApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0ZGVzYzogJ091dHB1dHMgdGhlIHZlcnNpb24nXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBhZGQgdGhlIGV4dGVuc2lvbnMgbm93IHRoYXQgdGhlIGF1dG8tZ2VuZXJhdGVkIG9wdGlvbnMgZXhpc3Rcblx0XHRpZiAoZXh0ZW5zaW9ucykge1xuXHRcdFx0Y29uc3QgZXh0cyA9IEFycmF5LmlzQXJyYXkoZXh0ZW5zaW9ucykgPyBleHRlbnNpb25zIDogT2JqZWN0LmVudHJpZXMoZXh0ZW5zaW9ucyk7XG5cdFx0XHRmb3IgKGNvbnN0IGV4dCBvZiBleHRzKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dGhpcy5leHRlbnNpb24uYXBwbHkodGhpcywgQXJyYXkuaXNBcnJheShleHQpID8gWyBleHRbMV0sIGV4dFswXSBdIDogWyBleHQgXSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHR0aGlzLndhcm5pbmdzLnB1c2goYEVycm9yIGxvYWRpbmcgZXh0ZW5zaW9uIFwiJHtleHR9XCJgKTtcblx0XHRcdFx0XHR3YXJuKGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENvbm5lY3RzIHRvIGEgY2xpLWtpdCBXZWJTb2NrZXQgc2VydmVyIGFuZCBpbml0aWFsaXplcyBhIHRlcm1pbmFsIHNlc3Npb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBUaGUgVVJMIHRvIGNvbm5lY3QgdG8uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBWYXJpb3VzIG9wdGlvbnMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5oZWFkZXJzXSAtIEhUVFAgaGVhZGVycyB0byBzZW5kIHdoZW4gY3JlYXRpbmcgdGhlIFdlYlNvY2tldC5cblx0ICogQHBhcmFtIHtUZXJtaWFubH0gW29wdHMudGVybWluYWxdIC0gQSB0ZXJtaW5hbCBpbnN0YW5jZSB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBDTEkgdGVybWluYWxcblx0ICogaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0cy50aW1lb3V0PTUwMDBdIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCB0byBjb25uZWN0IHRvIHRoZVxuXHQgKiBzZXJ2ZXIgYW5kIGNvbXBsZXRlIHRoZSBpbml0aWFsaXphdGlvbiBoYW5kc2hha2UuXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFJlc29sdmVzIGFuIGBFdmVudEVtaXR0ZXJgIGJhc2VkIGhhbmRsZSBjb250YWluaW5nIGEgYHNlbmQoKWBcblx0ICogZnVuY3Rpb24gdG8gc2VuZCBkYXRhIGFzIGlmIGZyb20gYHN0ZGluYC5cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICovXG5cdHN0YXRpYyBhc3luYyBjb25uZWN0KHVybCwgb3B0cyA9IHt9KSB7XG5cdFx0aWYgKCF1cmwgfHwgdHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHRocm93IEUuSU5WQUxJRF9BUkdVTUVOVCgnRXhwZWN0ZWQgVVJMIHRvIGJlIGEgc3RyaW5nJywgeyBuYW1lOiAndXJsJywgc2NvcGU6ICdDTEkuY29ubmVjdCcsIHZhbHVlOiB1cmwgfSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0dGhyb3cgRS5JTlZBTElEX0FSR1VNRU5UKCdFeHBlY3RlZCBvcHRpb25zIHRvIGJlIGFuIG9iamVjdCcsIHsgbmFtZTogJ29wdHMnLCBzY29wZTogJ0NMSS5jb25uZWN0JywgdmFsdWU6IG9wdHMgfSk7XG5cdFx0fVxuXG5cdFx0bGV0IHRlcm0gPSBvcHRzLnRlcm1pbmFsO1xuXHRcdGRlbGV0ZSBvcHRzLnRlcm1pbmFsO1xuXG5cdFx0aWYgKCF0ZXJtKSB7XG5cdFx0XHR0ZXJtID0gbmV3IFRlcm1pbmFsKCk7XG5cdFx0fSBlbHNlIGlmICghKHRlcm0gaW5zdGFuY2VvZiBUZXJtaW5hbCkpIHtcblx0XHRcdHRocm93IEUuSU5WQUxJRF9BUkdVTUVOVCgnRXhwZWN0ZWQgdGVybWluYWwgdG8gYmUgYSBUZXJtaW5hbCBpbnN0YW5jZScsIHsgbmFtZTogJ29wdHMudGVybWluYWwnLCBzY29wZTogJ0NMSS5jb25uZWN0JywgdmFsdWU6IHRlcm0gfSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdGxvZyhgQ29ubmVjdGluZyB0byAke2hpZ2hsaWdodCh1cmwpfWApO1xuXHRcdFx0Y29uc3Qgd3MgPSBuZXcgV2ViU29ja2V0KHVybCwgb3B0cyk7XG5cdFx0XHR3cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcblxuXHRcdFx0Y29uc3QgaGFuZGxlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXHRcdFx0aGFuZGxlLnNlbmQgPSBjaHVuayA9PiB7XG5cdFx0XHRcdGlmICh3cy5yZWFkeVN0YXRlID09PSAxKSB7XG5cdFx0XHRcdFx0d3Muc2VuZChjaHVuayk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IGluaXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBlcnIgPSBuZXcgRXJyb3Iod3MucmVhZHlTdGF0ZSA9PT0gMSA/ICdGYWlsZWQgdG8gaW5pdGlhbGl6ZSB0ZXJtaW5hbCBzZXNzaW9uJyA6ICdGYWlsZWQgdG8gY29ubmVjdCB0byBzZXJ2ZXInKTtcblx0XHRcdFx0ZXJyLmNvZGUgPSAnRVRJTUVPVVQnO1xuXHRcdFx0XHRyZWplY3QoZXJyKTtcblx0XHRcdH0sIG9wdHMudGltZW91dCB8fCA1MDAwKTtcblxuXHRcdFx0d3Mub24oJ2Nsb3NlJywgKGNvZGUsIHJlYXNvbikgPT4gaGFuZGxlLmVtaXQoJ2Nsb3NlJywgY29kZSwgcmVhc29uKSk7XG5cblx0XHRcdHdzLm9uKCdlcnJvcicsIGVyciA9PiBoYW5kbGUuZW1pdCgnZXJyb3InLCBlcnIpKTtcblxuXHRcdFx0d3Mub24oJ21lc3NhZ2UnLCBtc2cgPT4ge1xuXHRcdFx0XHRpZiAobXNnID09PSBhbnNpLmN1cnNvci5nZXQgJiYgd3MucmVhZHlTdGF0ZSA9PT0gMSkge1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dChpbml0VGltZXIpO1xuXHRcdFx0XHRcdHdzLnNlbmQoYCR7YW5zaS5lc2N9JHt0ZXJtLnJvd3N9OyR7dGVybS5jb2x1bW5zfVJgKTtcblx0XHRcdFx0XHRyZXNvbHZlKGhhbmRsZSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgY29kZSA9IG1zZy5tYXRjaChhbnNpLmN1c3RvbS5leGl0LnJlKTtcblx0XHRcdFx0aWYgKGNvZGUpIHtcblx0XHRcdFx0XHRoYW5kbGUuZW1pdCgnZXhpdCcsIGNvZGVbMV0pO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRlcm0uc3Rkb3V0LndyaXRlKG1zZyk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGVybS5vbigna2V5cHJlc3MnLCAoY2h1bmssIGtleSkgPT4ge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnS0VZUFJFU1MnLCBjaHVuayA9PT0gdW5kZWZpbmVkID8gY2h1bmsgOiBCdWZmZXIuZnJvbShjaHVuayksIGtleSwgQnVmZmVyLmZyb20oa2V5LnNlcXVlbmNlKSk7XG5cdFx0XHRcdGhhbmRsZS5zZW5kKGFuc2kuY3VzdG9tLmtleXByZXNzKGtleSkpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRlcm0ub24oJ3Jlc2l6ZScsICh7IHJvd3MsIGNvbHVtbnMgfSkgPT4ge1xuXHRcdFx0XHRoYW5kbGUuc2VuZChgJHthbnNpLmVzY30ke3Jvd3N9OyR7Y29sdW1uc31SYCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGVybS5vbignU0lHSU5UJywgKCkgPT4ge1xuXHRcdFx0XHR3cy5jbG9zZSgpO1xuXHRcdFx0XHRwcm9jZXNzLmV4aXQoKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlcyB0aGUgY29tbWFuZCBsaW5lIGFyZ3VtZW50cyBhbmQgcnVucyB0aGUgY29tbWFuZC5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gW19hcmd2XSAtIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byBwYXJzZS4gSWYgbm90IHNwZWNpZmllZCwgaXRcblx0ICogZGVmYXVsdHMgdG8gdGhlIGBwcm9jZXNzLmFyZ3ZgIHN0YXJ0aW5nIHdpdGggdGhlIDNyZCBhcmd1bWVudC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIFZhcmlvdXMgb3B0aW9ucy5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLmRhdGFdIC0gVXNlci1kZWZpbmVkIGRhdGEgdG8gcGFzcyBpbnRvIHRoZSBzZWxlY3RlZCBjb21tYW5kLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5leGl0Q29kZV0gLSBBIGZ1bmN0aW9uIHRoYXQgc2V0cyB0aGUgZXhpdCBjb2RlLlxuXHQgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBbcGFyYW1zLnBhcmVudENvbnRleHROYW1lc10gLSBBbiBhcnJheSBvZiBwYXJlbnQgY29udGV4dCBuYW1lcy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0cy5yZW1vdGVIZWxwPWZhbHNlXSAtIFdoZW4gYHRydWVgLCBkb24ndCBleGVjdXRlIHRoZSBidWlsdC1pbiBoZWxwXG5cdCAqIGNvbW1hbmQuIFRoaXMgaXMgc2V0IHdoZW4gYSByZXF1ZXN0IGNvbWVzIGZyb20gYSByZW1vdGUgY29ubmVjdGlvbi5cblx0ICogQHBhcmFtIHtUZXJtaWFubH0gW29wdHMudGVybWluYWxdIC0gQSB0ZXJtaW5hbCBpbnN0YW5jZSB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBDTEkgdGVybWluYWxcblx0ICogaW5zdGFuY2UuXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlLjxBcmd1bWVudHM+fVxuXHQgKiBAYWNjZXNzIHB1YmxpY1xuXHQgKi9cblx0YXN5bmMgZXhlYyhfYXJndiwgb3B0cyA9IHt9KSB7XG5cdFx0YXNzZXJ0Tm9kZUpTVmVyc2lvbih0aGlzKTtcblxuXHRcdGlmICghX2FyZ3YpIHtcblx0XHRcdF9hcmd2ID0gcHJvY2Vzcy5hcmd2LnNsaWNlKDIpO1xuXHRcdH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoX2FyZ3YpKSB7XG5cdFx0XHR0aHJvdyBFLklOVkFMSURfQVJHVU1FTlQoJ0V4cGVjdGVkIGFyZ3VtZW50cyB0byBiZSBhbiBhcnJheScsIHsgbmFtZTogJ2FyZ3MnLCBzY29wZTogJ0NMSS5leGVjJywgdmFsdWU6IF9hcmd2IH0pO1xuXHRcdH1cblxuXHRcdGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcblx0XHRcdHRocm93IEUuSU5WQUxJRF9BUkdVTUVOVCgnRXhwZWN0ZWQgb3B0cyB0byBiZSBhbiBvYmplY3QnLCB7IG5hbWU6ICdvcHRzJywgc2NvcGU6ICdDTEkuZXhlYycsIHZhbHVlOiBvcHRzIH0pO1xuXHRcdH1cblxuXHRcdGlmICghb3B0cy5kYXRhKSB7XG5cdFx0XHRvcHRzLmRhdGEgPSB7fTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLmRhdGEgIT09ICdvYmplY3QnKSB7XG5cdFx0XHR0aHJvdyBFLklOVkFMSURfQVJHVU1FTlQoJ0V4cGVjdGVkIGRhdGEgdG8gYmUgYW4gb2JqZWN0JywgeyBuYW1lOiAnb3B0cy5kYXRhJywgc2NvcGU6ICdDTEkuZXhlYycsIHZhbHVlOiBvcHRzLmRhdGEgfSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFvcHRzLnRlcm1pbmFsKSB7XG5cdFx0XHRvcHRzLnRlcm1pbmFsID0gdGhpcy50ZXJtaW5hbDtcblx0XHR9IGVsc2UgaWYgKCEob3B0cy50ZXJtaW5hbCBpbnN0YW5jZW9mIFRlcm1pbmFsKSkge1xuXHRcdFx0dGhyb3cgRS5JTlZBTElEX0FSR1VNRU5UKCdFeHBlY3RlZCB0ZXJtaW5hbCB0byBiZSBhIFRlcm1pbmFsIGluc3RhbmNlJywgeyBuYW1lOiAnb3B0cy50ZXJtaW5hbCcsIHNjb3BlOiAnQ0xJLmV4ZWMnLCB2YWx1ZTogb3B0cy50ZXJtaW5hbCB9KTtcblx0XHR9XG5cblx0XHRsZXQgZXhpdENvZGUgPSB1bmRlZmluZWQ7XG5cdFx0bGV0IHNob3dIZWxwT25FcnJvciA9IHRoaXMucHJvcCgnc2hvd0hlbHBPbkVycm9yJyk7XG5cdFx0Y29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcihvcHRzKS5saW5rKHRoaXMpO1xuXHRcdGNvbnN0IF9fYXJndiA9IF9hcmd2LnNsaWNlKDApO1xuXG5cdFx0b3B0cy5leGl0Q29kZSA9IGNvZGUgPT4gY29kZSA9PT0gdW5kZWZpbmVkID8gZXhpdENvZGUgOiAoZXhpdENvZGUgPSBjb2RlIHx8IDApO1xuXHRcdG9wdHMuc3R5bGVzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdHlsZXMsIG9wdHMuc3R5bGVzKTtcblxuXHRcdGxldCByZXN1bHRzID0ge1xuXHRcdFx0XzogICAgICAgICAgICAgIHVuZGVmaW5lZCxcblx0XHRcdF9hcmd2LCAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwgdW5wYXJzZWQgYXJndW1lbnRzXG5cdFx0XHRfX2FyZ3YsICAgICAgICAgLy8gdGhlIHBhcnNlZCBhcmd1bWVudHNcblx0XHRcdGFyZ3Y6ICAgICAgICAgICB1bmRlZmluZWQsXG5cdFx0XHRiYW5uZXJGaXJlZDogICAgZmFsc2UsXG5cdFx0XHRiYW5uZXJSZW5kZXJlZDogZmFsc2UsXG5cdFx0XHRjbGk6ICAgICAgICAgICAgdGhpcyxcblx0XHRcdGNtZDogICAgICAgICAgICB1bmRlZmluZWQsXG5cdFx0XHRjb25zb2xlOiAgICAgICAgb3B0cy50ZXJtaW5hbC5jb25zb2xlLFxuXHRcdFx0Y29udGV4dHM6ICAgICAgIHVuZGVmaW5lZCxcblx0XHRcdGRhdGE6ICAgICAgICAgICBvcHRzLmRhdGEsXG5cdFx0XHRleGl0Q29kZTogICAgICAgb3B0cy5leGl0Q29kZSxcblx0XHRcdGhlbHA6ICAgICAgICAgICAoKSA9PiByZW5kZXJIZWxwKHJlc3VsdHMuY21kLCBvcHRzKSxcblx0XHRcdHJlc3VsdDogICAgICAgICB1bmRlZmluZWQsXG5cdFx0XHRzZXRFeGl0Q29kZTogICAgb3B0cy5leGl0Q29kZSxcblx0XHRcdHN0eWxlczogICAgICAgICBvcHRzLnN0eWxlcyxcblx0XHRcdHRlcm1pbmFsOiAgICAgICBvcHRzLnRlcm1pbmFsLFxuXHRcdFx0dW5rbm93bjogICAgICAgIHVuZGVmaW5lZCxcblx0XHRcdHdhcm5pbmdzOiAgICAgICB0aGlzLndhcm5pbmdzXG5cdFx0fTtcblxuXHRcdGNvbnN0IHJlbmRlckJhbm5lciA9IGFzeW5jIChzdGF0ZSkgPT4ge1xuXHRcdFx0Y29uc3QgeyBhcmd2LCBjbGksIGNtZCA9IGNsaSwgdGVybWluYWwgfSA9IHN0YXRlO1xuXG5cdFx0XHQvLyBpZiAtLW5vLWJhbm5lciwgdGhlbiByZXR1cm5cblx0XHRcdC8vIG9yIGlmIHdlJ3JlIHJ1bm5pbmcgYW4gZXh0ZW5zaW9uIHRoYXQgaXMgbm90IGEgY2xpLWtpdCBleHRlbnNpb24sIHRoZW4gcmV0dXJuIGFuZFxuXHRcdFx0Ly8gbGV0IHRoZSBleHRlbnNpb24gQ0xJIHJlbmRlciBpdHMgb3duIGJhbm5lclxuXHRcdFx0aWYgKHN0YXRlLmJhbm5lclJlbmRlcmVkIHx8IChhcmd2ICYmICFhcmd2LmJhbm5lcikgfHwgKGNtZCBpbnN0YW5jZW9mIEV4dGVuc2lvbiAmJiAhY21kLmlzQ0xJS2l0RXh0ZW5zaW9uICYmICFjbWQuZ2V0KCdzaG93QmFubmVyRm9yRXh0ZXJuYWxDTElzJykpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0c3RhdGUuYmFubmVyUmVuZGVyZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBjb3B5IHRoZSBiYW5uZXIgdG8gdGhlIHN0YXRlXG5cdFx0XHQvLyBpZiB0aGUgYmFubmVyIGlzIGEgZnVuY3Rpb24sIHJ1biBpdCBub3dcblx0XHRcdGlmIChjbWQuYmFubmVyICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0c3RhdGUuYmFubmVyID0gY21kLmJhbm5lcjtcblx0XHRcdFx0Y21kLl9vcmlnQmFubmVyID0gY21kLmJhbm5lcjtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNtZCwgJ2Jhbm5lcicsIHtcblx0XHRcdFx0XHRnZXQoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gY21kLl9vcmlnQmFubmVyO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c2V0KHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRzdGF0ZS5iYW5uZXIgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGxldCBwID0gY21kLnBhcmVudDsgcDsgcCA9IHAucGFyZW50KSB7XG5cdFx0XHRcdGlmIChzdGF0ZS5iYW5uZXIgPT09IHVuZGVmaW5lZCAmJiAoIShzdGF0ZS5iYW5uZXJGaXJlZCBpbnN0YW5jZW9mIEVycm9yKSB8fCBwLmJhbm5lciAhPT0gdW5kZWZpbmVkKSkge1xuXHRcdFx0XHRcdHN0YXRlLmJhbm5lciA9IHAuYmFubmVyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cC5fb3JpZ0Jhbm5lciA9IHAuYmFubmVyO1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocCwgJ2Jhbm5lcicsIHtcblx0XHRcdFx0XHRnZXQoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcC5fb3JpZ0Jhbm5lcjtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHNldCh2YWx1ZSkge1xuXHRcdFx0XHRcdFx0c3RhdGUuYmFubmVyID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBzdGF0ZS5iYW5uZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0c3RhdGUuYmFubmVyID0gYXdhaXQgc3RhdGUuYmFubmVyKHN0YXRlKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcHJpbnRCYW5uZXIgPSAoKSA9PiB7XG5cdFx0XHRcdGlmICh0eXBlb2Ygc3RhdGUuYmFubmVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCYW5uZXIgZnVuY3Rpb24gbm90IHN1cHBvcnRlZCBoZXJlJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHN0YXRlLmJhbm5lcikge1xuXHRcdFx0XHRcdHN0YXRlLmJhbm5lciA9IFN0cmluZyhzdGF0ZS5iYW5uZXIpLnRyaW0oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc3RhdGUuYmFubmVyKSB7XG5cdFx0XHRcdFx0dGVybWluYWwuc3Rkb3V0LndyaXRlKGAke3N0YXRlLmJhbm5lcn1cXG5cXG5gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKGNtZC5wcm9wKCdhdXRvSGlkZUJhbm5lcicpKSB7XG5cdFx0XHRcdC8vIHdhaXQgdG8gc2hvdyBiYW5uZXJcblx0XHRcdFx0dGVybWluYWwub25PdXRwdXQoKCkgPT4gcHJpbnRCYW5uZXIoKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBzaG93IGJhbm5lciBub3dcblx0XHRcdFx0cHJpbnRCYW5uZXIoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3QgYmFubmVySG9vayA9IGFzeW5jIHN0YXRlID0+IHtcblx0XHRcdGlmICghc3RhdGUuYmFubmVyRmlyZWQpIHtcblx0XHRcdFx0c3RhdGUuYmFubmVyRmlyZWQgPSB0cnVlO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMuaG9vaygnYmFubmVyJywgcmVuZGVyQmFubmVyKShzdGF0ZSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdHN0YXRlLmJhbm5lckZpcmVkID0gZXJyO1xuXHRcdFx0XHRcdHRocm93IGVycjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgY2xpID0gdGhpcy5zZXJ2ZXJNb2RlID8gbmV3IENvbnRleHQoKS5pbml0KHRoaXMsIHRydWUpIDogdGhpcztcblxuXHRcdFx0bG9nKGBQYXJzaW5nICR7X19hcmd2Lmxlbmd0aH0gYXJndW1lbnQke19fYXJndi5sZW5ndGggIT09IDEgPyAncycgOiAnJ30gJHtub3RlKGAoc2VydmVyIG1vZGU6ICR7ISF0aGlzLnNlcnZlck1vZGV9KWApfWApO1xuXG5cdFx0XHQvLyBwYXJzZSB0aGUgY29tbWFuZCBsaW5lIGFyZ3VtZW50c1xuXHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRfLFxuXHRcdFx0XHRhcmd2LFxuXHRcdFx0XHRjb250ZXh0cyxcblx0XHRcdFx0cmVxdWlyZWQsXG5cdFx0XHRcdHVua25vd25cblx0XHRcdH0gPSBhd2FpdCBwYXJzZXIucGFyc2Uoe1xuXHRcdFx0XHRhcmdzOiBfX2FyZ3YsXG5cdFx0XHRcdGN0eDogIGNsaSxcblx0XHRcdFx0ZGF0YTogcmVzdWx0cy5kYXRhXG5cdFx0XHR9KTtcblxuXHRcdFx0bG9nKCdQYXJzaW5nIGNvbXBsZXRlOiAnICtcblx0XHRcdFx0YCR7cGx1cmFsaXplKCdvcHRpb24nLCBPYmplY3Qua2V5cyhhcmd2KS5sZW5ndGgsIHRydWUpfSwgYCArXG5cdFx0XHRcdGAke3BsdXJhbGl6ZSgndW5rbm93biBvcHRpb24nLCBPYmplY3Qua2V5cyh1bmtub3duKS5sZW5ndGgsIHRydWUpfSwgYCArXG5cdFx0XHRcdGAke3BsdXJhbGl6ZSgnYXJnJywgXy5sZW5ndGgsIHRydWUpfSwgYCArXG5cdFx0XHRcdGAke3BsdXJhbGl6ZSgnY29udGV4dCcsIGNvbnRleHRzLmxlbmd0aCwgdHJ1ZSl9IGAgK1xuXHRcdFx0XHRub3RlKGAoZXhpdDogJHtyZXN1bHRzLmV4aXRDb2RlKCl9KWApXG5cdFx0XHQpO1xuXG5cdFx0XHRjb25zdCBjbWQgPSBjb250ZXh0c1swXTtcblxuXHRcdFx0Ly8gY2hlY2sgZm9yIG1pc3NpbmcgYXJndW1lbnRzIGFuZCBvcHRpb25zIGlmIGhlbHAgaXMgZGlzYWJsZWQgb3IgaXMgbm90IHNldFxuXHRcdFx0aWYgKCF0aGlzLmhlbHAgfHwgIWFyZ3YuaGVscCkge1xuXHRcdFx0XHQvLyBgX2AgYWxyZWFkeSBjb250YWlucyBhbGwga25vd24gcGFyc2VkIGFyZ3VtZW50cywgYnV0IG1heSBub3QgY29udGFpbiBhbGwgcmVxdWlyZWRcblx0XHRcdFx0Ly8gYXJndW1lbnRzLCB0aHVzIHdlIG11c3QgbG9vcCBvdmVyIHRoZSByZW1haW5pbmcgYXJndW1lbnRzIGFuZCBjaGVjayBpZiB0aGVyZSBhcmVcblx0XHRcdFx0Ly8gYW55IG1pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnRzLlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBub3RlIHRoYXQgd2Ugc3RvcCBsb29waW5nIGlmIHdlIGZpbmQgYW4gYXJndW1lbnQgd2l0aCBtdWx0aXBsZSBhcmd1bWVudHMgc2luY2Vcblx0XHRcdFx0Ly8gd2UndmUgYWxyZWFkeSBnb2JibGVkIHVwIGFsbCB0aGUgdmFsdWVzXG5cdFx0XHRcdGxldCBpID0gXy5sZW5ndGg7XG5cdFx0XHRcdGNvbnN0IGxlbiA9IGNtZC5hcmdzLmxlbmd0aDtcblx0XHRcdFx0aWYgKGkgPT09IDAgfHwgKGkgPCBsZW4gJiYgIWNtZC5hcmdzW2kgLSAxXS5tdWx0aXBsZSkpIHtcblx0XHRcdFx0XHRmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAoY21kLmFyZ3NbaV0ucmVxdWlyZWQgJiYgKCFjbWQuYXJnc1tpXS5tdWx0aXBsZSB8fCAhYXJndltjbWQuYXJnc1tpXS5uYW1lXS5sZW5ndGgpKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IEUuTUlTU0lOR19SRVFVSVJFRF9BUkdVTUVOVChcblx0XHRcdFx0XHRcdFx0XHRgTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudCBcIiR7Y21kLmFyZ3NbaV0ubmFtZX1cImAsXG5cdFx0XHRcdFx0XHRcdFx0eyBuYW1lOiAnYXJncycsIHNjb3BlOiAnUGFyc2VyLnBhcnNlJywgdmFsdWU6IGNtZC5hcmdzW2ldIH1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocmVxdWlyZWQuc2l6ZSkge1xuXHRcdFx0XHRcdHRocm93IEUuTUlTU0lOR19SRVFVSVJFRF9PUFRJT04oXG5cdFx0XHRcdFx0XHRgTWlzc2luZyAke3JlcXVpcmVkLnNpemV9IHJlcXVpcmVkIG9wdGlvbiR7cmVxdWlyZWQuc2l6ZSA9PT0gMSA/ICcnIDogJ3MnfTpgLFxuXHRcdFx0XHRcdFx0eyBuYW1lOiAnb3B0aW9ucycsIHNjb3BlOiAnUGFyc2VyLnBhcnNlJywgcmVxdWlyZWQ6IHJlcXVpcmVkLnZhbHVlcygpIH1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJlc3VsdHMuXyAgICAgICAgICAgICAgICAgID0gXztcblx0XHRcdHJlc3VsdHMuYXJndiAgICAgICAgICAgICAgID0gYXJndjtcblx0XHRcdHJlc3VsdHMuY21kICAgICAgICAgICAgICAgID0gY21kO1xuXHRcdFx0cmVzdWx0cy5jbGkgICAgICAgICAgICAgICAgPSBjbGk7XG5cdFx0XHRyZXN1bHRzLmNvbnRleHRzICAgICAgICAgICA9IGNvbnRleHRzO1xuXHRcdFx0cmVzdWx0cy5wYXJlbnRDb250ZXh0TmFtZXMgPSBvcHRzLnBhcmVudENvbnRleHROYW1lcztcblx0XHRcdHJlc3VsdHMudW5rbm93biAgICAgICAgICAgID0gdW5rbm93bjtcblxuXHRcdFx0Ly8gY2hlY2sgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IGVycm9yZWRcblx0XHRcdGlmIChyZXN1bHRzLmV4aXRDb2RlKCkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvLyBkZXRlcm1pbmUgdGhlIGNvbW1hbmQgdG8gcnVuXG5cdFx0XHRcdGlmICh0aGlzLmhlbHAgJiYgYXJndi5oZWxwICYmICghY21kLmlzRXh0ZW5zaW9uIHx8IGNtZC5pc0NMSUtpdEV4dGVuc2lvbikpIHtcblx0XHRcdFx0XHQvLyBkaXNhYmxlIHRoZSBidWlsdC1pbiBoZWxwIGlmIHRoZSBoZWxwIGlzIHRvIGJlIHJlbmRlcmVkIHJlbW90ZWx5XG5cdFx0XHRcdFx0Ly8gbm90ZTogdGhlIGN1cnJlbnQgYGNtZGAgY291bGQgYmUgYSBjb21tYW5kIHVuZGVyIGFuIGV4dGVuc2lvbiwgc28gd2UgY2FsbFxuXHRcdFx0XHRcdC8vIGBjbWQucHJvcCgpYCB0byBzY2FuIHRoZSBjb21tYW5kJ3MgcGFyZW50cyB0byBzZWUgaWYgdGhpcyBjb21tYW5kIGlzXG5cdFx0XHRcdFx0Ly8gYWN0dWFsbHkgcmVtb3RlXG5cdFx0XHRcdFx0aWYgKCFjbWQucHJvcCgncmVtb3RlSGVscCcpKSB7XG5cdFx0XHRcdFx0XHRsb2coYFNlbGVjdGVkIGhlbHAgY29tbWFuZCwgd2FzIFwiJHtjbWQubmFtZX1cImApO1xuXHRcdFx0XHRcdFx0cmVzdWx0cy5jbWQgPSB0aGlzLmNvbW1hbmRzLmdldCgnaGVscCcpO1xuXHRcdFx0XHRcdFx0Y29udGV4dHMudW5zaGlmdChyZXN1bHRzLmNtZCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuZGVmYXVsdENvbW1hbmQgPT09ICdzdHJpbmcnICYmXG5cdFx0XHRcdFx0KFxuXHRcdFx0XHRcdFx0Ly8gaWYgd2UgZG9uJ3QgaGF2ZSBhbiBhY3Rpb24gb3IgY29tbWFuZCwgdGhlbiBkbyB0aGUgZGVmYXVsdCBjb21tYW5kXG5cdFx0XHRcdFx0XHQhKGNtZCBpbnN0YW5jZW9mIENvbW1hbmQpIHx8XG5cblx0XHRcdFx0XHRcdC8vIGlmIHdlIGhhdmUgYSBjb21tYW5kLCBidXQgdGhlIGNvbW1hbmQgZG9lcyBub3QgaGF2ZSBhbiBhY3Rpb24sIHRoZW4gZG9cblx0XHRcdFx0XHRcdC8vIHRoZSBkZWZhdWx0IGNvbW1hbmRcblx0XHRcdFx0XHRcdCh0eXBlb2YgY21kLmFjdGlvbiAhPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0XHRcdFx0XHQoIShjbWQuYWN0aW9uIGluc3RhbmNlb2YgQ29tbWFuZCkgfHwgdHlwZW9mIGNtZC5hY3Rpb24uYWN0aW9uICE9PSAnZnVuY3Rpb24nKVxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdCkgJiZcblx0XHRcdFx0XHQoIWNtZC5wcm9wKCdyZW1vdGVIZWxwJykgfHwgdGhpcy5kZWZhdWx0Q29tbWFuZCAhPT0gJ2hlbHAnKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRsb2coYFNlbGVjdGVkIGRlZmF1bHQgY29tbWFuZDogJHtoaWdobGlnaHQodGhpcy5kZWZhdWx0Q29tbWFuZCl9YCk7XG5cdFx0XHRcdFx0cmVzdWx0cy5jbWQgPSB0aGlzLmNvbW1hbmRzLmdldCh0aGlzLmRlZmF1bHRDb21tYW5kKTtcblx0XHRcdFx0XHRpZiAoIShyZXN1bHRzLmNtZCBpbnN0YW5jZW9mIENvbW1hbmQpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBFLkRFRkFVTFRfQ09NTUFORF9OT1RfRk9VTkQoYFRoZSBkZWZhdWx0IGNvbW1hbmQgXCIke3RoaXMuZGVmYXVsdENvbW1hbmR9XCIgd2FzIG5vdCBmb3VuZCFgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29udGV4dHMudW5zaGlmdChyZXN1bHRzLmNtZCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBub3cgdGhhdCB3ZSd2ZSBtYWRlIGl0IHBhc3QgdGhlIHBhcnNpbmcgYW5kIHZhbGlkYXRpb24sIHdlIGFyZSBnb2luZyB0byBleGVjdXRlXG5cdFx0XHRcdC8vIHRoZSBjb21tYW5kIGFuZCB0aHVzIHdlIHdhbnQgdG8gdHVybiBvZmYgc2hvdyBoZWxwIG9uIGVycm9yIHVubGVzcyB0aGUgZXJyb3Jcblx0XHRcdFx0Ly8gZXhwbGljaXRseSByZXF1ZXN0cyBoZWxwIHRvIGJlIHNob3duXG5cdFx0XHRcdHNob3dIZWxwT25FcnJvciA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIGhhbmRsZSB0aGUgYmFubmVyXG5cdFx0XHRcdGF3YWl0IGJhbm5lckhvb2socmVzdWx0cyk7XG5cblx0XHRcdFx0cmVzdWx0cyA9IGF3YWl0IHRoaXMuaG9vaygnZXhlYycsIGFzeW5jIHJlc3VsdHMgPT4ge1xuXHRcdFx0XHRcdC8vIGV4ZWN1dGUgdGhlIGNvbW1hbmRcblx0XHRcdFx0XHRpZiAocmVzdWx0cy5jbWQgJiYgdHlwZW9mIHJlc3VsdHMuY21kLmFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0bG9nKGBFeGVjdXRpbmcgY29tbWFuZDogJHtoaWdobGlnaHQocmVzdWx0cy5jbWQubmFtZSl9YCk7XG5cdFx0XHRcdFx0XHRyZXN1bHRzLnJlc3VsdCA9IGF3YWl0IHJlc3VsdHMuY21kLmFjdGlvbi5jYWxsKHJlc3VsdHMuY21kLCByZXN1bHRzKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHJlc3VsdHMuY21kICYmIHJlc3VsdHMuY21kLmFjdGlvbiBpbnN0YW5jZW9mIENvbW1hbmQgJiYgdHlwZW9mIHJlc3VsdHMuY21kLmFjdGlvbi5hY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdC8vIEkgdGhpbmsgdGhpcyBpcyByZWxhdGVkIHRvIHRoZSBsZWdhY3kgZXh0ZW5zaW9uIHN0dWZmLi4uXG5cdFx0XHRcdFx0XHRsb2coYEV4ZWN1dGluZyBjb21tYW5kOiAke2hpZ2hsaWdodChyZXN1bHRzLmNtZC5hY3Rpb24ubmFtZSl9ICh2aWEgJHtoaWdobGlnaHQocmVzdWx0cy5jbWQubmFtZSl9KWApO1xuXHRcdFx0XHRcdFx0cmVzdWx0cy5yZXN1bHQgPSBhd2FpdCByZXN1bHRzLmNtZC5hY3Rpb24uYWN0aW9uLmNhbGwocmVzdWx0cy5jbWQuYWN0aW9uLCByZXN1bHRzKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmRlZmF1bHRDb21tYW5kICA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0bG9nKGBFeGVjdXRpbmcgZGVmYXVsdCBjb21tYW5kOiAke2hpZ2hsaWdodCh0aGlzLmRlZmF1bHRDb21tYW5kLm5hbWUgfHwgJ2Fub255bW91cycpfWApO1xuXHRcdFx0XHRcdFx0cmVzdWx0cy5yZXN1bHQgPSBhd2FpdCB0aGlzLmRlZmF1bHRDb21tYW5kLmNhbGwodGhpcy5kZWZhdWx0Q29tbWFuZCwgcmVzdWx0cyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxvZygnTm8gY29tbWFuZCB0byBleGVjdXRlLCByZXR1cm5pbmcgcGFyc2VkIGFyZ3VtZW50cycpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fSkocmVzdWx0cyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5zZXJ2ZXJNb2RlKSB7XG5cdFx0XHRcdHByb2Nlc3MuZXhpdENvZGUgPSByZXN1bHRzLmV4aXRDb2RlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0aWYgKCF0aGlzLnNlcnZlck1vZGUpIHtcblx0XHRcdFx0ZXJyb3IoZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlIHx8IGVyci50b1N0cmluZygpIHx8ICdVbmtub3duIGVycm9yJyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChlcnIuanNvbiA9PT0gdW5kZWZpbmVkICYmIHJlc3VsdHMuY21kPy5wcm9wKCdqc29uTW9kZScpKSB7XG5cdFx0XHRcdGVyci5qc29uID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHRoZSBiYW5uZXIgcmVuZGVyZWQgZHVyaW5nIGFuIGVycm9yIGRvZXMgbm90IGZpcmUgdGhlIGhvb2tcblx0XHRcdFx0YXdhaXQgcmVuZGVyQmFubmVyKHJlc3VsdHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBoZWxwID0gdGhpcy5oZWxwICYmIChzaG93SGVscE9uRXJyb3IgIT09IGZhbHNlIHx8IGVyci5zaG93SGVscCkgJiYgdGhpcy5jb21tYW5kcy5nZXQoJ2hlbHAnKTtcblx0XHRcdGlmIChoZWxwKSB7XG5cdFx0XHRcdHJlc3VsdHMuY29udGV4dHMgPSBlcnIuY29udGV4dHMgfHwgcGFyc2VyLmNvbnRleHRzIHx8IFsgdGhpcyBdO1xuXHRcdFx0XHRyZXN1bHRzLmVyciA9IGVycjtcblx0XHRcdFx0cmVzdWx0cy5yZXN1bHQgPSBhd2FpdCBoZWxwLmFjdGlvbihyZXN1bHRzKTtcblx0XHRcdFx0cHJvY2Vzcy5leGl0Q29kZSA9IHJlc3VsdHMuZXhpdENvZGUoKTtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHR9XG5cblx0XHRcdHRocm93IGVycjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU3RhcnRzIGEgV2ViU29ja2V0IHNlcnZlci5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIFdlYlNvY2tldCBzZXJ2ZXIgb3B0aW9ucy4gVmlzaXRcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvYmxvYi9IRUFEL2RvYy93cy5tZCNuZXctd2Vic29ja2V0c2VydmVyb3B0aW9ucy1jYWxsYmFjayBmb3Jcblx0ICogbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQHJldHVybnMge1Byb21pc2U8V2ViU29ja2V0U2VydmVyPn1cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICovXG5cdGFzeW5jIGxpc3RlbihvcHRzID0ge30pIHtcblx0XHRpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG5cdFx0XHR0aHJvdyBFLklOVkFMSURfQVJHVU1FTlQoJ0V4cGVjdGVkIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0JywgeyBuYW1lOiAnb3B0cycsIHNjb3BlOiAnQ0xJLmxpc3RlbicsIHZhbHVlOiBvcHRzIH0pO1xuXHRcdH1cblxuXHRcdGlmIChvcHRzLnBvcnQgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIG9wdHMucG9ydCAhPT0gJ251bWJlcicgfHwgb3B0cy5wb3J0IDwgMSB8fCBvcHRzLnBvcnQgPiA2NTUzNSkpIHtcblx0XHRcdHRocm93IEUuSU5WQUxJRF9BUkdVTUVOVCgnRXhwZWN0ZWQgcG9ydCB0byBiZSBhIG51bWJlciBiZXR3ZWVuIDEgYW5kIDY1NTM1JywgeyBuYW1lOiAnb3B0cy5wb3J0Jywgc2NvcGU6ICdDTEkubGlzdGVuJywgdmFsdWU6IG9wdHMucG9ydCB9KTtcblx0XHR9XG5cblx0XHRsb2coYFN0YXJ0aW5nIFdlYlNvY2tldFNlcnZlciR7b3B0cy5wb3J0ID8gYCBvbiBwb3J0ICR7aGlnaGxpZ2h0KG9wdHMucG9ydCl9YCA6ICcnfS4uLmApO1xuXG5cdFx0aWYgKCF0aGlzLnNlcnZlck1vZGUpIHtcblx0XHRcdGxvZygnRW5hYmxpbmcgc2VydmVyIG1vZGUnKTtcblx0XHRcdHRoaXMuc2VydmVyTW9kZSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdHRoaXMuc2VydmVyID0gbmV3IFdlYlNvY2tldFNlcnZlcihvcHRzLCAoKSA9PiByZXNvbHZlKHRoaXMuc2VydmVyKSk7XG5cblx0XHRcdHRoaXMuc2VydmVyLm9uKCdjb25uZWN0aW9uJywgKHdzLCByZXEpID0+IHtcblx0XHRcdFx0Y29uc3QgeyByZW1vdGVBZGRyZXNzLCByZW1vdGVQb3J0IH0gPSByZXEuc29ja2V0O1xuXHRcdFx0XHRjb25zdCBrZXkgPSByZW1vdGVBZGRyZXNzICsgJzonICsgcmVtb3RlUG9ydDtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNvbnN0IHsgaGVhZGVycyB9ID0gcmVxO1xuXHRcdFx0XHRcdGNvbnN0IHRlcm1pbmFsID0gbmV3IFRlcm1pbmFsKHtcblx0XHRcdFx0XHRcdHN0ZG91dDogbmV3IE91dHB1dFNvY2tldCgxLCB3cyksXG5cdFx0XHRcdFx0XHRzdGRlcnI6IG5ldyBPdXRwdXRTb2NrZXQoMiwgd3MpXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0bGV0IGJ1ZmZlciA9ICcnO1xuXHRcdFx0XHRcdGxldCBjdXJyZW50ID0gbnVsbDtcblx0XHRcdFx0XHRsZXQgZWNobyA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0bG9nKGAke2hpZ2hsaWdodChrZXkpfSB1cGdyYWRlZCB0byBXZWJTb2NrZXRgKTtcblx0XHRcdFx0XHRsb2coaGVhZGVycyk7XG5cblx0XHRcdFx0XHR3cy5vbignY2xvc2UnLCAoKSA9PiBsb2coYCR7aGlnaGxpZ2h0KGtleSl9IGNsb3NlZCBXZWJTb2NrZXRgKSk7XG5cblx0XHRcdFx0XHR3cy5vbignZXJyb3InLCBlcnIgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKGVyci5jb2RlICE9PSAnRUNPTk5SRVNFVCcpIHtcblx0XHRcdFx0XHRcdFx0ZXJyb3IoZXJyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGNvbnN0IGV4ZWMgPSBhc3luYyAoYXJncywgcG9zdCkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgY29tbWFuZCA9IHNwbGl0KGFyZ3MpO1xuXHRcdFx0XHRcdFx0bG9nKGBSdW5uaW5nOiAke2hpZ2hsaWdodChjb21tYW5kKX1gKTtcblxuXHRcdFx0XHRcdFx0Y3VycmVudCA9IHRoaXMuZXhlYyhjb21tYW5kLCB7XG5cdFx0XHRcdFx0XHRcdGRhdGE6IHtcblx0XHRcdFx0XHRcdFx0XHRjd2Q6ICAgICAgIGRlY29kZShoZWFkZXJzWydjbGlraXQtY3dkJ10pLFxuXHRcdFx0XHRcdFx0XHRcdGVudjogICAgICAgZGVjb2RlKGhlYWRlcnNbJ2NsaWtpdC1lbnYnXSksXG5cdFx0XHRcdFx0XHRcdFx0dXNlckFnZW50OiBoZWFkZXJzWyd1c2VyLWFnZW50J10gfHwgdW5kZWZpbmVkXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBhcmVudENvbnRleHROYW1lczogZGVjb2RlKGhlYWRlcnNbJ2NsaWtpdC1wYXJlbnRzJ10pLFxuXHRcdFx0XHRcdFx0XHR0ZXJtaW5hbFxuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgcG9zdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0XHRwb3N0KCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGxldCBlYyA9IDE7XG5cblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHsgZXhpdENvZGUgfSA9IGF3YWl0IGN1cnJlbnQ7XG5cdFx0XHRcdFx0XHRcdGVjID0gZXhpdENvZGUoKSB8fCAwO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdGVycm9yKGVyci5zdGFjayB8fCBlcnIubWVzc2FnZSB8fCBlcnIudG9TdHJpbmcoKSk7XG5cdFx0XHRcdFx0XHRcdHRlcm1pbmFsLnN0ZGVyci53cml0ZShgJHt0aGlzLnN0eWxlcy5lcnJvcihlcnIudG9TdHJpbmcoKSl9XFxuYCk7XG5cdFx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0bG9nKGBDb21tYW5kIGZpbmlzaGVkIChjb2RlICR7ZWN9KWApO1xuXHRcdFx0XHRcdFx0XHR3cy5zZW5kKGFuc2kuY3VzdG9tLmV4aXQoZWMpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0d3Mub24oJ21lc3NhZ2UnLCBhc3luYyBtc2cgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKEJ1ZmZlci5pc0J1ZmZlcihtc2cpKSB7XG5cdFx0XHRcdFx0XHRcdG1zZyA9IG1zZy50b1N0cmluZygpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRsZXQgbTtcblxuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0Ly8gY2hlY2sgaWYgd2UgcmVjZWl2ZWQgYSBjdXJzb3IgbWVzc2FnZVxuXHRcdFx0XHRcdFx0XHRtID0gbXNnLm1hdGNoKGFuc2kuY3Vyc29yLnBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdFx0aWYgKG0pIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCByb3dzID0gdGVybWluYWwuc3Rkb3V0LnJvd3MgPSB0ZXJtaW5hbC5zdGRlcnIucm93cyA9IH5+bVsxXTtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBjb2xzID0gdGVybWluYWwuc3Rkb3V0LmNvbHVtbnMgPSB0ZXJtaW5hbC5zdGRlcnIuY29sdW1ucyA9IH5+bVsyXTtcblx0XHRcdFx0XHRcdFx0XHRsb2coYFRlcm1pbmFsIHNldCB0byAke2hpZ2hsaWdodChjb2xzKX0geCAke2hpZ2hsaWdodChyb3dzKX1gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyBjaGVjayBpZiB3ZSByZWNlaXZlZCBhbiBlY2hvIG1lc3NhZ2Vcblx0XHRcdFx0XHRcdFx0bSA9IG1zZy5tYXRjaChhbnNpLmN1c3RvbS5lY2hvLnJlKTtcblx0XHRcdFx0XHRcdFx0aWYgKG0pIHtcblx0XHRcdFx0XHRcdFx0XHRlY2hvID0gbVsxXSAhPT0gJ29mZic7XG5cdFx0XHRcdFx0XHRcdFx0bG9nKGBTZXR0aW5nIGVjaG8gJHtoaWdobGlnaHQoZWNobyA/ICdvbicgOiAnb2ZmJyl9YCk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gY2hlY2sgaWYgd2UgcmVjZWl2ZWQgYW4gZXhlY3V0ZSBtZXNzYWdlXG5cdFx0XHRcdFx0XHRcdG0gPSBtc2cubWF0Y2goYW5zaS5jdXN0b20uZXhlYy5yZSk7XG5cdFx0XHRcdFx0XHRcdGlmIChtKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGF3YWl0IGV4ZWMoZGVjb2RlKG1bMV0pKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIGNoZWNrIGlmIHdlIHJlY2VpdmVkIGEga2V5cHJlc3MgbWVzc2FnZVxuXHRcdFx0XHRcdFx0XHRtID0gbXNnLm1hdGNoKGFuc2kuY3VzdG9tLmtleXByZXNzLnJlKTtcblx0XHRcdFx0XHRcdFx0aWYgKG0pIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBrZXkgPSBkZWNvZGUobVsxXSk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoY3VycmVudCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGVybWluYWwuc3RkaW4uZW1pdCgna2V5cHJlc3MnLCBrZXkuc2VxdWVuY2UsIGtleSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0bXNnID0ga2V5LnNlcXVlbmNlO1xuXHRcdFx0XHRcdFx0XHRcdG0gPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gbWVzc2FnZSBpcyBhIHJhdyBtZXNzYWdlLCBzbyB3ZSBoYXZlIHRvIGNsZWFuIGl0IHVwLCBidWZmZXIsIGFuZCBtYW51YWxseSBkaXNwYXRjaFxuXG5cdFx0XHRcdFx0XHRcdG1zZyA9IG1zZy5yZXBsYWNlKC9cXHJcXG58XFxufFxcci9nLCAnXFxyXFxuJyk7IC8vIG5vcm1hbGl6ZSBuZXcgbGluZXNcblx0XHRcdFx0XHRcdFx0bXNnID0gbXNnLnJlcGxhY2UoL1xceDdmL2csICdcXGInKTsgLy8gbm9ybWFsaXplIGJhY2tzcGFjZXNcblxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBzdXBwb3J0IGN1cnNvciBwb3NpdGlvblxuXG5cdFx0XHRcdFx0XHRcdC8vIHJlcGVhdCBiYWNrIHRvIHRoZSBjbGllbnQgd2hhdCB0aGV5IGp1c3QgcGFzc2VkIHVzXG5cdFx0XHRcdFx0XHRcdGlmIChlY2hvKSB7XG5cdFx0XHRcdFx0XHRcdFx0d3Muc2VuZChtc2cucmVwbGFjZSgvW1xcYl0vZywgJ1xcYiBcXGInKSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGVyZSdzIGFscmVhZHkgYW4gYWN0aXZlIGNvbW1hbmQsIHRyZWF0IG1lc3NhZ2UgYXMgYW4gaW5jb21pbmcga2V5IGZyb20gc3RkaW5cblx0XHRcdFx0XHRcdFx0aWYgKGN1cnJlbnQpIHtcblx0XHRcdFx0XHRcdFx0XHR0ZXJtaW5hbC5zdGRpbi5lbWl0KCdrZXlwcmVzcycsIG1zZywgZ2VuZXJhdGVLZXkobXNnKSk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gbm8gcGVuZGluZyBjb21tYW5kLCBzbyB3ZSBuZWVkIHRvIGJ1ZmZlciBhbmQgYXMgc29vbiBhcyB3ZSBzZWUgYSBsaW5lIHJldHVybixcblx0XHRcdFx0XHRcdFx0Ly8gdGhlbiB3ZSBleGVjdXRlIGl0IGFuZCBhbnkgcmVtYWluaW5nIGNoYXJhY3RlcnMgYXJlIHRyZWF0ZWQgYXMga2V5cHJlc3Nlc1xuXG5cdFx0XHRcdFx0XHRcdGJ1ZmZlciArPSBtc2c7XG5cblx0XHRcdFx0XHRcdFx0Ly8gcmVwbGFjZSBiYWNrc3BhY2VzXG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IHAgPSAwOyAocCA9IGJ1ZmZlci5pbmRleE9mKCdcXGInLCBwKSkgIT09IC0xOykge1xuXHRcdFx0XHRcdFx0XHRcdGJ1ZmZlciA9IGJ1ZmZlci5zdWJzdHJpbmcoMCwgcCAtIDEpICsgYnVmZmVyLnN1YnN0cmluZyhwICsgMSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRsZXQgcCA9IGJ1ZmZlci5pbmRleE9mKCdcXHInKTtcblx0XHRcdFx0XHRcdFx0aWYgKHAgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgY29tbWFuZCA9IGJ1ZmZlci5zdWJzdHJpbmcoMCwgcCk7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3Qgc3RyID0gYnVmZmVyLnN1YnN0cmluZyhwICsgMik7XG5cdFx0XHRcdFx0XHRcdFx0YnVmZmVyID0gJyc7XG5cdFx0XHRcdFx0XHRcdFx0YXdhaXQgZXhlYyhjb21tYW5kLCAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoc3RyLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRlcm1pbmFsLnN0ZGluLndyaXRlKHN0cik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdhcm4oJ0ZhaWxlZCB0byB3cml0ZSB0byBzdGRpbicpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdhcm4oZXJyKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0XHRpZiAobSkge1xuXHRcdFx0XHRcdFx0XHRcdGJ1ZmZlciA9ICcnO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQvLyBnZXQgdGhlIHJlbW90ZSB0ZXJtaW5hbCBzaXplXG5cdFx0XHRcdFx0d3Muc2VuZChhbnNpLmN1cnNvci5zYXZlKTtcblx0XHRcdFx0XHR3cy5zZW5kKGFuc2kuY3Vyc29yLm1vdmUoOTk5LCA5OTkpKTtcblx0XHRcdFx0XHR3cy5zZW5kKGFuc2kuY3Vyc29yLmdldCk7XG5cdFx0XHRcdFx0d3Muc2VuZChhbnNpLmN1cnNvci5yZXN0b3JlKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0d2FybihlcnIpO1xuXHRcdFx0XHRcdHdhcm4oYEhhbmdpbmcgdXAgJHtoaWdobGlnaHQoa2V5KX1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuc2VydmVyLm9uKCdlcnJvcicsIHJlamVjdCk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc2NoZW1hIGZvciB0aGUgQ0xJIGFuZCBhbGwgY2hpbGQgY29udGV4dHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBWYXJpb3VzIG9wdGlvbnMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5kYXRhXSAtIFVzZXItZGVmaW5lZCBkYXRhIHRvIHBhc3MgaW50byB0aGUgc2VsZWN0ZWQgY29tbWFuZC5cblx0ICogQHJldHVybnMge09iamVjdH1cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICovXG5cdGFzeW5jIHNjaGVtYShvcHRzID0ge30pIHtcblx0XHRjb25zdCBvYmogPSB7XG5cdFx0XHRhcmdzOiAgICAgICBbXSxcblx0XHRcdGJhbm5lcjogICAgIFN0cmluZyh0eXBlb2YgdGhpcy5iYW5uZXIgPT09ICdmdW5jdGlvbicgPyAoYXdhaXQgdGhpcy5iYW5uZXIob3B0cykpIDogdGhpcy5iYW5uZXIpLnRyaW0oKSxcblx0XHRcdGNvbW1hbmRzOiAgIHt9LFxuXHRcdFx0ZGVzYzogICAgICAgdGhpcy5kZXNjLFxuXHRcdFx0ZXh0ZW5zaW9uczoge30sXG5cdFx0XHRuYW1lOiAgICAgICB0aGlzLm5hbWUsXG5cdFx0XHRvcHRpb25zOiAgICB7fSxcblx0XHRcdHRpdGxlOiAgICAgIHRoaXMudGl0bGUsXG5cdFx0XHR2ZXJzaW9uOiAgICBTdHJpbmcodHlwZW9mIHRoaXMudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyA/IChhd2FpdCB0aGlzLnZlcnNpb24ob3B0cykpIDogdGhpcy52ZXJzaW9uKS50cmltKClcblx0XHR9O1xuXG5cdFx0Zm9yIChjb25zdCBhcmcgb2YgdGhpcy5hcmdzKSB7XG5cdFx0XHRpZiAoIWFyZy5oaWRkZW4pIHtcblx0XHRcdFx0b2JqLmFyZ3MucHVzaChhcmcuc2NoZW1hKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGNvbnN0IFsgbmFtZSwgY21kIF0gb2YgdGhpcy5jb21tYW5kcy5lbnRyaWVzKCkpIHtcblx0XHRcdG9iai5jb21tYW5kc1tuYW1lXSA9IGF3YWl0IGNtZC5zY2hlbWEob3B0cyk7XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBbIG5hbWUsIGV4dCBdIG9mIHRoaXMuZXh0ZW5zaW9ucy5lbnRyaWVzKCkpIHtcblx0XHRcdG9iai5leHRlbnNpb25zW25hbWVdID0gYXdhaXQgZXh0LnNjaGVtYShvcHRzKTtcblx0XHR9XG5cblx0XHRmb3IgKGNvbnN0IG9wdGlvbnMgb2YgdGhpcy5vcHRpb25zLnZhbHVlcygpKSB7XG5cdFx0XHRmb3IgKGNvbnN0IG9wdCBvZiBvcHRpb25zKSB7XG5cdFx0XHRcdGlmICghb3B0LmhpZGRlbikge1xuXHRcdFx0XHRcdG9iai5vcHRpb25zW29wdC5mb3JtYXRdID0gYXdhaXQgb3B0LnNjaGVtYShvcHRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH1cbn1cbiJdLCJmaWxlIjoiY2xpLmpzIn0=
