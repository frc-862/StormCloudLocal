"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.HookEmitter = void 0;

/* istanbul ignore if */
if (!Error.prepareStackTrace) {
  require('source-map-support/register');
}
/**
 * Emits events and hooks to synchronous and asynchronous listeners.
 */


class HookEmitter {
  /**
   * Constructs an HookEmitter object.
   *
   * @access public
   */
  constructor() {
    this._events = new Map();
    this._links = [];
  }
  /**
   * An iterator for returning all events.
   * @type {Iterator}
   */


  get events() {
    return this._events;
  }
  /**
   * Adds an event listener.
   *
   * @param {String} event - One or more space-separated event names to add
   * the listener to.
   * @param {Number} [priority=0] - The priority of listener. The higher the
   * priority, the sooner it will be executed.
   * @param {Function} listener - A function to call when the event is emitted.
   * @returns {HookEmitter}
   * @access public
   */


  on(event, priority = 0, listener) {
    if (!event || typeof event !== 'string') {
      throw new TypeError('Expected event name to be a valid string.');
    }

    if (typeof priority === 'function') {
      listener = priority;
      priority = 0;
    }

    if (typeof priority !== 'number') {
      throw new TypeError('Expected priority to be a number.');
    }

    if (typeof listener !== 'function') {
      throw new TypeError('Expected listener to be a function.');
    }

    let events = event.split(/\s/);
    let evt;

    while (evt = events.shift()) {
      if (evt) {
        let listeners = this._events.get(evt);

        if (!listeners) {
          this._events.set(evt, listeners = []);
        }

        listeners.push({
          listener,
          priority
        });
      }
    }

    return this;
  }
  /**
   * Adds an event listener that will only be called once.
   *
   * @param {String} event - One or more space-separated event names to add
   * the listener to.
   * @param {Number} [priority=0] - The priority of listener. The higher the
   * priority, the sooner it will be executed.
   * @param {Function} listener - A function to call when the event is emitted.
   * @returns {HookEmitter}
   * @access public
   */


  once(event, priority = 0, listener) {
    if (!event || typeof event !== 'string') {
      throw new TypeError('Expected event name to be a valid string.');
    }

    if (typeof priority === 'function') {
      listener = priority;
      priority = 0;
    } else if (typeof priority !== 'number') {
      throw new TypeError('Expected priority to be a number.');
    }

    if (typeof listener !== 'function') {
      throw new TypeError('Expected listener to be a function.');
    }

    let events = event.split(/\s/);

    for (let evt of events) {
      if (evt) {
        let listeners = this._events.get(evt);

        if (!listeners) {
          this._events.set(evt, listeners = []);
        }

        let wrapper = function () {
          this.off(evt, wrapper);
          listener.apply(this, arguments);
        }.bind(this);

        listeners.push({
          listener: wrapper,
          priority
        });
      }
    }

    return this;
  }
  /**
   * Removes an event listener.
   *
   * @param {String} event - One or more space-separated event names to remove
   * the listener from.
   * @param {Function} [listener] - The listener function. If not specified,
   * then all listeners for the specified event are removed.
   * @returns {HookEmitter}
   * @access public
   */


  off(event, listener) {
    if (!event || typeof event !== 'string') {
      throw new TypeError('Expected event name to be a valid string.');
    }

    if (listener && typeof listener !== 'function') {
      throw new TypeError('Expected listener to be a function.');
    }

    let events = event.split(/\s/);
    let evt;

    while (evt = events.shift()) {
      if (!listener) {
        // remove them all
        this._events.delete(evt);

        continue;
      }

      let listeners = this._events.get(evt);

      if (!listeners) {
        continue;
      }

      const len = listeners.length;

      if (len === 1 && listeners[0].listener === listener) {
        // there was only one event and this was it, so
        // nuke the entire event from the map
        this._events.delete(evt);

        continue;
      }

      for (let i = 0; i < len; i++) {
        if (listeners[i].listener === listener) {
          listeners.splice(i, 1);
          break;
        }
      }
    }

    return this;
  }
  /**
   * Converts an array of listeners into a promise chain
   *
   * @param {Object} [opts] - Various options.
   * @param {Function} [opts.callback] - An optional function to call after
   * all listeners have been fired.
   * @param {Function} [opts.transform] - An function that transforms a result
   * with the original payload.
   * @param {String} [opts.type] - The event type.
   * @returns {Function}
   * @access private
   */


  compose({
    type,
    callback,
    transform
  }) {
    if (callback && typeof callback !== 'function') {
      throw new TypeError('Expected callback to be a function.');
    }

    if (typeof transform !== 'function') {
      // define the default transform for passing results to the next
      // listener in the chain
      transform = (result, payload) => ({
        type: payload.type,
        args: result !== undefined ? result : payload.args
      });
    } // create the function that fetches the events since the list of
    // listeners may change before the hook is called


    const getListeners = () => {
      let listeners = this._events.get(type) || [];

      if (!Array.isArray(listeners)) {
        throw new TypeError('Expected listeners to be an array.');
      } // clone the listeners


      listeners = [...listeners];

      for (const link of this._links) {
        listeners.push({
          listener: link.emitter.compose({
            type: (link.prefix || '') + type
          }),
          priority: 0
        });
      }

      return listeners.sort((a, b) => b.priority - a.priority).map(p => {
        if (typeof p.listener !== 'function') {
          throw new TypeError('Expected listener to be a function.');
        }

        return p.listener;
      });
    }; // return the wrapped function


    return function (...args) {
      const listeners = getListeners();
      const ctx = this;

      if (callback) {
        listeners.push(callback);
      } // start the chain and return its promise


      return dispatch({
        type: type,
        args: args
      }, 0);

      function dispatch(payload, i) {
        let listener = listeners[i];

        if (!listener) {
          return Promise.resolve(payload);
        }

        return new Promise((resolve, reject) => {
          let fired = false;
          let innerResult; // construct the args

          const args = [...(Array.isArray(payload.args) ? payload.args : [payload.args]), function next(result) {
            if (fired) {
              return;
            }

            fired = true; // if somebody mixes paradigms and calls next().then(),
            // at least their function will wait for the next listener

            return dispatch(result || payload, i + 1).then(result => innerResult = result !== undefined ? result : payload).catch(reject);
          }]; // call the listener

          let result = listener.apply(ctx, args);

          if (result === undefined && fired) {
            result = Promise.resolve();
          } // if we got back a promise, we have to wait


          if (result instanceof Promise) {
            return result.then(result => {
              result = transform(fired && innerResult !== undefined ? innerResult : result, payload);
              return fired ? result : dispatch(result, i + 1);
            }).then(resolve).catch(reject);
          }

          return dispatch(transform(result, payload), i + 1).then(resolve, reject);
        });
      }
    };
  }
  /**
   * Emits one or more events.
   *
   * @param {String} event - The name of the event to emit.
   * @param {...*} [args] - One or more additional arguments to be emitted
   * with the event.
   * @returns {Promise}
   * @access public
   */


  async emit(event, ...args) {
    if (!event || typeof event !== 'string') {
      throw new TypeError('Expected event name to be a valid string.');
    }

    return await this.compose({
      type: event
    }).apply(this, args);
  }
  /**
   * Creates a function hook.
   *
   * @param {String} event - The name of the hook's event.
   * @param {Object} [ctx] - The context to run the function in. Useful if
   * `fn` is going to be overwritten.
   * @param {Function} fn - The function being hooked up.
   * @returns {Function}
   * @access public
   */


  hook(event, ctx, fn) {
    if (!event || typeof event !== 'string') {
      throw new TypeError('Expected event name to be a valid string.');
    } // shift arguments if necessary


    if (typeof ctx === 'function' && !fn) {
      fn = ctx;
      ctx = null;
    }

    if (ctx && typeof ctx !== 'object') {
      throw new TypeError('Expected context to be an object.');
    }

    if (typeof fn !== 'function') {
      throw new TypeError('Expected hooked function to be a function.');
    }

    return (...args) => {
      const data = {
        type: event,
        fn,
        args,
        ctx
      };
      const chain = this.compose({
        type: event,
        callback: async function (...args) {
          this.result = await this.fn.apply(this.ctx, this.args);
          return this;
        },
        transform: (result, data) => result !== undefined ? result : data
      });
      return chain.apply(data, data.args).then(data => data.result);
    };
  }
  /**
   * Links all listeners from another hook emitter into this instance. When an
   * event is emitted, it will notify all of this instance's listeners, then
   * notify all linked hook emitter's listeners. Same applies to hooked
   * functions.
   *
   * @param {HookEmitter} emitter - A hook emitter to link to.
   * @param {String} [prefix] - A string to prefix to all emitted event names.
   * @returns {HookEmitter}
   * @access public
   */


  link(emitter, prefix) {
    if (!(emitter instanceof HookEmitter)) {
      throw new TypeError('Expected argument to be a HookEmitter.');
    }

    this._links.push({
      emitter,
      prefix
    });

    return this;
  }
  /**
   * Unlinks all listeners from another hook emitter from this instance.
   *
   * @param {HookEmitter} emitter - A hook emitter to unlink.
   * @returns {HookEmitter}
   * @access public
   */


  unlink(emitter) {
    if (!(emitter instanceof HookEmitter)) {
      throw new TypeError('Expected argument to be a HookEmitter.');
    }

    for (let i = 0; i < this._links.length; i++) {
      if (this._links[i].emitter === emitter) {
        this._links.splice(i--, 1);
      }
    }

    return this;
  }

}

exports.HookEmitter = HookEmitter;
var _default = HookEmitter;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbIkVycm9yIiwicHJlcGFyZVN0YWNrVHJhY2UiLCJyZXF1aXJlIiwiSG9va0VtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsIl9ldmVudHMiLCJNYXAiLCJfbGlua3MiLCJldmVudHMiLCJvbiIsImV2ZW50IiwicHJpb3JpdHkiLCJsaXN0ZW5lciIsIlR5cGVFcnJvciIsInNwbGl0IiwiZXZ0Iiwic2hpZnQiLCJsaXN0ZW5lcnMiLCJnZXQiLCJzZXQiLCJwdXNoIiwib25jZSIsIndyYXBwZXIiLCJvZmYiLCJhcHBseSIsImFyZ3VtZW50cyIsImJpbmQiLCJkZWxldGUiLCJsZW4iLCJsZW5ndGgiLCJpIiwic3BsaWNlIiwiY29tcG9zZSIsInR5cGUiLCJjYWxsYmFjayIsInRyYW5zZm9ybSIsInJlc3VsdCIsInBheWxvYWQiLCJhcmdzIiwidW5kZWZpbmVkIiwiZ2V0TGlzdGVuZXJzIiwiQXJyYXkiLCJpc0FycmF5IiwibGluayIsImVtaXR0ZXIiLCJwcmVmaXgiLCJzb3J0IiwiYSIsImIiLCJtYXAiLCJwIiwiY3R4IiwiZGlzcGF0Y2giLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImZpcmVkIiwiaW5uZXJSZXN1bHQiLCJuZXh0IiwidGhlbiIsImNhdGNoIiwiZW1pdCIsImhvb2siLCJmbiIsImRhdGEiLCJjaGFpbiIsInVubGluayJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0EsSUFBSSxDQUFDQSxLQUFLLENBQUNDLGlCQUFYLEVBQThCO0FBQzdCQyxFQUFBQSxPQUFPLENBQUMsNkJBQUQsQ0FBUDtBQUNBO0FBRUQ7QUFDQTtBQUNBOzs7QUFDTyxNQUFNQyxXQUFOLENBQWtCO0FBQ3hCO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQ0MsRUFBQUEsV0FBVyxHQUFHO0FBQ2IsU0FBS0MsT0FBTCxHQUFlLElBQUlDLEdBQUosRUFBZjtBQUNBLFNBQUtDLE1BQUwsR0FBYyxFQUFkO0FBQ0E7QUFFRDtBQUNEO0FBQ0E7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dkMsYUFBS3JDLE1BQUwsQ0FBWXdCLE1BQVosQ0FBbUJELENBQUMsRUFBcEIsRUFBd0IsQ0FBeEI7QUFDQTtBQUNEOztBQUVELFdBQU8sSUFBUDtBQUNBOztBQXpZdUI7OztlQTRZVjNCLFciLCJzb3VyY2VzQ29udGVudCI6WyIvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICghRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UpIHtcblx0cmVxdWlyZSgnc291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyJyk7XG59XG5cbi8qKlxuICogRW1pdHMgZXZlbnRzIGFuZCBob29rcyB0byBzeW5jaHJvbm91cyBhbmQgYXN5bmNocm9ub3VzIGxpc3RlbmVycy5cbiAqL1xuZXhwb3J0IGNsYXNzIEhvb2tFbWl0dGVyIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYW4gSG9va0VtaXR0ZXIgb2JqZWN0LlxuXHQgKlxuXHQgKiBAYWNjZXNzIHB1YmxpY1xuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5fZXZlbnRzID0gbmV3IE1hcCgpO1xuXHRcdHRoaXMuX2xpbmtzID0gW107XG5cdH1cblxuXHQvKipcblx0ICogQW4gaXRlcmF0b3IgZm9yIHJldHVybmluZyBhbGwgZXZlbnRzLlxuXHQgKiBAdHlwZSB7SXRlcmF0b3J9XG5cdCAqL1xuXHRnZXQgZXZlbnRzKCkge1xuXHRcdHJldHVybiB0aGlzLl9ldmVudHM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhbiBldmVudCBsaXN0ZW5lci5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IC0gT25lIG9yIG1vcmUgc3BhY2Utc2VwYXJhdGVkIGV2ZW50IG5hbWVzIHRvIGFkZFxuXHQgKiB0aGUgbGlzdGVuZXIgdG8uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHk9MF0gLSBUaGUgcHJpb3JpdHkgb2YgbGlzdGVuZXIuIFRoZSBoaWdoZXIgdGhlXG5cdCAqIHByaW9yaXR5LCB0aGUgc29vbmVyIGl0IHdpbGwgYmUgZXhlY3V0ZWQuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gQSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQuXG5cdCAqIEByZXR1cm5zIHtIb29rRW1pdHRlcn1cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICovXG5cdG9uKGV2ZW50LCBwcmlvcml0eSA9IDAsIGxpc3RlbmVyKSB7XG5cdFx0aWYgKCFldmVudCB8fCB0eXBlb2YgZXZlbnQgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBldmVudCBuYW1lIHRvIGJlIGEgdmFsaWQgc3RyaW5nLicpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgcHJpb3JpdHkgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGxpc3RlbmVyID0gcHJpb3JpdHk7XG5cdFx0XHRwcmlvcml0eSA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiBwcmlvcml0eSAhPT0gJ251bWJlcicpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHByaW9yaXR5IHRvIGJlIGEgbnVtYmVyLicpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG5cdFx0fVxuXG5cdFx0bGV0IGV2ZW50cyA9IGV2ZW50LnNwbGl0KC9cXHMvKTtcblx0XHRsZXQgZXZ0O1xuXG5cdFx0d2hpbGUgKGV2dCA9IGV2ZW50cy5zaGlmdCgpKSB7XG5cdFx0XHRpZiAoZXZ0KSB7XG5cdFx0XHRcdGxldCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMuZ2V0KGV2dCk7XG5cdFx0XHRcdGlmICghbGlzdGVuZXJzKSB7XG5cdFx0XHRcdFx0dGhpcy5fZXZlbnRzLnNldChldnQsIGxpc3RlbmVycyA9IFtdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBwcmlvcml0eSB9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgd2lsbCBvbmx5IGJlIGNhbGxlZCBvbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgLSBPbmUgb3IgbW9yZSBzcGFjZS1zZXBhcmF0ZWQgZXZlbnQgbmFtZXMgdG8gYWRkXG5cdCAqIHRoZSBsaXN0ZW5lciB0by5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwcmlvcml0eT0wXSAtIFRoZSBwcmlvcml0eSBvZiBsaXN0ZW5lci4gVGhlIGhpZ2hlciB0aGVcblx0ICogcHJpb3JpdHksIHRoZSBzb29uZXIgaXQgd2lsbCBiZSBleGVjdXRlZC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBBIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZC5cblx0ICogQHJldHVybnMge0hvb2tFbWl0dGVyfVxuXHQgKiBAYWNjZXNzIHB1YmxpY1xuXHQgKi9cblx0b25jZShldmVudCwgcHJpb3JpdHkgPSAwLCBsaXN0ZW5lcikge1xuXHRcdGlmICghZXZlbnQgfHwgdHlwZW9mIGV2ZW50ICE9PSAnc3RyaW5nJykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgZXZlbnQgbmFtZSB0byBiZSBhIHZhbGlkIHN0cmluZy4nKTtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIHByaW9yaXR5ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRsaXN0ZW5lciA9IHByaW9yaXR5O1xuXHRcdFx0cHJpb3JpdHkgPSAwO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHByaW9yaXR5ICE9PSAnbnVtYmVyJykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgcHJpb3JpdHkgdG8gYmUgYSBudW1iZXIuJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcblx0XHR9XG5cblx0XHRsZXQgZXZlbnRzID0gZXZlbnQuc3BsaXQoL1xccy8pO1xuXG5cdFx0Zm9yIChsZXQgZXZ0IG9mIGV2ZW50cykge1xuXHRcdFx0aWYgKGV2dCkge1xuXHRcdFx0XHRsZXQgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzLmdldChldnQpO1xuXHRcdFx0XHRpZiAoIWxpc3RlbmVycykge1xuXHRcdFx0XHRcdHRoaXMuX2V2ZW50cy5zZXQoZXZ0LCBsaXN0ZW5lcnMgPSBbXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IHdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5vZmYoZXZ0LCB3cmFwcGVyKTtcblx0XHRcdFx0XHRsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9LmJpbmQodGhpcyk7XG5cdFx0XHRcdGxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXI6IHdyYXBwZXIsIHByaW9yaXR5IH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCAtIE9uZSBvciBtb3JlIHNwYWNlLXNlcGFyYXRlZCBldmVudCBuYW1lcyB0byByZW1vdmVcblx0ICogdGhlIGxpc3RlbmVyIGZyb20uXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtsaXN0ZW5lcl0gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uIElmIG5vdCBzcGVjaWZpZWQsXG5cdCAqIHRoZW4gYWxsIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCBldmVudCBhcmUgcmVtb3ZlZC5cblx0ICogQHJldHVybnMge0hvb2tFbWl0dGVyfVxuXHQgKiBAYWNjZXNzIHB1YmxpY1xuXHQgKi9cblx0b2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuXHRcdGlmICghZXZlbnQgfHwgdHlwZW9mIGV2ZW50ICE9PSAnc3RyaW5nJykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgZXZlbnQgbmFtZSB0byBiZSBhIHZhbGlkIHN0cmluZy4nKTtcblx0XHR9XG5cblx0XHRpZiAobGlzdGVuZXIgJiYgdHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuXHRcdH1cblxuXHRcdGxldCBldmVudHMgPSBldmVudC5zcGxpdCgvXFxzLyk7XG5cdFx0bGV0IGV2dDtcblxuXHRcdHdoaWxlIChldnQgPSBldmVudHMuc2hpZnQoKSkge1xuXHRcdFx0aWYgKCFsaXN0ZW5lcikge1xuXHRcdFx0XHQvLyByZW1vdmUgdGhlbSBhbGxcblx0XHRcdFx0dGhpcy5fZXZlbnRzLmRlbGV0ZShldnQpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cy5nZXQoZXZ0KTtcblx0XHRcdGlmICghbGlzdGVuZXJzKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuXG5cdFx0XHRpZiAobGVuID09PSAxICYmIGxpc3RlbmVyc1swXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcblx0XHRcdFx0Ly8gdGhlcmUgd2FzIG9ubHkgb25lIGV2ZW50IGFuZCB0aGlzIHdhcyBpdCwgc29cblx0XHRcdFx0Ly8gbnVrZSB0aGUgZW50aXJlIGV2ZW50IGZyb20gdGhlIG1hcFxuXHRcdFx0XHR0aGlzLl9ldmVudHMuZGVsZXRlKGV2dCk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGlmIChsaXN0ZW5lcnNbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG5cdFx0XHRcdFx0bGlzdGVuZXJzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGFuIGFycmF5IG9mIGxpc3RlbmVycyBpbnRvIGEgcHJvbWlzZSBjaGFpblxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gVmFyaW91cyBvcHRpb25zLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5jYWxsYmFja10gLSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0byBjYWxsIGFmdGVyXG5cdCAqIGFsbCBsaXN0ZW5lcnMgaGF2ZSBiZWVuIGZpcmVkLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy50cmFuc2Zvcm1dIC0gQW4gZnVuY3Rpb24gdGhhdCB0cmFuc2Zvcm1zIGEgcmVzdWx0XG5cdCAqIHdpdGggdGhlIG9yaWdpbmFsIHBheWxvYWQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy50eXBlXSAtIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259XG5cdCAqIEBhY2Nlc3MgcHJpdmF0ZVxuXHQgKi9cblx0Y29tcG9zZSh7IHR5cGUsIGNhbGxiYWNrLCB0cmFuc2Zvcm0gfSkge1xuXHRcdGlmIChjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGNhbGxiYWNrIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiB0cmFuc2Zvcm0gIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdC8vIGRlZmluZSB0aGUgZGVmYXVsdCB0cmFuc2Zvcm0gZm9yIHBhc3NpbmcgcmVzdWx0cyB0byB0aGUgbmV4dFxuXHRcdFx0Ly8gbGlzdGVuZXIgaW4gdGhlIGNoYWluXG5cdFx0XHR0cmFuc2Zvcm0gPSAocmVzdWx0LCBwYXlsb2FkKSA9PiAoe1xuXHRcdFx0XHR0eXBlOiBwYXlsb2FkLnR5cGUsXG5cdFx0XHRcdGFyZ3M6IHJlc3VsdCAhPT0gdW5kZWZpbmVkID8gcmVzdWx0IDogcGF5bG9hZC5hcmdzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBjcmVhdGUgdGhlIGZ1bmN0aW9uIHRoYXQgZmV0Y2hlcyB0aGUgZXZlbnRzIHNpbmNlIHRoZSBsaXN0IG9mXG5cdFx0Ly8gbGlzdGVuZXJzIG1heSBjaGFuZ2UgYmVmb3JlIHRoZSBob29rIGlzIGNhbGxlZFxuXHRcdGNvbnN0IGdldExpc3RlbmVycyA9ICgpID0+IHtcblx0XHRcdGxldCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMuZ2V0KHR5cGUpIHx8IFtdO1xuXHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KGxpc3RlbmVycykpIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgbGlzdGVuZXJzIHRvIGJlIGFuIGFycmF5LicpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjbG9uZSB0aGUgbGlzdGVuZXJzXG5cdFx0XHRsaXN0ZW5lcnMgPSBbIC4uLmxpc3RlbmVycyBdO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGxpbmsgb2YgdGhpcy5fbGlua3MpIHtcblx0XHRcdFx0bGlzdGVuZXJzLnB1c2goe1xuXHRcdFx0XHRcdGxpc3RlbmVyOiBsaW5rLmVtaXR0ZXIuY29tcG9zZSh7XG5cdFx0XHRcdFx0XHR0eXBlOiAobGluay5wcmVmaXggfHwgJycpICsgdHlwZVxuXHRcdFx0XHRcdH0pLFxuXHRcdFx0XHRcdHByaW9yaXR5OiAwXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbGlzdGVuZXJzXG5cdFx0XHRcdC5zb3J0KChhLCBiKSA9PiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eSlcblx0XHRcdFx0Lm1hcChwID0+IHtcblx0XHRcdFx0XHRpZiAodHlwZW9mIHAubGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBwLmxpc3RlbmVyO1xuXHRcdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0Ly8gcmV0dXJuIHRoZSB3cmFwcGVkIGZ1bmN0aW9uXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0XHRjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnMoKTtcblx0XHRcdGNvbnN0IGN0eCA9IHRoaXM7XG5cblx0XHRcdGlmIChjYWxsYmFjaykge1xuXHRcdFx0XHRsaXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHN0YXJ0IHRoZSBjaGFpbiBhbmQgcmV0dXJuIGl0cyBwcm9taXNlXG5cdFx0XHRyZXR1cm4gZGlzcGF0Y2goe1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRhcmdzOiBhcmdzXG5cdFx0XHR9LCAwKTtcblxuXHRcdFx0ZnVuY3Rpb24gZGlzcGF0Y2gocGF5bG9hZCwgaSkge1xuXHRcdFx0XHRsZXQgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG5cdFx0XHRcdGlmICghbGlzdGVuZXIpIHtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBheWxvYWQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdFx0XHRsZXQgZmlyZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRsZXQgaW5uZXJSZXN1bHQ7XG5cblx0XHRcdFx0XHQvLyBjb25zdHJ1Y3QgdGhlIGFyZ3Ncblx0XHRcdFx0XHRjb25zdCBhcmdzID0gWyAuLi4oQXJyYXkuaXNBcnJheShwYXlsb2FkLmFyZ3MpID8gcGF5bG9hZC5hcmdzIDogWyBwYXlsb2FkLmFyZ3MgXSksIGZ1bmN0aW9uIG5leHQocmVzdWx0KSB7XG5cdFx0XHRcdFx0XHRpZiAoZmlyZWQpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRmaXJlZCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdC8vIGlmIHNvbWVib2R5IG1peGVzIHBhcmFkaWdtcyBhbmQgY2FsbHMgbmV4dCgpLnRoZW4oKSxcblx0XHRcdFx0XHRcdC8vIGF0IGxlYXN0IHRoZWlyIGZ1bmN0aW9uIHdpbGwgd2FpdCBmb3IgdGhlIG5leHQgbGlzdGVuZXJcblx0XHRcdFx0XHRcdHJldHVybiBkaXNwYXRjaChyZXN1bHQgfHwgcGF5bG9hZCwgaSArIDEpXG5cdFx0XHRcdFx0XHRcdC50aGVuKHJlc3VsdCA9PiAoaW5uZXJSZXN1bHQgPSByZXN1bHQgIT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHBheWxvYWQpKVxuXHRcdFx0XHRcdFx0XHQuY2F0Y2gocmVqZWN0KTtcblx0XHRcdFx0XHR9IF07XG5cblx0XHRcdFx0XHQvLyBjYWxsIHRoZSBsaXN0ZW5lclxuXHRcdFx0XHRcdGxldCByZXN1bHQgPSBsaXN0ZW5lci5hcHBseShjdHgsIGFyZ3MpO1xuXHRcdFx0XHRcdGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCAmJiBmaXJlZCkge1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gaWYgd2UgZ290IGJhY2sgYSBwcm9taXNlLCB3ZSBoYXZlIHRvIHdhaXRcblx0XHRcdFx0XHRpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdFxuXHRcdFx0XHRcdFx0XHQudGhlbihyZXN1bHQgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdCA9IHRyYW5zZm9ybShmaXJlZCAmJiBpbm5lclJlc3VsdCAhPT0gdW5kZWZpbmVkID8gaW5uZXJSZXN1bHQgOiByZXN1bHQsIHBheWxvYWQpO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBmaXJlZCA/IHJlc3VsdCA6IGRpc3BhdGNoKHJlc3VsdCwgaSArIDEpO1xuXHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHQudGhlbihyZXNvbHZlKVxuXHRcdFx0XHRcdFx0XHQuY2F0Y2gocmVqZWN0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gZGlzcGF0Y2godHJhbnNmb3JtKHJlc3VsdCwgcGF5bG9hZCksIGkgKyAxKVxuXHRcdFx0XHRcdFx0LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbWl0cyBvbmUgb3IgbW9yZSBldmVudHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBlbWl0LlxuXHQgKiBAcGFyYW0gey4uLip9IFthcmdzXSAtIE9uZSBvciBtb3JlIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIGJlIGVtaXR0ZWRcblx0ICogd2l0aCB0aGUgZXZlbnQuXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHQgKiBAYWNjZXNzIHB1YmxpY1xuXHQgKi9cblx0YXN5bmMgZW1pdChldmVudCwgLi4uYXJncykge1xuXHRcdGlmICghZXZlbnQgfHwgdHlwZW9mIGV2ZW50ICE9PSAnc3RyaW5nJykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgZXZlbnQgbmFtZSB0byBiZSBhIHZhbGlkIHN0cmluZy4nKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYXdhaXQgdGhpcy5jb21wb3NlKHtcblx0XHRcdHR5cGU6IGV2ZW50XG5cdFx0fSkuYXBwbHkodGhpcywgYXJncyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGhvb2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCAtIFRoZSBuYW1lIG9mIHRoZSBob29rJ3MgZXZlbnQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbY3R4XSAtIFRoZSBjb250ZXh0IHRvIHJ1biB0aGUgZnVuY3Rpb24gaW4uIFVzZWZ1bCBpZlxuXHQgKiBgZm5gIGlzIGdvaW5nIHRvIGJlIG92ZXJ3cml0dGVuLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiBiZWluZyBob29rZWQgdXAuXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn1cblx0ICogQGFjY2VzcyBwdWJsaWNcblx0ICovXG5cdGhvb2soZXZlbnQsIGN0eCwgZm4pIHtcblx0XHRpZiAoIWV2ZW50IHx8IHR5cGVvZiBldmVudCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGV2ZW50IG5hbWUgdG8gYmUgYSB2YWxpZCBzdHJpbmcuJyk7XG5cdFx0fVxuXG5cdFx0Ly8gc2hpZnQgYXJndW1lbnRzIGlmIG5lY2Vzc2FyeVxuXHRcdGlmICh0eXBlb2YgY3R4ID09PSAnZnVuY3Rpb24nICYmICFmbikge1xuXHRcdFx0Zm4gPSBjdHg7XG5cdFx0XHRjdHggPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChjdHggJiYgdHlwZW9mIGN0eCAhPT0gJ29iamVjdCcpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGNvbnRleHQgdG8gYmUgYW4gb2JqZWN0LicpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGhvb2tlZCBmdW5jdGlvbiB0byBiZSBhIGZ1bmN0aW9uLicpO1xuXHRcdH1cblxuXHRcdHJldHVybiAoLi4uYXJncykgPT4ge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdFx0dHlwZTogZXZlbnQsXG5cdFx0XHRcdGZuLFxuXHRcdFx0XHRhcmdzLFxuXHRcdFx0XHRjdHhcblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IGNoYWluID0gdGhpcy5jb21wb3NlKHtcblx0XHRcdFx0dHlwZTogZXZlbnQsXG5cdFx0XHRcdGNhbGxiYWNrOiBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdFx0XHRcdHRoaXMucmVzdWx0ID0gYXdhaXQgdGhpcy5mbi5hcHBseSh0aGlzLmN0eCwgdGhpcy5hcmdzKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0dHJhbnNmb3JtOiAocmVzdWx0LCBkYXRhKSA9PiByZXN1bHQgIT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRhdGFcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gY2hhaW4uYXBwbHkoZGF0YSwgZGF0YS5hcmdzKS50aGVuKGRhdGEgPT4gZGF0YS5yZXN1bHQpO1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogTGlua3MgYWxsIGxpc3RlbmVycyBmcm9tIGFub3RoZXIgaG9vayBlbWl0dGVyIGludG8gdGhpcyBpbnN0YW5jZS4gV2hlbiBhblxuXHQgKiBldmVudCBpcyBlbWl0dGVkLCBpdCB3aWxsIG5vdGlmeSBhbGwgb2YgdGhpcyBpbnN0YW5jZSdzIGxpc3RlbmVycywgdGhlblxuXHQgKiBub3RpZnkgYWxsIGxpbmtlZCBob29rIGVtaXR0ZXIncyBsaXN0ZW5lcnMuIFNhbWUgYXBwbGllcyB0byBob29rZWRcblx0ICogZnVuY3Rpb25zLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0hvb2tFbWl0dGVyfSBlbWl0dGVyIC0gQSBob29rIGVtaXR0ZXIgdG8gbGluayB0by5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtwcmVmaXhdIC0gQSBzdHJpbmcgdG8gcHJlZml4IHRvIGFsbCBlbWl0dGVkIGV2ZW50IG5hbWVzLlxuXHQgKiBAcmV0dXJucyB7SG9va0VtaXR0ZXJ9XG5cdCAqIEBhY2Nlc3MgcHVibGljXG5cdCAqL1xuXHRsaW5rKGVtaXR0ZXIsIHByZWZpeCkge1xuXHRcdGlmICghKGVtaXR0ZXIgaW5zdGFuY2VvZiBIb29rRW1pdHRlcikpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGFyZ3VtZW50IHRvIGJlIGEgSG9va0VtaXR0ZXIuJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGlua3MucHVzaCh7IGVtaXR0ZXIsIHByZWZpeCB9KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVubGlua3MgYWxsIGxpc3RlbmVycyBmcm9tIGFub3RoZXIgaG9vayBlbWl0dGVyIGZyb20gdGhpcyBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtIb29rRW1pdHRlcn0gZW1pdHRlciAtIEEgaG9vayBlbWl0dGVyIHRvIHVubGluay5cblx0ICogQHJldHVybnMge0hvb2tFbWl0dGVyfVxuXHQgKiBAYWNjZXNzIHB1YmxpY1xuXHQgKi9cblx0dW5saW5rKGVtaXR0ZXIpIHtcblx0XHRpZiAoIShlbWl0dGVyIGluc3RhbmNlb2YgSG9va0VtaXR0ZXIpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhIEhvb2tFbWl0dGVyLicpO1xuXHRcdH1cblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbGlua3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLl9saW5rc1tpXS5lbWl0dGVyID09PSBlbWl0dGVyKSB7XG5cdFx0XHRcdHRoaXMuX2xpbmtzLnNwbGljZShpLS0sIDEpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEhvb2tFbWl0dGVyO1xuIl0sImZpbGUiOiJpbmRleC5qcyJ9
